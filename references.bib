@inproceedings{2022arbiter,
  title = {Arbiter: {{Bridging}} the {{Static}} and {{Dynamic Divide}} in {{Vulnerability Discovery}} on {{Binary Programs}}},
  shorttitle = {Arbiter},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  year = {2022},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SUYQYZ58\\2022 - Arbiter Bridging the Static and Dynamic Divide in.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\TWZAHDFB\\vadayath.html}
}

@misc{2022sandboxed,
  title = {Sandboxed {{API}}},
  year = {2022},
  month = jul,
  abstract = {Generates sandboxes for C/C++ libraries automatically},
  copyright = {Apache-2.0},
  howpublished = {Google},
  keywords = {cplusplus,cplusplus-17,sandbox,sandboxing,sapi,security,security-hardening}
}

@inproceedings{abubakar2021shard,
  title = {\{\vphantom\}{{SHARD}}\vphantom\{\}: \{\vphantom\}{{Fine-Grained}}\vphantom\{\} {{Kernel Specialization}} with \{\vphantom\}{{Context-Aware}}\vphantom\{\} {{Hardening}}},
  shorttitle = {\{\vphantom\}{{SHARD}}\vphantom\{\}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Abubakar, Muhammad and Ahmad, Adil and Fonseca, Pedro and Xu, Dongyan},
  year = {2021},
  pages = {2435--2452},
  isbn = {978-1-939133-24-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\J6H6ECAQ\\Abubakar et al. - 2021 - SHARD Fine-Grained Kernel Specialization with.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\DRCJN2IL\\abubakar.html}
}

@phdthesis{acher2019learning,
  type = {Report},
  title = {Learning {{Very Large Configuration Spaces}}: {{What Matters}} for {{Linux Kernel Sizes}}},
  shorttitle = {Learning {{Very Large Configuration Spaces}}},
  author = {Acher, Mathieu and Martin, Hugo and Pereira, Juliana Alves and Blouin, Arnaud and J{\'e}z{\'e}quel, Jean-Marc and Khelladi, Djamel Eddine and Lesoil, Luc and Barais, Olivier},
  year = {2019},
  month = oct,
  abstract = {Linux kernels are used in a wide variety of appliances, many of them having strong requirements on the kernel size due to constraints such as limited memory or instant boot. With more than ten thousands of configuration options to choose from, obtaining a suitable trade off between kernel size and functionality is an extremely hard problem. Developers, contributors, and users actually spend significant effort to document, understand, and eventually tune (combinations of) options for meeting a kernel size. In this paper, we investigate how machine learning can help explain what matters for predicting a given Linux kernel size. Unveiling what matters in such very large configuration space is challenging for two reasons: (1) whatever the time we spend on it, we can only build and measure a tiny fraction of possible kernel configurations; (2) the prediction model should be both accurate and interpretable. We compare different machine learning algorithms and demonstrate the benefits of specific feature encoding and selection methods to learn an accurate model that is fast to compute and simple to interpret. Our results are validated over 95,854 kernel configurations and show that we can achieve low prediction errors over a reduced set of options. We also show that we can extract interpretable information for refining documentation and experts' knowledge of Linux, or even assigning more sensible default values to options.},
  langid = {english},
  school = {Inria Rennes - Bretagne Atlantique},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\CJ7D22P5\\Acher et al. - 2019 - Learning Very Large Configuration Spaces What Mat.pdf}
}

@inproceedings{agadakos2019nibbler,
  title = {Nibbler: Debloating Binary Shared Libraries},
  shorttitle = {Nibbler},
  booktitle = {Proceedings of the 35th {{Annual Computer Security Applications Conference}}},
  author = {Agadakos, Ioannis and Jin, Di and {Williams-King}, David and Kemerlis, Vasileios P. and Portokalidis, Georgios},
  year = {2019},
  month = dec,
  series = {{{ACSAC}} '19},
  pages = {70--83},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3359789.3359823},
  abstract = {Developers today have access to an arsenal of toolkits and libraries for rapid application prototyping. However, when an application loads a library, the entirety of that library's code is mapped into the address space, even if only a single function is actually needed. The unused portion is bloat that can negatively impact software defenses by unnecessarily inflating their overhead or increasing their attack surface. Recent work has explored debloating as a way of alleviating the above problems, when source code is available. In this paper, we investigate whether debloating is possible and practical at the binary level. To this end, we present Nibbler: a system that identifies and erases unused functions within shared libraries. Nibbler works in tandem with defenses like continuous code re-randomization and control-flow integrity, enhancing them without incurring additional run-time overhead. We developed and tested a prototype of Nibbler on x86-64 Linux; Nibbler reduces the size of shared libraries and the number of available functions, for real-world binaries and the SPEC CINT2006 suite, by up to 56\% and 82\%, respectively. We also demonstrate that Nibbler benefits defenses by showing that: (i) it improves the deployability of a continuous re-randomization system for binaries, namely Shuffler, by increasing its efficiency by 20\%, and (ii) it improves certain fast, but coarse and context-insensitive control-flow integrity schemes by reducing the number of gadgets reachable through returns and indirect calls by 75\% and 49\% on average.},
  isbn = {978-1-4503-7628-0},
  keywords = {code debloating,software security,static binary analysis},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IVU4KKJ3\\Agadakos et al. - 2019 - Nibbler debloating binary shared libraries.pdf}
}

@article{ahmad2019obfuscuro,
  title = {{{OBFUSCURO}}: {{A Commodity Obfuscation Engine}} on {{Intel SGX}}},
  shorttitle = {{{OBFUSCURO}}},
  author = {Ahmad, Adil and Joe, Byunggill and Xiao, Yuan and Zhang, Yinqian and Shin, Insik and Lee, Byoungyoung},
  year = {2019},
  month = jan,
  journal = {Network and Distributed System Security Symposium},
  abstract = {Program obfuscation is a popular cryptographic construct with a wide range of uses such as IP theft prevention. Although cryptographic solutions for program obfuscation impose impractically high overheads, a recent breakthrough leveraging trusted hardware has shown promise. However, the existing solution is based on special-purpose trusted hardware, restricting its use-cases to a limited few. In this paper, we first study if such obfuscation is feasible based on commodity trusted hardware, Intel SGX, and we observe that certain important security considerations are not afforded by commodity hardware. In particular, we found that existing obfuscation/obliviousness schemes are insecure if directly applied to Intel SGX primarily due to side-channel limitations. To this end, we present OBFUSCURO, the first system providing program obfuscation using commodity trusted hardware, Intel SGX. The key idea is to leverage ORAM operations to perform secure code execution and data access. Initially, OBFUSCURO transforms the regular program layout into a side-channel secure and ORAM-compatible layout. Then, OBFUSCURO ensures that its ORAM controller performs data oblivious accesses in order to protect itself from all memory-based side-channels. Furthermore, OBFUSCURO ensures that the program is secure from timing attacks by ensuring that the program always runs for a pre-configured time interval. Along the way, OBFUSCURO also introduces a systematic optimization such as register-based ORAM stash. We provide a thorough security analysis of OBFUSCURO along with empirical attack evaluations showing that OBFUSCURO can protect the SGX program execution from being leaked by access pattern-based and timing-based channels. We also provide a detailed performance benchmark results in order to show the practical aspects of OBFUSCURO.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LSX6FJWB\\Ahmad et al. - 2019 - OBFUSCURO A Commodity Obfuscation Engine on Intel.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\I2VNHKUV\\10134884.html}
}

@inproceedings{ahmad2021kard,
  title = {Kard: Lightweight Data Race Detection with per-Thread Memory Protection},
  shorttitle = {Kard},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Ahmad, Adil and Lee, Sangho and Fonseca, Pedro and Lee, Byoungyoung},
  year = {2021},
  month = apr,
  series = {{{ASPLOS}} 2021},
  pages = {647--660},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3445814.3446727},
  abstract = {Finding data race bugs in multi-threaded programs has proven challenging. A promising direction is to use dynamic detectors that monitor the program's execution for data races. However, despite extensive work on dynamic data race detection, most proposed systems for commodity hardware incur prohibitive overheads due to expensive compiler instrumentation of memory accesses; hence, they are not efficient enough to be used in all development and testing settings. KARD is a lightweight system that dynamically detects data races caused by inconsistent lock usage\textemdash when a program concurrently accesses the same memory object using different locks or only some of the concurrent accesses are synchronized using a common lock. Unlike existing detectors, KARD does not monitor memory accesses using expensive compiler instrumentation. Instead, KARD leverages commodity per-thread memory protection, Intel Memory Protection Keys (MPK). Using MPK, KARD ensures that a shared object is only accessible to a single thread in its critical section, and captures all violating accesses from other concurrent threads. KARD overcomes various limitations of MPK by introducing key-enforced race detection, employing consolidated unique page allocation, carefully managing protection keys, and automatically pruning out non-racy or redundant violations. Our evaluation shows that KARD detects all data races caused by inconsistent lock usage and has a low geometric mean execution time overhead: 7.0\% on PARSEC and SPLASH-2x benchmarks and 5.3\% on a set of real-world applications (NGINX, memcached, pigz, and Aget).},
  isbn = {978-1-4503-8317-2},
  keywords = {concurrency,data race,lock,memory protection},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QICBL4ZZ\\Ahmad et al. - 2021 - Kard lightweight data race detection with per-thr.pdf}
}

@article{ahmad2021trimmer,
  title = {{{TRIMMER}}: {{An Automated System}} for {{Configuration-based Software Debloating}}},
  shorttitle = {{{TRIMMER}}},
  author = {Ahmad, Aatira Anum and Noor, Abdul Rafae and Sharif, Hashim and Hameed, Usama and Asif, Shoaib and Anwar, Mubashir and Gehani, Ashish and Siddiqui, Junaid Haroon and Zaffar, Fareed M},
  year = {2021},
  journal = {IEEE Transactions on Software Engineering},
  pages = {1--1},
  issn = {1939-3520},
  doi = {10.1109/TSE.2021.3095716},
  abstract = {Software bloat has negative implications for security, reliability, and performance. To counter bloat, we propose TRIMMER, a static analysis-based system for pruning unused functionality. TRIMMER removes code that is unused with respect to user-provided command-line arguments and application-specific configuration files (no low-level source annotations required). TRIMMER uses concrete memory tracking and a custom inter-procedural constant propagation analysis that facilitates dead code elimination. Our system supports both context-sensitive and context-insensitive constant propagation. We show that context-sensitive constant propagation is important for effective software pruning in most applications. We introduce sparse constant propagation that performs constant propagation only for configuration-hosting variables and show that it performs better (higher code size reductions) compared to constant propagation for all program variables. Overall, our results show that TRIMMER reduces binary sizes for real-world programs with reasonable analysis times. Across 20 evaluated programs, we observe a mean binary size reduction of 22.7\% and a maximum reduction of 62.7\%. For 5 programs, we observe performance speedups ranging from 5\% to 53\%. Moreover, we show that winnowing software applications can reduce the program attack surface by removing code that contains exploitable vulnerabilities. We find that debloating using TRIMMER removes CVEs in 4 applications.},
  keywords = {Annotations,Compilers,Optimization,Partial evaluation,Program analysis,Program processors,Security,Software,Standards,Transforms},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\C5U9SZHX\\Ahmad et al. - 2021 - TRIMMER An Automated System for Configuration-bas.pdf}
}

@inproceedings{ainsworth2020markus,
  title = {{{MarkUs}}: {{Drop-in}} Use-after-Free Prevention for Low-Level Languages},
  shorttitle = {{{MarkUs}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Ainsworth, Sam and Jones, Timothy M.},
  year = {2020},
  month = may,
  pages = {578--591},
  publisher = {{IEEE}},
  address = {{San Francisco, CA, USA}},
  doi = {10.1109/SP40000.2020.00058},
  abstract = {Use-after-free vulnerabilities have plagued software written in low-level languages, such as C and C++, becoming one of the most frequent classes of exploited software bugs. Attackers identify code paths where data is manually freed by the programmer, but later incorrectly reused, and take advantage by reallocating the data to themselves. They then alter the data behind the program's back, using the erroneous reuse to gain control of the application and, potentially, the system. While a variety of techniques have been developed to deal with these vulnerabilities, they often have unacceptably high performance or memory overheads, especially in the worst case.},
  isbn = {978-1-72813-497-0},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\I63EVKPI\\Ainsworth and Jones - 2020 - MarkUs Drop-in use-after-free prevention for low-.pdf}
}

@article{akram2020meet,
  title = {Meet the {{Sherlock Holmes}}' of {{Side Channel Leakage}}: {{A Survey}} of {{Cache SCA Detection Techniques}}},
  shorttitle = {Meet the {{Sherlock Holmes}}' of {{Side Channel Leakage}}},
  author = {Akram, Ayaz and Mushtaq, Maria and Bhatti, Muhammad Khurram and Lapotre, Vianney and Gogniat, Guy},
  year = {2020},
  journal = {IEEE Access},
  volume = {8},
  pages = {70836--70860},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2020.2980522},
  abstract = {Cache Side Channel Attacks (SCAs) have gained a lot of attention in the recent past. Since, these attacks exploit the caching hardware vulnerabilities, they are fast and dangerous. Detection of cache side channel attacks is an important step towards mitigating against such hostile entities. Researchers have already proposed different techniques to detect cache side channel attacks. This paper provides a detailed survey of literature related to the state-of-the-art detection techniques for cache based side channel attacks. We identify a set of important characteristics that can be used to characterize a CSCA (cache side channel attack) detection technique. We use the identified features to compare and contrast the most important detection techniques and provide the important observations. We also identify some of the challenges that the research community will have to resolve in future to improve the efficiency of cache side channel detection techniques. To the best of our knowledge, this is the first work to do such a study. We believe that this paper will prove useful to researchers in the area of systems security.},
  keywords = {anomaly \& signature detection,Cache-based side channel attacks (SCAs),cryptography,detection,Hardware,machine learning,Program processors,Side-channel attacks,survey,Timing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BG7HKSVY\\Akram et al. - 2020 - Meet the Sherlock Holmesâ€™ of Side Channel Leakage.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\TQ49ELI2\\9035459.html}
}

@inproceedings{akritidis2008preventing,
  title = {Preventing {{Memory Error Exploits}} with {{WIT}}},
  booktitle = {2008 {{IEEE Symposium}} on {{Security}} and {{Privacy}} (Sp 2008)},
  author = {Akritidis, Periklis and Cadar, Cristian and Raiciu, Costin and Costa, Manuel and Castro, Miguel},
  year = {2008},
  month = may,
  pages = {263--277},
  issn = {2375-1207},
  doi = {10.1109/SP.2008.30},
  abstract = {Attacks often exploit memory errors to gain control over the execution of vulnerable programs. These attacks remain a serious problem despite previous research on techniques to prevent them. We present write integrity testing (WIT), a new technique that provides practical protection from these attacks. WIT uses points-to analysis at compile time to compute the control-flow graph and the set of objects that can be written by each instruction in the program. Then it generates code instrumented to prevent instructions from modifying objects that are not in the set computed by the static analysis, and to ensure that indirect control transfers are allowed by the control-flow graph. To improve coverage where the analysis is not precise enough, WIT inserts small guards between the original program objects. We describe an efficient implementation with optimizations to reduce space and time overhead. This implementation can be used in practice because it compiles C and C++ programs without modifications, it has high coverage with no false positives, and it has low overhead. WIT's average runtime overhead is only 7\% across a set of CPU intensive benchmarks and it is negligible when IO is the bottleneck.},
  keywords = {attack detection,Color,Computer aided instruction,Error correction,Gain control,instrumentation,Instruments,memory errors,points-to analysis,Privacy,Protection,Runtime,s\&p,Security,static analysis,Testing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\DT6687ED\\Akritidis et al. - 2008 - Preventing Memory Error Exploits with WIT.pdf}
}

@inproceedings{alhanahnah2022lightweight,
  title = {Lightweight, {{Multi-Stage}}, {{Compiler-Assisted Application Specialization}}},
  booktitle = {2022 {{IEEE}} 7th {{European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Alhanahnah, Mohannad and Jain, Rithik and Rastogi, Vaibhav and Jha, Somesh and Reps, Thomas},
  year = {2022},
  month = jun,
  pages = {251--269},
  doi = {10.1109/EuroSP53844.2022.00024},
  abstract = {Program debloating aims to enhance the performance and reduce the attack surface of bloated applications. Several techniques have been recently proposed to specialize programs. These approaches are either based on unsound strategies or demanding techniques, leading to unsafe results or a high-overhead debloating process. In this paper, we address these limitations by applying partial-evaluation principles to generate specialized applications. Our approach relies on a simple observation that an application typically consists of configuration logic, followed by the main logic of the program. The configuration logic specifies what functionality in the main logic should be executed. LMCAS performs partial interpretation to capture a precise program state of the configuration logic based on the supplied inputs. LMCAS then applies partial-evaluation optimizations to generate a specialized program by propagating the constants in the captured partial state, eliminating unwanted code, and preserving the desired functionalities. Our evaluation of LMCAS-on commonly used benchmarks and real-world applications-shows that it successfully removes unwanted features while preserving the functionality and robustness of the debloated programs, runs faster than prior tools, and reduces the attack surface of specialized programs. LMCAS runs 1500x, 4.6x, and 1.2x faster than the state-of-the-art debloating tools CHISEL, RAZOR, and OCCAM, respectively; achieves 25\% reduction in the binary size; demonstrates favorable gadgets elimination trade-off; and eliminates 87.5\% of the known CVE vulnerabilities in our test corpus.},
  keywords = {Benchmark testing,Codes,Debloating,Manuals,Neck,Optimization,Partial Evaluation,Program Division,Robustness,Security,Specialization,Surface treatment},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5UB9SNE4\\Alhanahnah et al. - 2022 - Lightweight, Multi-Stage, Compiler-Assisted Applic.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\UT9JHNDC\\9797349.html}
}

@inproceedings{almakhdhub2020mu,
  title = {\$\textbackslash mu\${{RAI}}: {{Securing Embedded Systems}} with {{Return Address Integrity}}},
  shorttitle = {\$\textbackslash mu\${{RAI}}},
  booktitle = {Proceedings 2020 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Almakhdhub, Naif Saleh and Clements, Abraham A. and Bagchi, Saurabh and Payer, Mathias},
  year = {2020},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2020.24016},
  abstract = {Embedded systems are deployed in security critical environments and have become a prominent target for remote attacks. Microcontroller-based systems (MCUS) are particularly vulnerable due to a combination of limited resources and low level programming which leads to bugs. Since MCUS are often a part of larger systems, vulnerabilities may jeopardize not just the security of the device itself but that of other systems as well. For example, exploiting a WiFi System on Chip (SoC) allows an attacker to hijack the smart phone's application processor.},
  isbn = {978-1-891562-61-7},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\89ZDZ5BI\\Almakhdhub et al. - 2020 - $mu$RAI Securing Embedded Systems with Return Ad.pdf}
}

@misc{almatary2022compartos,
  title = {{{CompartOS}}: {{CHERI Compartmentalization}} for {{Embedded Systems}}},
  shorttitle = {{{CompartOS}}},
  author = {Almatary, Hesham and Dodson, Michael and Clarke, Jessica and Rugg, Peter and Gomes, Ivan and Podhradsky, Michal and Neumann, Peter G. and Moore, Simon W. and Watson, Robert N. M.},
  year = {2022},
  month = jun,
  number = {arXiv:2206.02852},
  eprint = {2206.02852},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2206.02852},
  abstract = {Existing high-end embedded systems face frequent security attacks. Software compartmentalization is one technique to limit the attacks' effects to the compromised compartment and not the entire system. Unfortunately, the existing state-of-the-art embedded hardware-software solutions do not work well to enforce software compartmentalization for high-end embedded systems. MPUs are not fine-grained and suffer from significant scalability limitations as they can only protect a small and fixed number of memory regions. On the other hand, MMUs suffer from non-determinism and coarse-grained protection. This paper introduces CompartOS as a lightweight linkage-based compartmentalization model for high-end, complex, mainstream embedded systems. CompartOS builds on CHERI, a capability-based hardware architecture, to meet scalability, availability, compatibility, and fine-grained security goals. Microbenchmarks show that CompartOS' protection-domain crossing is 95\% faster than MPU-based IPC. We applied the CompartOS model, with low effort, to complex existing systems, including TCP servers and a safety-critical automotive demo. CompartOS not only catches 10 out of 13 FreeRTOS-TCP published vulnerabilities that MPU-based protection (e.g., uVisor) cannot catch but can also recover from them. Further, our TCP throughput evaluations show that our CompartOS prototype is 52\% faster than relevant MPU-based compartmentalization models (e.g., ACES), with a 15\% overhead compared to an unprotected system. This comes at an FPGA's LUTs overhead of 10.4\% to support CHERI for an unprotected baseline RISC-V processor, compared to 7.6\% to support MPU, while CHERI only incurs 1.3\% of the registers area overhead compared to 2\% for MPU.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\R2A7ZMKS\\Almatary et al. - 2022 - CompartOS CHERI Compartmentalization for Embedded.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\NDIA4AUF\\2206.html}
}

@article{andersonsecurity,
  title = {Security {{Engineering}}: {{A Guide}} to {{Building Dependable Distributed Systems}}},
  author = {Anderson, Ross},
  pages = {1235},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3WUE2SVS\\Anderson - Security Engineering A Guide to Building Dependab.pdf}
}

@misc{atamli-reineh2017securing,
  title = {Securing {{Application}} with {{Software Partitioning}}: {{A}} Case Study Using {{SGX}}},
  shorttitle = {Securing {{Application}} with {{Software Partitioning}}},
  author = {{Atamli-Reineh}, Ahmad and Martin, Andrew},
  year = {2017},
  month = jun,
  number = {arXiv:1706.03006},
  eprint = {1706.03006},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  abstract = {Application size and complexity are the underlying cause of numerous security vulnerabilities in code. In order to mitigate the risks arising from such vulnerabilities, various techniques have been proposed to isolate the execution of sensitive code from the rest of the application and from other software on the platform (e.g. the operating system). However, even with these partitioning techniques, it is not immediately clear exactly how they can and should be used to partition applications. What overall partitioning scheme should be followed; what granularity of the partitions should be. To some extent, this is dependent on the capabilities and performance of the partitioning technology in use. For this work, we focus on the upcoming Intel Software Guard Extensions (SGX) technology as the state-of-the-art in this field. SGX provides a trusted execution environment, called an enclave, that protects the integrity of the code and the confidentiality of the data inside it from other software, including the operating system. We present a novel framework consisting of four possible schemes under which an application can be partitioned. These schemes range from coarse-grained partitioning, in which the full application is included in a single enclave, through ultra-fine partitioning, in which each application secret is protected in an individual enclave. We explain the specific security benefits provided by each of the partitioning schemes and discuss how the performance of the application would be affected. To compare the different partitioning schemes, we have partitioned OpenSSL using four different schemes. We discuss SGX properties together with the implications of our design choices in this paper.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Cryptography and Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5KXANEMI\\Atamli-Reineh and Martin - 2017 - Securing Application with Software Partitioning A.pdf}
}

@article{avanzi2017qarma,
  title = {The {{QARMA}} Block Cipher Family. {{Almost MDS}} Matrices over Rings with Zero Divisors, Nearly Symmetric Even-Mansour Constructions with Non-Involutory Central Rounds, and Search Heuristics for Low-Latency s-Boxes},
  author = {Avanzi, Roberto},
  year = {2017},
  month = mar,
  journal = {IACR Transactions on Symmetric Cryptology},
  volume = {2017},
  number = {1},
  pages = {4--44},
  doi = {10.13154/tosc.v2017.i1.4-44},
  abstract = {This paper introduces QARMA, a new family of lightweight tweakable block ciphers targeted at applications such as memory encryption, the generation of very short tags for hardware-assisted prevention of software exploitation, and the construction of keyed hash functions. QARMA is inspired by reflection ciphers such as PRINCE, to which it adds a tweaking input, and MANTIS. However, QARMA differs from previous reflector constructions in that it is a \&amp;lt;em\&amp;gt;three-round Even-Mansour scheme\&amp;lt;/em\&amp;gt; instead of a FX-construction, and its middle permutation is \&amp;lt;em\&amp;gt;non-involutory and keyed\&amp;lt;/em\&amp;gt;. We introduce and analyse a family of Almost MDS matrices defined over a ring with zero divisors that allows us to encode rotations in its operation while maintaining the minimal latency associated to 0, 1-matrices. The purpose of all these design choices is to harden the cipher against various classes of attacks. We also describe new S-Box search heuristics aimed at minimising the critical path. QARMA exists in 64- and 128-bit block sizes, where block and tweak size are equal, and keys are twice as long as the blocks. We argue that QARMA provides sufficient security margins within the constraints determined by the mentioned applications, while still achieving best-in-class latency. Implementation results on a state-of-the art manufacturing process are reported. Finally, we propose a technique to extend the length of the tweak by using, for instance, a universal hash function, which can also be used to strengthen the security of QARMA.},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3BRILC2Y\\Avanzi - 2017 - The QARMA block cipher family. Almost MDS matrices.pdf}
}

@inproceedings{azad2019less,
  title = {Less Is {{More}}: {{Quantifying}} the {{Security Benefits}} of {{Debloating Web Applications}}},
  shorttitle = {Less Is {{More}}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Azad, Babak Amin and Laperdrix, Pierre and Nikiforakis, Nick},
  year = {2019},
  pages = {1697--1714},
  isbn = {978-1-939133-06-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GZXQ4WKH\\Azad et al. - 2019 - Less is More Quantifying the Security Benefits of.pdf}
}

@inproceedings{azim2019dynamic,
  title = {Dynamic {{Slicing}} for {{Android}}},
  booktitle = {2019 {{IEEE}}/{{ACM}} 41st {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Azim, Tanzirul and Alavi, Arash and Neamtiu, Iulian and Gupta, Rajiv},
  year = {2019},
  month = may,
  pages = {1154--1164},
  issn = {1558-1225},
  doi = {10.1109/ICSE.2019.00118},
  abstract = {Dynamic program slicing is useful for a variety of tasks, from testing to debugging to security. Prior slicing approaches have targeted traditional desktop/server platforms, rather than mobile platforms such as Android. Slicing mobile, event-based systems is challenging due to their asynchronous callback construction and the IPC (interprocess communication)- heavy, sensor-driven, timing-sensitive nature of the platform. To address these problems, we introduce AndroidSlicer1, the first slicing approach for Android. AndroidSlicer combines a novel asynchronous slicing approach for modeling data and control dependences in the presence of callbacks with lightweight and precise instrumentation; this allows slicing for apps running on actual phones, and without requiring the app's source code. Our slicer is capable of handling a wide array of inputs that Android supports without adding any noticeable overhead. Experiments on 60 apps from Google Play show that AndroidSlicer is effective (reducing the number of instructions to be examined to 0.3\% of executed instructions) and efficient (app instrumentation and post-processing combined takes 31 seconds); all while imposing a runtime overhead of just 4\%. We present three applications of AndroidSlicer that are particularly relevant in the mobile domain: (1) finding and tracking input parts responsible for an error/crash, (2) fault localization, i.e., finding the instructions responsible for an error/crash, and (3) reducing the regression test suite. Experiments with these applications on an additional set of 18 popular apps indicate that AndroidSlicer is effective for Android testing and debugging.},
  keywords = {Computer crashes,Debugging,Mobile apps; Android; Dynamic analysis,Pins,Registers,Runtime,Smart phones,Testing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7X6JU2B8\\Azim et al. - 2019 - Dynamic Slicing for Android.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\CCHLGDD7\\8811953.html}
}

@inproceedings{bae2021rudra,
  title = {Rudra: {{Finding Memory Safety Bugs}} in {{Rust}} at the {{Ecosystem Scale}}},
  shorttitle = {Rudra},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 28th {{Symposium}} on {{Operating Systems Principles}}},
  author = {Bae, Yechan and Kim, Youngsuk and Askar, Ammar and Lim, Jungwon and Kim, Taesoo},
  year = {2021},
  month = oct,
  series = {{{SOSP}} '21},
  pages = {84--99},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3477132.3483570},
  abstract = {Rust is a promising system programming language that guarantees memory safety at compile time. To support diverse requirements for system software such as accessing low-level hardware, Rust allows programmers to perform operations that are not protected by the Rust compiler with the unsafe keyword. However, Rust's safety guarantee relies on the soundness of all unsafe code in the program as well as the standard and external libraries, making it hard to reason about their correctness. In other words, a single bug in any unsafe code breaks the whole program's safety guarantee. In this paper, we introduce RUDRA, a program that analyzes and reports potential memory safety bugs in unsafe Rust. Since a bug in unsafe code threatens the foundation of Rust's safety guarantee, our primary focus is to scale our analysis to all the packages hosted in the Rust package registry. RUDRA can scan the entire registry (43k packages) in 6.5 hours and identified 264 previously unknown memory safety bugs---leading to 76 CVEs and 112 RustSec advisories being filed, which represent 51.6\% of memory safety bugs reported to RustSec since 2016. The new bugs RUDRA found are non-trivial, subtle, and often made by Rust experts: two in the Rust standard library, one in the official futures library, and one in the Rust compiler. RUDRA is open-source, and part of its algorithm is integrated into the official Rust linter.},
  isbn = {978-1-4503-8709-5},
  keywords = {Memory-safety,Program analysis,Rust},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TLSRPAD7\\Bae et al. - 2021 - Rudra Finding Memory Safety Bugs in Rust at the E.pdf}
}

@inproceedings{bai2018dsac,
  title = {\{\vphantom\}{{DSAC}}\vphantom\{\}: {{Effective Static Analysis}} of \{\vphantom\}{{Sleep-in-Atomic-Context}}\vphantom\{\} {{Bugs}} in {{Kernel Modules}}},
  shorttitle = {\{\vphantom\}{{DSAC}}\vphantom\{\}},
  booktitle = {2018 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 18)},
  author = {Bai, Jia-Ju and Wang, Yu-Ping and Lawall, Julia and Hu, Shi-Min},
  year = {2018},
  pages = {587--600},
  isbn = {978-1-939133-01-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NVETIWD3\\Bai et al. - 2018 - DSAC Effective Static Analysis of Sleep-in-Ato.pdf}
}

@article{balasubramanian2017system,
  title = {System {{Programming}} in {{Rust}}: {{Beyond Safety}}},
  shorttitle = {System {{Programming}} in {{Rust}}},
  author = {Balasubramanian, Abhiram and Baranowski, Marek S. and Burtsev, Anton and Panda, Aurojit and Rakamari, Zvonimir and Ryzhyk, Leonid},
  year = {2017},
  month = sep,
  journal = {ACM SIGOPS Operating Systems Review},
  volume = {51},
  number = {1},
  pages = {94--99},
  issn = {0163-5980},
  doi = {10.1145/3139645.3139660},
  abstract = {Rust is a new system programming language that offers a practical and safe alternative to C. Rust is unique in that it enforces safety without runtime overhead, most importantly, without the overhead of garbage collection. While zero-cost safety is remarkable on its own, we argue that the superpowers of Rust go beyond safety. In particular, Rust's linear type system enables capabilities that cannot be implemented efficiently in traditional languages, both safe and unsafe, and that dramatically improve security and reliability of system software. We show three examples of such capabilities: zero-copy software fault isolation, efficient static information flow analysis, and automatic checkpointing. While these capabilities have been in the spotlight of systems research for a long time, their practical use is hindered by high cost and complexity. We argue that with the adoption of Rust these mechanisms will become commoditized.},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JKNGSKDL\\Balasubramanian et al. - 2017 - System Programming in Rust Beyond Safety.pdf}
}

@article{banerjee2020sound,
  title = {Sound Garbage Collection for {{C}} Using Pointer Provenance},
  author = {Banerjee, Subarno and Devecsery, David and Chen, Peter M. and Narayanasamy, Satish},
  year = {2020},
  month = nov,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {OOPSLA},
  pages = {1--28},
  issn = {2475-1421},
  doi = {10.1145/3428244},
  abstract = {SUBARNO BANERJEE, University of Michigan, USA DAVID DEVECSERY, Georgia Institute of Technology, USA PETER M. CHEN, University of Michigan, USA SATISH NARAYANASAMY, University of Michigan, USA Garbage collection (GC) support for unmanaged languages can reduce programming burden in reasoning about liveness of dynamic objects. It also avoids temporal memory safety violations and memory leaks. Sound GC for weakly-typed languages such as C/C++, however, remains an unsolved problem. Current value-based GC solutions examine values of memory locations to discover the pointers, and the objects they point to. The approach is inherently unsound in the presence of arbitrary type casts and pointer manipulations, which are legal in C/C++. Such language features are regularly used, especially in low-level systems code. In this paper, we propose Dynamic Pointer Provenance Tracking to realize sound GC. We observe that pointers cannot be created out-of-thin-air, and they must have provenance to at least one valid allocation. Therefore, by tracking pointer provenance from the source (e.g., malloc) through both explicit data-flow and implicit control-flow, our GC has sound and precise information to compute the set of all reachable objects at any program state. We discuss several static analysis optimizations, that can be employed during compilation aided with profiling, to significantly reduce the overhead of dynamic provenance tracking from nearly 8\texttimes{} to 16\% for well-behaved programs that adhere to the C standards. Pointer provenance based sound GC invocation is also 13\% faster and reclaims 6\% more memory on average, compared to an unsound value-based GC. CCS Concepts: {$\cdot$} Software and its engineering \textrightarrow{} Garbage collection; Automated static analysis.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NA25HB2G\\Banerjee et al. - 2020 - Sound garbage collection for C using pointer prove.pdf}
}

@inproceedings{bang2018online,
  title = {Online {{Synthesis}} of {{Adaptive Side-Channel Attacks Based On Noisy Observations}}},
  booktitle = {2018 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS P}})},
  author = {Bang, Lucas and Rosner, Nicolas and Bultan, Tevfik},
  year = {2018},
  month = apr,
  pages = {307--322},
  doi = {10.1109/EuroSP.2018.00029},
  abstract = {We present an automated technique for synthesizing adaptive attacks to extract information from program functions that leak secret data through a side channel. We synthesize attack steps dynamically and consider noisy program environments. Our approach consists of an offline profiling phase using symbolic execution, witness generation, and profiling to construct a noise model. During our online attack synthesis phase, we use weighted model counting and numeric optimization to automatically synthesize attack inputs. We experimentally evaluate the effectiveness of our approach on DARPA benchmark programs created for testing side-channel analysis techniques.},
  keywords = {attack synthesis,Noise measurement,Numerical models,Optimization,Servers,side channels,Side-channel attacks},
  annotation = {19 citations (Semantic Scholar/DOI) [2022-01-24]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\EEW6JCUY\\Bang et al. - 2018 - Online Synthesis of Adaptive Side-Channel Attacks .pdf}
}

@inproceedings{bauer2021cali,
  title = {Cali: {{Compiler-Assisted Library Isolation}}},
  shorttitle = {Cali},
  booktitle = {Proceedings of the 2021 {{ACM Asia Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Bauer, Markus and Rossow, Christian},
  year = {2021},
  month = may,
  series = {{{ASIA CCS}} '21},
  pages = {550--564},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3433210.3453111},
  abstract = {Software libraries can freely access the program's entire address space, and also inherit its system-level privileges. This lack of separation regularly leads to security-critical incidents once libraries contain vulnerabilities or turn rogue. We present Cali, a compiler-assisted library isolation system that fully automatically shields a program from a given library. Cali is fully compatible with mainline Linux and does not require supervisor privileges to execute. We compartmentalize libraries into their own process with well-defined security policies. To preserve the functionality of the interactions between program and library, Cali uses a Program Dependence Graph to track data flow between the program and the library during link time. We evaluate our open-source prototype against three popular libraries: Ghostscript, OpenSSL, and SQLite. Cali successfully reduced the amount of memory that is shared between the program and library to 0.08\% (ImageMagick) - 0.4\% (Socat), while retaining an acceptable program performance.},
  isbn = {978-1-4503-8287-8},
  keywords = {Cali,compiler,library isolation,LLVM,memory isolation,privilege separation,program dependence graph},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\D57XXM5U\\Bauer and Rossow - 2021 - Cali Compiler-Assisted Library Isolation.pdf}
}

@inproceedings{bernhard2022xtag,
  title = {{{xTag}}: {{Mitigating Use-After-Free Vulnerabilities}} via {{Software-Based Pointer Tagging}} on {{Intel}} X86-64},
  shorttitle = {{{xTag}}},
  booktitle = {2022 {{IEEE}} 7th {{European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Bernhard, Lukas and Rodler, Michael and Holz, Thorsten and Davit, Lucas},
  year = {2022},
  month = jun,
  pages = {502--519},
  doi = {10.1109/EuroSP53844.2022.00038},
  abstract = {Memory safety in complex applications implemented in unsafe programming languages such as C/C++ is still an unresolved problem in practice. Such applications were often developed in an ad-hoc, security-ignorant fashion, and thus they contain many types of security issues. Many different types of defenses have been proposed in the past to mitigate these problems, some of which are even widely used in practice. However, advanced attacks are still able to circumvent these defenses, and the arms race is not (yet) over. On the defensive side, the most promising next step is a tighter integration of the hardware and software level: modern mitigation techniques are either accelerated using hardware extensions or implemented in the hardware by extensions of the instruction set architecture (ISA). In particular, memory tagging, as proposed by ARM or SPARC, promises to solve many issues for practical memory safety. Unfortunately, Intel x86-64, which represents the most important ISA for both the desktop and server domain, lacks support for hardware-accelerated memory tagging, so memory tagging is not considered practical for this platform. In this paper, we present the design and implementation of an efficient, software-only pointer tagging scheme for Intel x86-64 based on a novel metadata embedding scheme. The basic idea is to alias multiple virtual pages to one physical page so that we can efficiently embed tag bits into a pointer. Furthermore, we introduce several optimizations that significantly reduce the performance impact of this approach to memory tagging. Based on this scheme, we propose a novel use-after-free mitigation scheme, called xTag, that offers better performance and strong security properties compared to state-of-the-art methods. We also show how double-free vulnerabilities can be mitigated. Our approach is highly compatible, allowing pointers to be passed back and forth between instrumented and non-instrumented code without losing metadata, and it is even compatible with inline assembly. We conclude that building exploit mitigation mechanisms on top of our memory tagging scheme is feasible on Intel x86-64, as demonstrated by the effective prevention of use-after-free bugs in the Firefox web browser.},
  keywords = {Hardware,Memory management,memory safety,memory tagging,Metadata,Reduced instruction set computing,Software,Tagging,use-after-free,Weapons},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KKX7MSNP\\Bernhard et al. - 2022 - xTag Mitigating Use-After-Free Vulnerabilities vi.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZC93NLUJ\\9797369.html}
}

@incollection{besson2019compiling,
  title = {Compiling {{Sandboxes}}: {{Formally Verified Software Fault Isolation}}},
  shorttitle = {Compiling {{Sandboxes}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Besson, Fr{\'e}d{\'e}ric and Blazy, Sandrine and Dang, Alexandre and Jensen, Thomas and Wilke, Pierre},
  editor = {Caires, Lu{\'i}s},
  year = {2019},
  volume = {11423},
  pages = {499--524},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-17184-1_18},
  abstract = {Software Fault Isolation (SFI) is a security-enhancing program transformation for instrumenting an untrusted binary module so that it runs inside a dedicated isolated address space, called a sandbox. To ensure that the untrusted module cannot escape its sandbox, existing approaches such as Google's Native Client rely on a binary verifier to check that all memory accesses are within the sandbox. Instead of relying on a posteriori verification, we design, implement and prove correct a program instrumentation phase as part of the formally verified compiler CompCert that enforces a sandboxing security property a priori. This eliminates the need for a binary verifier and, instead, leverages the soundness proof of the compiler to prove the security of the sandboxing transformation. The technical contributions are a novel sandboxing transformation that has a well-defined C semantics and which supports arbitrary function pointers, and a formally verified C compiler that implements SFI. Experiments show that our formally verified technique is a competitive way of implementing SFI.},
  isbn = {978-3-030-17183-4 978-3-030-17184-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2E5TW8YF\\Besson et al. - 2019 - Compiling Sandboxes Formally Verified Software Fa.pdf}
}

@article{bittauwedge,
  title = {Wedge: {{Splitting Applications}} into {{Reduced-Privilege Compartments}}},
  author = {Bittau, Andrea and Marchenko, Petr and Handley, Mark and Karp, Brad},
  pages = {14},
  abstract = {Software vulnerabilities and bugs persist, and so exploits continue to cause significant damage, particularly by divulging users' sensitive data to miscreants. Yet the vast majority of networked applications remain monolithically structured, in stark contravention of the ideal of least-privilege partitioning. Like others before us, we believe this state of affairs continues because today's operating systems offer isolation primitives that are cumbersome. We present Wedge, a system well suited to the splitting of complex, legacy, monolithic applications into fine-grained, least-privilege compartments. Wedge consists of two synergistic parts: OS primitives that create compartments with default-deny semantics, which force the programmer to make compartments' privileges explicit; and Crowbar, a pair of run-time analysis tools that assist the programmer in determining which code needs which privileges for which memory objects. By implementing the Wedge system atop Linux, and applying it to the SSL-enabled Apache web server and the OpenSSH login server, we demonstrate that Wedge allows fine-grained compartmentalization of applications to prevent the leakage of sensitive data, at acceptable performance cost. We further show that Wedge is powerful enough to prevent a subtle man-in-the-middle attack that succeeds on a more coarsely privilege-separated Apache web server.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3R6GHXBB\\Bittau et al. - Wedge Splitting Applications into Reduced-Privile.pdf}
}

@inproceedings{bohme2017directed,
  title = {Directed {{Greybox Fuzzing}}},
  booktitle = {Proceedings of the 2017 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {B{\"o}hme, Marcel and Pham, Van-Thuan and Nguyen, Manh-Dung and Roychoudhury, Abhik},
  year = {2017},
  month = oct,
  series = {{{CCS}} '17},
  pages = {2329--2344},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3133956.3134020},
  abstract = {Existing Greybox Fuzzers (GF) cannot be effectively directed, for instance, towards problematic changes or patches, towards critical system calls or dangerous locations, or towards functions in the stack-trace of a reported vulnerability that we wish to reproduce. In this paper, we introduce Directed Greybox Fuzzing (DGF) which generates inputs with the objective of reaching a given set of target program locations efficiently. We develop and evaluate a simulated annealing-based power schedule that gradually assigns more energy to seeds that are closer to the target locations while reducing energy for seeds that are further away. Experiments with our implementation AFLGo demonstrate that DGF outperforms both directed symbolic-execution-based whitebox fuzzing and undirected greybox fuzzing. We show applications of DGF to patch testing and crash reproduction, and discuss the integration of AFLGo into Google's continuous fuzzing platform OSS-Fuzz. Due to its directedness, AFLGo could find 39 bugs in several well-fuzzed, security-critical projects like LibXML2. 17 CVEs were assigned.},
  isbn = {978-1-4503-4946-8},
  keywords = {coverage-based greybox fuzzing,crash reproduction,directed testing,patch testing,reachability,verifying true positives},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TL2EQ7FV\\BÃ¶hme et al. - 2017 - Directed Greybox Fuzzing.pdf}
}

@article{bonstrup2019rapid,
  title = {A {{Rapid Form}} of {{Offline Consolidation}} in {{Skill Learning}}},
  author = {B{\"o}nstrup, Marlene and Iturrate, I{\~n}aki and Thompson, Ryan and Cruciani, Gabriel and Censor, Nitzan and Cohen, Leonardo G.},
  year = {2019},
  month = apr,
  journal = {Current Biology},
  volume = {29},
  number = {8},
  pages = {1346-1351.e4},
  issn = {0960-9822},
  doi = {10.1016/j.cub.2019.02.049},
  abstract = {The brain strengthens memories through consolidation, defined as resistance to interference (stabilization) or performance improvements between the end of a practice session and the beginning of the next (offline gains) [1]. Typically, consolidation has been measured hours or days after the completion of training [2], but the same concept may apply to periods of rest that occur interspersed in a series of practice bouts within the same session. Here, we took an unprecedented close look at the within-seconds time course of early human procedural learning over alternating short periods of practice and rest that constitute a typical online training session. We found that performance did not markedly change over short periods of practice. On the other hand, performance improvements in between practice periods, when subjects were at rest, were significant and accounted for early procedural learning. These offline improvements were more prominent in early training trials when the learning curve was steep and no performance decrements during preceding practice periods were present. At the neural level, simultaneous magnetoencephalographic recordings showed an anatomically defined signature of this phenomenon. Beta-band brain oscillatory activity in a predominantly contralateral frontoparietal network predicted rest-period performance improvements. Consistent with its role in sensorimotor engagement [3], modulation of beta activity may reflect replay of task processes during rest periods. We report a rapid form of offline consolidation that substantially contributes to early skill learning and may extend the concept of consolidation to a time scale in the order of seconds, rather than the hours or days traditionally accepted.},
  langid = {english},
  keywords = {beta activity,consolidation,human motor learning,learning,magnetoencephalography,offline learning,procedural memory,reactivation,replay,skill learning},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\J3AVZ56U\\BÃ¶nstrup et al. - 2019 - A Rapid Form of Offline Consolidation in Skill Lea.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\CJMFYZDN\\S0960982219302192.html}
}

@inproceedings{boos2020theseus,
  title = {Theseus: An {{Experiment}} in {{Operating System Structure}} and {{State Management}}},
  shorttitle = {Theseus},
  booktitle = {14th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 20)},
  author = {Boos, Kevin and Liyanage, Namitha and Ijaz, Ramla and Zhong, Lin},
  year = {2020},
  pages = {1--19},
  isbn = {978-1-939133-19-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PR92EBEY\\Boos et al. - 2020 - Theseus an Experiment in Operating System Structu.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZQVUURZW\\boos.html}
}

@inproceedings{borrello2021constantine,
  title = {Constantine: {{Automatic Side-Channel Resistance Using Efficient Control}} and {{Data Flow Linearization}}},
  shorttitle = {Constantine},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Borrello, Pietro and D'Elia, Daniele Cono and Querzoni, Leonardo and Giuffrida, Cristiano},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {715--733},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484583},
  abstract = {In the era of microarchitectural side channels, vendors scramble to deploy mitigations for transient execution attacks, but leave traditional side-channel attacks against sensitive software (e.g., crypto programs) to be fixed by developers by means of constant-time programming (i.e., absence of secret-dependent code/data patterns). Unfortunately, writing constant-time code by hand is hard, as evidenced by the many flaws discovered in production side channel-resistant code. Prior efforts to automatically transform programs into constant-time equivalents offer limited security or compatibility guarantees, hindering their applicability to real-world software. In this paper, we present Constantine, a compiler-based system to automatically harden programs against microarchitectural side channels. Constantine pursues a radical design point where secret-dependent control and data flows are completely linearized (i.e., all involved code/data accesses are always executed). This strategy provides strong security and compatibility guarantees by construction, but its natural implementation leads to state explosion in real-world programs. To address this challenge, Constantine relies on carefully designed optimizations such as just-in-time loop linearization and aggressive function cloning for fully context-sensitive points-to analysis, which not only address state explosion, but also lead to an efficient and compatible solution. Constantine yields overheads as low as 16\% on standard benchmarks and can handle a fully-fledged component from the production wolfSSL library.},
  isbn = {978-1-4503-8454-4},
  keywords = {compilers,constant-time programming,control-flow linearization,data-flow linearization,side channels},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6IK8JPNY\\Borrello et al. - 2021 - Constantine Automatic Side-Channel Resistance Usi.pdf}
}

@inproceedings{bosamiya2022provablysafea,
  title = {\{\vphantom\}{{Provably-Safe}}\vphantom\{\} {{Multilingual Software Sandboxing}} Using \{\vphantom\}{{WebAssembly}}\vphantom\{\}},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {Bosamiya, Jay and Lim, Wen Shih and Parno, Bryan},
  year = {2022},
  pages = {1975--1992},
  isbn = {978-1-939133-31-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\N5H2ARFU\\Bosamiya et al. - 2022 - Provably-Safe Multilingual Software Sandboxing u.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\SJUW4Y3F\\bosamiya.html}
}

@inproceedings{brasser2015tytan,
  title = {{{TyTAN}}: Tiny Trust Anchor for Tiny Devices},
  shorttitle = {{{TyTAN}}},
  booktitle = {Proceedings of the 52nd {{Annual Design Automation Conference}}},
  author = {Brasser, Ferdinand and El Mahjoub, Brahim and Sadeghi, Ahmad-Reza and Wachsmann, Christian and Koeberl, Patrick},
  year = {2015},
  month = jun,
  series = {{{DAC}} '15},
  pages = {1--6},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2744769.2744922},
  abstract = {Embedded systems are at the core of many security-sensitive and safety-critical applications, including automotive, industrial control systems, and critical infrastructures. Existing protection mechanisms against (software-based) malware are inflexible, too complex, expensive, or do not meet real-time requirements. We present TyTAN, which, to the best of our knowledge, is the first security architecture for embedded systems that provides (1) hardware-assisted strong isolation of dynamically configurable tasks and (2) real-time guarantees. We implemented TyTAN on the Intel\textregistered{} Siskiyou Peak embedded platform and demonstrate its efficiency and effectiveness through extensive evaluation.},
  isbn = {978-1-4503-3520-1},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\Q3GV7A2G\\Brasser et al. - 2015 - TyTAN tiny trust anchor for tiny devices.pdf}
}

@inproceedings{briongos2021aim,
  title = {Aim, {{Wait}}, {{Shoot}}: {{How}} the {{CacheSniper Technique Improves Unprivileged Cache Attacks}}},
  shorttitle = {Aim, {{Wait}}, {{Shoot}}},
  booktitle = {2021 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS P}})},
  author = {Briongos, Samira and Bruhns, Ida and Malag{\'o}n, Pedro and Eisenbarth, Thomas and Moya, Jos{\'e} M.},
  year = {2021},
  month = sep,
  pages = {683--700},
  doi = {10.1109/EuroSP51992.2021.00051},
  abstract = {Microarchitectural side channel attacks have been very prominent in security research over the last few years. Caches proved to be an outstanding side channel, as they provide high resolution and generic cross-core leakage. All major cryptographic libraries provide countermeasures to hinder key extraction via cross-core cache attacks by now. In this paper, we analyze implementations protected by prefetch-based countermeasures aimed at preventing well-known cache attacks, and highlight the circumstances causing them to remain vulnerable. Further, we craft a novel attack technique that precisely synchronizes the attacking and the victim processes, enabling the attacking process to evict the target data from the cache at the desired instants. One key improvement of our approach is that it provides unprivileged attackers with a method to remove specific data from the cache with a single memory access and in absence of shared memory by leveraging the transient capabilities of TSX and relying on the L3 replacement policy. We show the feasibility of our approach by extracting an RSA key from the latest wolfSSL library and an AES key from the T-Table and S-Box implementations included in OpenSSL with CacheSniper. Both libraries implement prefetch-based methods as a protection against cache attacks.},
  keywords = {Cache attack,Codes,Costs,Cryptography,Hardware transactional memory,Microarchitecture,Prefetching,Program processors,Side channel attacks,Side-channel attacks,Writing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\YKMTGMWA\\Briongos et al. - 2021 - Aim, Wait, Shoot How the CacheSniper Technique Im.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\LUCWAIST\\9581261.html}
}

@inproceedings{brown2019less,
  title = {Is {{Less Really More}}? {{Towards Better Metrics}} for {{Measuring Security Improvements Realized Through Software Debloating}}},
  shorttitle = {Is {{Less Really More}}?},
  booktitle = {12th {{USENIX Workshop}} on {{Cyber Security Experimentation}} and {{Test}} ({{CSET}} 19)},
  author = {Brown, Michael D. and Pande, Santosh},
  year = {2019},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UHI6JLLP\\Brown and Pande - 2019 - Is Less Really More Towards Better Metrics for Me.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\IQPZUY2S\\brown.html}
}

@inproceedings{brumley2004privtrans,
  title = {Privtrans: {{Automatically Partitioning Programs}} for {{Privilege Separation}}},
  shorttitle = {Privtrans},
  booktitle = {13th {{USENIX Security Symposium}} ({{USENIX Security}} 04)},
  author = {Brumley, David and Song, Dawn},
  year = {2004},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NUWVYL3U\\Brumley and Song - 2004 - Privtrans Automatically Partitioning Programs for.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\HM8MHV7W\\privtrans-automatically-partitioning-programs-privilege.html}
}

@book{bryant2016computer,
  title = {Computer Systems: A Programmer's Perspective},
  shorttitle = {Computer Systems},
  author = {Bryant, Randal E. and O'Hallaron, David R.},
  year = {2016},
  edition = {Third edition},
  publisher = {{Pearson}},
  address = {{Boston}},
  isbn = {978-0-13-409266-9},
  langid = {english},
  lccn = {QA76.5 .B795 2016},
  keywords = {Computer systems,Computers,Telecommunication,User interfaces (Computer systems)},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IL69A7MT\\Bryant and O'Hallaron - 2016 - Computer systems a programmer's perspective.pdf}
}

@inproceedings{burnim2008heuristics,
  title = {Heuristics for Scalable Dynamic Test Generation},
  booktitle = {In {{Proc}}. {{ASE}}},
  author = {Burnim, Jacob and Sen, Koushik},
  year = {2008},
  pages = {443--446},
  abstract = {Abstract\textemdash Recently there has been great success in using symbolic execution to automatically generate test inputs for small software systems. A primary challenge in scaling such approaches to larger programs is the combinatorial explosion of the path space. It is likely that sophisticated strategies for searching this path space are needed to generate inputs that effectively test large programs (by, e.g., achieving significant branch coverage). We present several such heuristic search strategies, including a novel strategy guided by the control flow graph of the program under test. We have implemented these strategies in CREST, our open source concolic testing tool for C, and evaluated them on two widely-used software tools, grep 2.2 (15K lines of code) and Vim 5.7 (150K lines). On these benchmarks, the presented heuristics achieve significantly greater branch coverage on the same testing budget than concolic testing with a traditional depth-first search strategy. I.},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2UIK2WXR\\Burnim and Sen - 2008 - Heuristics for scalable dynamic test generation.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\LPVMBE66\\download.html}
}

@article{burow2018controlflow,
  title = {Control-{{Flow Integrity}}: {{Precision}}, {{Security}}, and {{Performance}}},
  shorttitle = {Control-{{Flow Integrity}}},
  author = {Burow, Nathan and Carr, Scott A. and Nash, Joseph and Larsen, Per and Franz, Michael and Brunthaler, Stefan and Payer, Mathias},
  year = {2018},
  month = jan,
  journal = {ACM Computing Surveys},
  volume = {50},
  number = {1},
  pages = {1--33},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3054924},
  abstract = {Memory corruption errors in C/C++ programs remain the most common source of security vulnerabilities in today's systems. Control-flow hijacking attacks exploit memory corruption vulnerabilities to divert program execution away from the intended control flow. Researchers have spent more than a decade studying and refining defenses based on Control-Flow Integrity (CFI); this technique is now integrated into several production compilers. However, so far, no study has systematically compared the various proposed CFI mechanisms nor is there any protocol on how to compare such mechanisms. We compare a broad range of CFI mechanisms using a unified nomenclature based on (i) a qualitative discussion of the conceptual security guarantees, (ii) a quantitative security evaluation, and (iii) an empirical evaluation of their performance in the same test environment. For each mechanism, we evaluate (i) protected types of control-flow transfers and (ii) precision of the protection for forward and backward edges. For open-source, compiler-based implementations, we also evaluate (iii) generated equivalence classes and target sets and (iv) runtime performance.},
  langid = {english},
  keywords = {cfi,csur},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PF5ZMK53\\Burow et al. - 2018 - Control-Flow Integrity Precision, Security, and P.pdf}
}

@inproceedings{burtsev2021isolation,
  title = {Isolation in {{Rust}}: {{What}} Is {{Missing}}?},
  shorttitle = {Isolation in {{Rust}}},
  booktitle = {Proceedings of the 11th {{Workshop}} on {{Programming Languages}} and {{Operating Systems}}},
  author = {Burtsev, Anton and Appel, Dan and Detweiler, David and Huang, Tianjiao and Li, Zhaofeng and Narayanan, Vikram and Zellweger, Gerd},
  year = {2021},
  month = oct,
  pages = {76--83},
  publisher = {{ACM}},
  address = {{Virtual Event Germany}},
  doi = {10.1145/3477113.3487272},
  abstract = {Rust is the first practical programming language that has the potential to provide fine-grained isolation of untrusted computations at the language level. A combination of zerooverhead safety, i.e., safety without a managed runtime and garbage collection, and a unique ownership discipline enable isolation in systems with tight performance budgets, e.g., databases, network processing frameworks, browsers, and even operating system kernels. Unfortunately, Rust was not designed with isolation in mind. Today, implementing isolation in Rust is possible but requires complex, ad hoc, and arguably error-prone mechanisms to enforce it outside of the language. We examine several recent systems that implement isolation in Rust but struggle with the shortcomings of the language. As a result of our analysis we identify a collection of mechanisms that can enable isolation as a first class citizen in the Rust ecosystem and suggest directions for implementing them.},
  isbn = {978-1-4503-8707-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9CK7Q8PF\\Burtsev et al. - 2021 - Isolation in Rust What is Missing.pdf}
}

@inproceedings{caballero2012undangle,
  title = {Undangle: Early Detection of Dangling Pointers in Use-after-Free and Double-Free Vulnerabilities},
  shorttitle = {Undangle},
  booktitle = {Proceedings of the 2012 {{International Symposium}} on {{Software Testing}} and {{Analysis}} - {{ISSTA}} 2012},
  author = {Caballero, Juan and Grieco, Gustavo and Marron, Mark and Nappa, Antonio},
  year = {2012},
  pages = {133},
  publisher = {{ACM Press}},
  address = {{Minneapolis, MN, USA}},
  doi = {10.1145/2338965.2336769},
  abstract = {Use-after-free vulnerabilities are rapidly growing in popularity, especially for exploiting web browsers. Use-after-free (and doublefree) vulnerabilities are caused by a program operating on a dangling pointer. In this work we propose early detection, a novel runtime approach for finding and diagnosing use-after-free and doublefree vulnerabilities. While previous work focuses on the creation of the vulnerability (i.e., the use of a dangling pointer), early detection shifts the focus to the creation of the dangling pointer(s) at the root of the vulnerability.},
  isbn = {978-1-4503-1454-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\FXGQSPNU\\Caballero et al. - 2012 - Undangle early detection of dangling pointers in .pdf}
}

@misc{canella2021domain,
  title = {Domain {{Page-Table Isolation}}},
  author = {Canella, Claudio and Kogler, Andreas and Giner, Lukas and Gruss, Daniel and Schwarz, Michael},
  year = {2021},
  month = nov,
  number = {arXiv:2111.10876},
  eprint = {2111.10876},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2111.10876},
  abstract = {Modern applications often consist of different security domains that require isolation from each other. While several solutions exist, most of them rely on specialized hardware, hardware extensions, or require less-efficient software instrumentation of the application. In this paper, we propose Domain Page-Table Isolation (DPTI), a novel mechanism for hardware-enforced security domains that can be readily used on commodity off-the-shelf CPUs. DPTI uses two novel techniques for dynamic, time-limited changes to the memory isolation at security-critical points, called memory freezing and stashing. We demonstrate the versatility and efficacy of DPTI in two scenarios: First, DPTI freezes or stashes memory to support faster and more fine-grained syscall filtering than state-of-the-art seccomp-bpf. With the provided memory safety guarantees, DPTI can even securely support deep argument filtering, such as string comparisons. Second, DPTI freezes or stashes memory to efficiently confine potentially untrusted SGX enclaves, outperforming existing solutions by 14.6\%-22\% while providing the same security guarantees. Our results show that DPTI is a viable mechanism to isolate domains within applications using only existing mechanisms available on modern CPUs, without relying on special hardware instructions or extensions},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8PEV33WX\\Canella et al. - 2021 - Domain Page-Table Isolation.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\H3B48AXP\\2111.html}
}

@inproceedings{carlini2015controlflow,
  title = {Control-{{Flow Bending}}: {{On}} the {{Effectiveness}} of {{Control-Flow Integrity}}},
  shorttitle = {Control-{{Flow Bending}}},
  booktitle = {24th {{USENIX Security Symposium}} ({{USENIX Security}} 15)},
  author = {Carlini, Nicholas and Barresi, Antonio and Payer, Mathias and Wagner, David and Gross, Thomas R.},
  year = {2015},
  pages = {161--176},
  isbn = {978-1-939133-11-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ICNBM7JX\\Carlini et al. - 2015 - Control-Flow Bending On the Effectiveness of C.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\LW98DLCR\\carlini.html}
}

@inproceedings{castro2006securing,
  title = {Securing Software by Enforcing Data-Flow Integrity},
  booktitle = {Proceedings of the 7th Symposium on {{Operating}} Systems Design and Implementation},
  author = {Castro, Miguel and Costa, Manuel and Harris, Tim},
  year = {2006},
  month = nov,
  series = {{{OSDI}} '06},
  pages = {147--160},
  publisher = {{USENIX Association}},
  address = {{USA}},
  abstract = {Software attacks often subvert the intended data-flow in a vulnerable program. For example, attackers exploit buffer overflows and format string vulnerabilities to write data to unintended locations. We present a simple technique that prevents these attacks by enforcing data-flow integrity. It computes a data-flow graph using static analysis, and it instruments the program to ensure that the flow of data at runtime is allowed by the data-flow graph. We describe an efficient implementation of data-flow integrity enforcement that uses static analysis to reduce instrumentation overhead. This implementation can be used in practice to detect a broad class of attacks and errors because it can be applied automatically to C and C++ programs without modifications, it does not have false positives, and it has low overhead.},
  isbn = {978-1-931971-47-8},
  keywords = {dfi},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\YG5JWN9R\\Castro et al. - 2006 - Securing software by enforcing data-flow integrity.pdf}
}

@inproceedings{castro2009fast,
  title = {Fast Byte-Granularity Software Fault Isolation},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on {{Operating}} Systems Principles},
  author = {Castro, Miguel and Costa, Manuel and Martin, Jean-Philippe and Peinado, Marcus and Akritidis, Periklis and Donnelly, Austin and Barham, Paul and Black, Richard},
  year = {2009},
  month = oct,
  series = {{{SOSP}} '09},
  pages = {45--58},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1629575.1629581},
  abstract = {Bugs in kernel extensions remain one of the main causes of poor operating system reliability despite proposed techniques that isolate extensions in separate protection domains to contain faults. We believe that previous fault isolation techniques are not widely used because they cannot isolate existing kernel extensions with low overhead on standard hardware. This is a hard problem because these extensions communicate with the kernel using a complex interface and they communicate frequently. We present BGI (Byte-Granularity Isolation), a new software fault isolation technique that addresses this problem. BGI uses efficient byte-granularity memory protection to isolate kernel extensions in separate protection domains that share the same address space. BGI ensures type safety for kernel objects and it can detect common types of errors inside domains. Our results show that BGI is practical: it can isolate Windows drivers without requiring changes to the source code and it introduces a CPU overhead between 0 and 16\%. BGI can also find bugs during driver testing. We found 28 new bugs in widely used Windows drivers.},
  isbn = {978-1-60558-752-3},
  keywords = {device drivers,isolation,sfi},
  annotation = {190 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3IKHSFUT\\Castro et al. - 2009 - Fast byte-granularity software fault isolation.pdf}
}

@inproceedings{cha2015programadaptive,
  title = {Program-{{Adaptive Mutational Fuzzing}}},
  booktitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Cha, Sang Kil and Woo, Maverick and Brumley, David},
  year = {2015},
  month = may,
  pages = {725--741},
  issn = {2375-1207},
  doi = {10.1109/SP.2015.50},
  abstract = {We present the design of an algorithm to maximize the number of bugs found for black-box mutational fuzzing given a program and a seed input. The major intuition is to leverage white-box symbolic analysis on an execution trace for a given program-seed pair to detect dependencies among the bit positions of an input, and then use this dependency relation to compute a probabilistically optimal mutation ratio for this program-seed pair. Our result is promising: we found an average of 38.6\% more bugs than three previous fuzzers over 8 applications using the same amount of fuzzing time.},
  keywords = {Computer bugs,fuzzing,Hamming distance,mutation ratio optimization,mutational fuzzing,Optimization,Security,Software,software testing,Testing},
  annotation = {196 citations (Semantic Scholar/DOI) [2022-10-09]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\VS5V8TA4\\Cha et al. - 2015 - Program-Adaptive Mutational Fuzzing.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\4HNWQEYS\\7163057.html}
}

@inproceedings{chen2016shreds,
  title = {Shreds: {{Fine-Grained Execution Units}} with {{Private Memory}}},
  shorttitle = {Shreds},
  booktitle = {2016 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Chen, Yaohui and Reymondjohnson, Sebassujeen and Sun, Zhichuang and Lu, Long},
  year = {2016},
  month = may,
  pages = {56--71},
  issn = {2375-1207},
  doi = {10.1109/SP.2016.12},
  abstract = {Once attackers have injected code into a victim program's address space, or found a memory disclosure vulnerability, all sensitive data and code inside that address space are subject to thefts or manipulation. Unfortunately, this broad type of attack is hard to prevent, even if software developers wish to cooperate, mostly because the conventional memory protection only works at process level and previously proposed in-process memory isolation methods are not practical for wide adoption. We propose shreds, a set of OS-backed programming primitives that addresses developers' currently unmet needs for fine-grained, convenient, and efficient protection of sensitive memory content against in-process adversaries. A shred can be viewed as a flexibly defined segment of a thread execution (hence the name). Each shred is associated with a protected memory pool, which is accessible only to code running in the shred. Unlike previous works, shreds offer in-process private memory without relying on separate page tables, nested paging, or even modified hardware. Plus, shreds provide the essential data flow and control flow guarantees for running sensitive code. We have built the compiler toolchain and the OS module that together enable shreds on Linux. We demonstrated the usage of shreds and evaluated their performance using 5 non-trivial open source software, including OpenSSH and Lighttpd. The results show that shreds are fairly easy to use and incur low runtime overhead (4.67\%).},
  keywords = {fine-grained private memory,Instruction sets,intra-process isolation,Libraries,Malware,memory domain,Memory management,memory protection,Runtime,s\&p,Security,shred},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\AC382PYK\\Chen et al. - 2016 - Shreds Fine-Grained Execution Units with Private .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\GZ3CAC8Z\\7546495.html}
}

@inproceedings{chen2020koobe,
  title = {\{\vphantom\}{{KOOBE}}\vphantom\{\}: {{Towards Facilitating Exploit Generation}} of {{Kernel}} \{\vphantom\}{{Out-Of-Bounds}}\vphantom\{\} {{Write Vulnerabilities}}},
  shorttitle = {\{\vphantom\}{{KOOBE}}\vphantom\{\}},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Chen, Weiteng and Zou, Xiaochen and Li, Guoren and Qian, Zhiyun},
  year = {2020},
  pages = {1093--1110},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7SKK7IWZ\\Chen et al. - 2020 - KOOBE Towards Facilitating Exploit Generation o.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7KKIXRVX\\chen-weiteng.html}
}

@inproceedings{chen2020savior,
  title = {{{SAVIOR}}: {{Towards Bug-Driven Hybrid Testing}}},
  shorttitle = {{{SAVIOR}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Chen, Yaohui and Li, Peng and Xu, Jun and Guo, Shengjian and Zhou, Rundong and Zhang, Yulong and Wei, Tao and Lu, Long},
  year = {2020},
  month = may,
  pages = {1580--1596},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00002},
  abstract = {Hybrid testing combines fuzz testing and concolic execution. It leverages fuzz testing to test easy-to-reach code regions and uses concolic execution to explore code blocks guarded by complex branch conditions. As a result, hybrid testing is able to reach deeper into program state space than fuzz testing or concolic execution alone. Recently, hybrid testing has seen significant advancement. However, its code coverage-centric design is inefficient in vulnerability detection. First, it blindly selects seeds for concolic execution and aims to explore new code continuously. However, as statistics show, a large portion of the explored code is often bug-free. Therefore, giving equal attention to every part of the code during hybrid testing is a non-optimal strategy. It slows down the detection of real vulnerabilities by over 43\%. Second, classic hybrid testing quickly moves on after reaching a chunk of code, rather than examining the hidden defects inside. It may frequently miss subtle vulnerabilities despite that it has already explored the vulnerable code paths.We propose SAVIOR, a new hybrid testing framework pioneering a bug-driven principle. Unlike the existing hybrid testing tools, SAVIOR prioritizes the concolic execution of the seeds that are likely to uncover more vulnerabilities. Moreover, SAVIOR verifies all vulnerable program locations along the executing program path. By modeling faulty situations using SMT constraints, SAVIOR reasons the feasibility of vulnerabilities and generates concrete test cases as proofs. Our evaluation shows that the bug-driven approach outperforms mainstream automated testing techniques, including state-of-the-art hybrid testing systems driven by code coverage. On average, SAVIOR detects vulnerabilities 43.4\% faster than DRILLER and 44.3\% faster than QSYM, leading to the discovery of 88 and 76 more unique bugs, respectively. According to the evaluation on 11 well fuzzed benchmark programs, within the first 24 hours, SAVIOR triggers 481 UBSAN violations, among which 243 are real bugs.},
  keywords = {Benchmark testing,Computer bugs,Fuzzing,Security,Software,Tools},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\672JHG2G\\Chen et al. - 2020 - SAVIOR Towards Bug-Driven Hybrid Testing.pdf}
}

@inproceedings{chen2021syzgen,
  title = {{{SyzGen}}: {{Automated Generation}} of {{Syscall Specification}} of {{Closed-Source macOS Drivers}}},
  shorttitle = {{{SyzGen}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Chen, Weiteng and Wang, Yu and Zhang, Zheng and Qian, Zhiyun},
  year = {2021},
  month = nov,
  pages = {749--763},
  publisher = {{ACM}},
  address = {{Virtual Event Republic of Korea}},
  doi = {10.1145/3460120.3484564},
  abstract = {Kernel drivers are a critical part of the attack surface since they constitute a large fraction of kernel codebase and oftentimes lack proper vetting, especially for those closed-source ones. Unfortunately, the complex input structure and unknown relationships/dependencies among interfaces make them very challenging to understand. Thus, security analysts primarily rely on manual audit for interface recovery to generate meaningful fuzzing test cases. In this paper, we present SyzGen, a first attempt to automate the generation of syscall specifications for closed-source macOS drivers and facilitate interface-aware fuzzing. We leverage two insights to overcome the challenges of binary analysis: (1) iterative refinement of syscall knowledge and (2) extraction and extrapolation of dependencies from a small number of execution traces. We evaluated our approach on 25 targets. The results show that SyzGen can effectively produce high-quality specifications, leading to 34 bugs, including one that attackers can exploit to escalate privilege, and 2 CVEs to date.},
  isbn = {978-1-4503-8454-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\I6LYJ4WF\\Chen et al. - 2021 - SyzGen Automated Generation of Syscall Specificat.pdf}
}

@inproceedings{chen2021vscape,
  title = {{{VScape}}: {{Assessing}} and {{Escaping Virtual Call Protections}}},
  shorttitle = {\{\vphantom\}{{VScape}}\vphantom\{\}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Chen, Kaixiang and Zhang, Chao and Yin, Tingting and Chen, Xingman and Zhao, Lei},
  year = {2021},
  pages = {1719--1736},
  isbn = {978-1-939133-24-3},
  langid = {english},
  keywords = {cfi},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ZQWVR9DU\\Chen et al. - 2021 - VScape Assessing and Escaping Virtual Call Prot.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\8S96XX35\\chen-kaixiang.html}
}

@article{cheng2021exploitation,
  title = {Exploitation {{Techniques}} for {{Data-oriented Attacks}} with {{Existing}} and {{Potential Defense Approaches}}},
  author = {Cheng, Long and Ahmed, Salman and Liljestrand, Hans and Nyman, Thomas and Cai, Haipeng and Jaeger, Trent and Asokan, N. and Yao, Danfeng (Daphne)},
  year = {2021},
  month = sep,
  journal = {ACM Transactions on Privacy and Security},
  volume = {24},
  number = {4},
  pages = {26:1--26:36},
  issn = {2471-2566},
  doi = {10.1145/3462699},
  abstract = {Data-oriented attacks manipulate non-control data to alter a program's benign behavior without violating its control-flow integrity. It has been shown that such attacks can cause significant damage even in the presence of control-flow defense mechanisms. However, these threats have not been adequately addressed. In this survey article, we first map data-oriented exploits, including Data-Oriented Programming (DOP) and Block-Oriented Programming (BOP) attacks, to their assumptions/requirements and attack capabilities. Then, we compare known defenses against these attacks, in terms of approach, detection capabilities, overhead, and compatibility. It is generally believed that control flows may not be useful for data-oriented security. However, data-oriented attacks (especially DOP attacks) may generate side effects on control-flow behaviors in multiple dimensions (i.e., incompatible branch behaviors and frequency anomalies). We also characterize control-flow anomalies caused by data-oriented attacks. In the end, we discuss challenges for building deployable data-oriented defenses and open research questions.},
  keywords = {BOP,branch correlation,Data-oriented attacks,DOP,frequency anomaly},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ZBRDR8RE\\Cheng et al. - 2021 - Exploitation Techniques for Data-oriented Attacks .pdf}
}

@inproceedings{chisnall2017cheri,
  title = {{{CHERI JNI}}: {{Sinking}} the {{Java Security Model}} into the {{C}}},
  shorttitle = {{{CHERI JNI}}},
  booktitle = {Proceedings of the {{Twenty-Second International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Chisnall, David and Davis, Brooks and Gudka, Khilan and Brazdil, David and Joannou, Alexandre and Woodruff, Jonathan and Markettos, A. Theodore and Maste, J. Edward and Norton, Robert and Son, Stacey and Roe, Michael and Moore, Simon W. and Neumann, Peter G. and Laurie, Ben and Watson, Robert N.M.},
  year = {2017},
  month = apr,
  series = {{{ASPLOS}} '17},
  pages = {569--583},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3037697.3037725},
  abstract = {Java provides security and robustness by building a high-level security model atop the foundation of memory protection. Unfortunately, any native code linked into a Java program -- including the million lines used to implement the standard library -- is able to bypass both the memory protection and the higher-level policies. We present a hardware-assisted implementation of the Java native code interface, which extends the guarantees required for Java's security model to native code. Our design supports safe direct access to buffers owned by the JVM, including hardware-enforced read-only access where appropriate. We also present Java language syntax to declaratively describe isolated compartments for native code. We show that it is possible to preserve the memory safety and isolation requirements of the Java security model in C code, allowing native code to run in the same process as Java code with the same impact on security as running equivalent Java code. Our approach has a negligible impact on performance, compared with the existing unsafe native code interface. We demonstrate a prototype implementation running on the CHERI microprocessor synthesized in FPGA.},
  isbn = {978-1-4503-4465-4},
  keywords = {architecture,capability systems,cheri,compartmentalization,compilers,hardware security,java,jni,language security,memory protection,sandboxing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3GUBHI95\\Chisnall et al. - 2017 - CHERI JNI Sinking the Java Security Model into th.pdf}
}

@inproceedings{cho2022vik,
  title = {{{ViK}}: Practical Mitigation of Temporal Memory Safety Violations through Object {{ID}} Inspection},
  shorttitle = {{{ViK}}},
  booktitle = {Proceedings of the 27th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Cho, Haehyun and Park, Jinbum and Oest, Adam and Bao, Tiffany and Wang, Ruoyu and Shoshitaishvili, Yan and Doup{\'e}, Adam and Ahn, Gail-Joon},
  year = {2022},
  month = feb,
  series = {{{ASPLOS}} 2022},
  pages = {271--284},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3503222.3507780},
  abstract = {Temporal memory safety violations, such as use-after-free (UAF) vulnerabilities, are a critical security issue for software written in memory-unsafe languages such as C and C++. In this paper, we introduce ViK, a novel, lightweight, and widely applicable runtime defense that can protect both operating system (OS) kernels and user-space applications against temporal memory safety violations. ViK performs object ID inspection, where it assigns a random identifier to every allocated object and stores the identifier in the unused bits of the corresponding pointer. When the pointer is used, ViK inspects the value of a pointer before dereferencing, ensuring that the pointer still references the original object. To the best of our knowledge, this is the first mitigation against temporal memory safety violations that scales to OS kernels. We evaluated the software prototype of ViK on Android and Linux kernels and observed runtime overhead of around 20\%. Also, we evaluated a hardware-assisted prototype of ViK on Android kernel, where the runtime overhead was as low as 2\%.},
  isbn = {978-1-4503-9205-1},
  keywords = {Operating System Kernels,Temporal Memory Safety Violations},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WG3G74UR\\Cho et al. - 2022 - ViK practical mitigation of temporal memory safet.pdf}
}

@inproceedings{clements2017protecting,
  title = {Protecting {{Bare-Metal Embedded Systems}} with {{Privilege Overlays}}},
  booktitle = {2017 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Clements, Abraham A. and Almakhdhub, Naif Saleh and Saab, Khaled S. and Srivastava, Prashast and Koo, Jinkyu and Bagchi, Saurabh and Payer, Mathias},
  year = {2017},
  month = may,
  pages = {289--303},
  issn = {2375-1207},
  doi = {10.1109/SP.2017.37},
  abstract = {Embedded systems are ubiquitous in every aspect of modern life. As the Internet of Thing expands, our dependence on these systems increases. Many of these interconnected systems are and will be low cost bare-metal systems, executing without an operating system. Bare-metal systems rarely employ any security protection mechanisms and their development assumptions (unrestricted access to all memory and instructions), and constraints(runtime, energy, and memory) makes applying protections challenging. To address these challenges we present EPOXY, an LLVM-based embedded compiler. We apply a novel technique, called privilege overlaying, wherein operations requiring privileged execution are identified and only these operations execute in privileged mode. This provides the foundation on which code-integrity, adapted control-flow hijacking defenses, and protections for sensitive IO are applied. We also design fine-grained randomization schemes, that work within the constraints of bare-metal systems to provide further protection against control-flow and data corruption attacks. These defenses prevent code injection attacks and ROP attacks from scaling across large sets of devices. We evaluate the performance of our combined defense mechanisms for a suite of 75 benchmarks and 3 real-world IoT applications. Our results for the application case studies show that EPOXY has, on average, a 1.8\% increase in execution time and a 0.5\% increase in energy usage.},
  keywords = {Bare-metal,Cyber-Security,Diversity,Embedded systems,Embedded Systems,Hardware,Memory management,Privilege Overlay,Random access memory,Registers,Runtime,Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LXGEUSBK\\Clements et al. - 2017 - Protecting Bare-Metal Embedded Systems with Privil.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\DYJ5HK2V\\7958583.html}
}

@inproceedings{clements2018aces,
  title = {{{ACES}}: {{Automatic Compartments}} for {{Embedded Systems}}},
  shorttitle = {\{\vphantom\}{{ACES}}\vphantom\{\}},
  booktitle = {27th {{USENIX Security Symposium}} ({{USENIX Security}} 18)},
  author = {Clements, Abraham A. and Almakhdhub, Naif Saleh and Bagchi, Saurabh and Payer, Mathias},
  year = {2018},
  pages = {65--82},
  isbn = {978-1-939133-04-5},
  langid = {english},
  keywords = {compartmentalization,embedded,pdg},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QNJT8QSI\\Clements et al. - 2018 - ACES Automatic Compartments for Embedded System.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\23MM5P9E\\clements.html}
}

@inproceedings{connor2020pku,
  title = {\{\vphantom\}{{PKU}}\vphantom\{\} {{Pitfalls}}: {{Attacks}} on \{\vphantom\}{{PKU-based}}\vphantom\{\} {{Memory Isolation Systems}}},
  shorttitle = {\{\vphantom\}{{PKU}}\vphantom\{\} {{Pitfalls}}},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Connor, R. Joseph and McDaniel, Tyler and Smith, Jared M. and Schuchard, Max},
  year = {2020},
  pages = {1409--1426},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\VV4NFLE3\\Connor et al. - 2020 - PKU Pitfalls Attacks on PKU-based Memory Isol.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\VKMBGFVP\\connor.html}
}

@inproceedings{corina2017difuze,
  title = {{{DIFUZE}}: {{Interface Aware Fuzzing}} for {{Kernel Drivers}}},
  shorttitle = {{{DIFUZE}}},
  booktitle = {Proceedings of the 2017 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Corina, Jake and Machiry, Aravind and Salls, Christopher and Shoshitaishvili, Yan and Hao, Shuang and Kruegel, Christopher and Vigna, Giovanni},
  year = {2017},
  month = oct,
  series = {{{CCS}} '17},
  pages = {2123--2138},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3133956.3134069},
  abstract = {Device drivers are an essential part in modern Unix-like systems to handle operations on physical devices, from hard disks and printers to digital cameras and Bluetooth speakers. The surge of new hardware, particularly on mobile devices, introduces an explosive growth of device drivers in system kernels. Many such drivers are provided by third-party developers, which are susceptible to security vulnerabilities and lack proper vetting. Unfortunately, the complex input data structures for device drivers render traditional analysis tools, such as fuzz testing, less effective, and so far, research on kernel driver security is comparatively sparse. In this paper, we present DIFUZE, an interface-aware fuzzing tool to automatically generate valid inputs and trigger the execution of the kernel drivers. We leverage static analysis to compose correctly-structured input in the userspace to explore kernel drivers. DIFUZE is fully automatic, ranging from identifying driver handlers, to mapping to device file names, to constructing complex argument instances. We evaluate our approach on seven modern Android smartphones. The results show that DIFUZE can effectively identify kernel driver bugs, and reports 32 previously unknown vulnerabilities, including flaws that lead to arbitrary code execution.},
  isbn = {978-1-4503-4946-8},
  keywords = {fuzzing,interface aware,kernel drivers},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\A2YSUUA9\\Corina et al. - 2017 - DIFUZE Interface Aware Fuzzing for Kernel Drivers.pdf}
}

@inproceedings{datta2020valve,
  title = {Valve: {{Securing Function Workflows}} on {{Serverless Computing Platforms}}},
  shorttitle = {Valve},
  booktitle = {Proceedings of {{The Web Conference}} 2020},
  author = {Datta, Pubali and Kumar, Prabuddha and Morris, Tristan and Grace, Michael and Rahmati, Amir and Bates, Adam},
  year = {2020},
  month = apr,
  pages = {939--950},
  publisher = {{ACM}},
  address = {{Taipei Taiwan}},
  doi = {10.1145/3366423.3380173},
  abstract = {Serverless Computing has quickly emerged as a dominant cloud computing paradigm, allowing developers to rapidly prototype eventdriven applications using a composition of small functions that each perform a single logical task. However, many such application workflows are based in part on publicly-available functions developed by third-parties, creating the potential for functions to behave in unexpected, or even malicious, ways. At present, developers are not in total control of where and how their data is flowing, creating significant security and privacy risks in growth markets that have embraced serverless (e.g., IoT).},
  isbn = {978-1-4503-7023-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8EUMHFJP\\Datta et al. - 2020 - Valve Securing Function Workflows on Serverless C.pdf}
}

@inproceedings{davi2014hardwareassisted,
  title = {Hardware-Assisted Fine-Grained Control-Flow Integrity: {{Towards}} Efficient Protection of Embedded Systems against Software Exploitation},
  shorttitle = {Hardware-Assisted Fine-Grained Control-Flow Integrity},
  booktitle = {2014 51st {{ACM}}/{{EDAC}}/{{IEEE Design Automation Conference}} ({{DAC}})},
  author = {Davi, Lucas and Koeberl, Patrick and Sadeghi, Ahmad-Reza},
  year = {2014},
  month = jun,
  pages = {1--6},
  issn = {0738-100X},
  doi = {10.1109/DAC.2014.6881460},
  abstract = {Embedded systems have become pervasive and are built into a vast number of devices such as sensors, vehicles, mobile and wearable devices. However, due to resource constraints, they fail to provide sufficient security, and are particularly vulnerable to runtime attacks (code injection and ROP). Previous works have proposed the enforcement of control-flow integrity (CFI) as a general defense against runtime attacks. However, existing solutions either suffer from performance overhead or only enforce coarse-grain CFI policies that a sophisticated adversary can undermine. In this paper, we tackle these limitations and present the design of novel security hardware mechanisms to enable fine-grained CFI checks. Our CFI proposal is based on a state model and a per-function CFI label approach. In particular, our CFI policies ensure that function returns can only transfer control to active call sides (i.e, return landing pads of functions currently executing). Further, we restrict indirect calls to target the beginning of a function, and lastly, deploy behavioral heuristics for indirect jumps.},
  keywords = {cfi,Embedded systems,fine-grained cfi,Hardware,Payloads,Radiation detectors,Runtime,Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SETJAPEX\\Davi et al. - 2014 - Hardware-assisted fine-grained control-flow integr.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\MWMTALG7\\6881460.html}
}

@inproceedings{davis2019cheriabi,
  title = {{{CheriABI}}: {{Enforcing Valid Pointer Provenance}} and {{Minimizing Pointer Privilege}} in the {{POSIX C Run-time Environment}}},
  shorttitle = {{{CheriABI}}},
  booktitle = {Proceedings of the {{Twenty-Fourth International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Davis, Brooks and Watson, Robert N. M. and Richardson, Alexander and Neumann, Peter G. and Moore, Simon W. and Baldwin, John and Chisnall, David and Clarke, Jessica and Filardo, Nathaniel Wesley and Gudka, Khilan and Joannou, Alexandre and Laurie, Ben and Markettos, A. Theodore and Maste, J. Edward and Mazzinghi, Alfredo and Napierala, Edward Tomasz and Norton, Robert M. and Roe, Michael and Sewell, Peter and Son, Stacey and Woodruff, Jonathan},
  year = {2019},
  month = apr,
  series = {{{ASPLOS}} '19},
  pages = {379--393},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3297858.3304042},
  abstract = {The CHERI architecture allows pointers to be implemented as capabilities (rather than integer virtual addresses) in a manner that is compatible with, and strengthens, the semantics of the C language. In addition to the spatial protections offered by conventional fat pointers, CHERI capabilities offer strong integrity, enforced provenance validity, and access monotonicity. The stronger guarantees of these architectural capabilities must be reconciled with the real-world behavior of operating systems, run-time environments, and applications. When the process model, user-kernel interactions, dynamic linking, and memory management are all considered, we observe that simple derivation of architectural capabilities is insufficient to describe appropriate access to memory. We bridge this conceptual gap with a notional abstract capability that describes the accesses that should be allowed at a given point in execution, whether in the kernel or userspace. To investigate this notion at scale, we describe the first adaptation of a full C-language operating system (FreeBSD) with an enterprise database (PostgreSQL) for complete spatial and referential memory safety. We show that awareness of abstract capabilities, coupled with CHERI architectural capabilities, can provide more complete protection, strong compatibility, and acceptable performance overhead compared with the pre-CHERI baseline and software-only approaches. Our observations also have potentially significant implications for other mitigation techniques.},
  isbn = {978-1-4503-6240-5},
  keywords = {cheri,hardware,operating systems,security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2LQ7GFAN\\Davis et al. - 2019 - CheriABI Enforcing Valid Pointer Provenance and M.pdf}
}

@inproceedings{daw2021speedo,
  title = {Speedo: {{Fast}} Dispatch and Orchestration of Serverless Workflows},
  shorttitle = {Speedo},
  booktitle = {Proceedings of the {{ACM Symposium}} on {{Cloud Computing}}},
  author = {Daw, Nilanjan and Bellur, Umesh and Kulkarni, Purushottam},
  year = {2021},
  month = nov,
  series = {{{SoCC}} '21},
  pages = {585--599},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3472883.3486982},
  abstract = {Structuring cloud applications as collections of interacting fine-grained microservices makes them scalable and affords the flexibility of hot upgrading parts of the application. The current avatar of serverless computing (FaaS) with its dynamic resource allocation and auto-scaling capabilities make it the deployment model of choice for such applications. FaaS platforms operate with user space dispatchers that receive requests over the network and make a dispatch decision to one of multiple workers (usually a container) distributed in the data center. With the granularity of microservices approaching execution times of a few milliseconds combined with loads approaching tens of thousands of requests a second, having a low dispatch latency of less than one millisecond becomes essential to keep up with line rates. When these microservices are part of a workflow making up an application, the orchestrator that coordinates the sequence in which microservices execute also needs to operate with microsecond latency. Our observations reveal that the most significant component of the dispatch/orchestration latency is the time it takes for the request to traverse into and out of the user space from the network. Motivated by the presence of a multitude of low power cores on today's SmartNICs, one approach to keeping up with these high line rates and the stringent latency expectations is to run both the dispatcher and the orchestrator close to the network on a SmartNIC. Doing so will save valuable cycles spent in transferring requests to and back from the user space. The operating characteristics of short-lived ephemeral state and low CPU burst requirements of FaaS dispatcher/orchestrator make them ideal candidates for offloading from the server to the NIC cores. This also brings other benefit of freeing up the server CPU. In this paper, we present Speedo--- a design for offloading of FaaS dispatch and orchestration services to the SmartNIC from the user space. We implemented Speedo on ASIC based Netronome Agilio SmartNICs and our comprehensive evaluation shows that Speedo brings down the dispatch latency from \textasciitilde 150ms to \textasciitilde 140{$\mu$}s at a load of 10K requests per second.},
  isbn = {978-1-4503-8638-8},
  keywords = {orchestration,programmable SmartNIC,serverless workflows},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ER9M6VE5\\Daw et al. - 2021 - Speedo Fast dispatch and orchestration of serverl.pdf}
}

@inproceedings{devaux2019true,
  title = {The True {{Processing In Memory}} Accelerator},
  shorttitle = {Upmem},
  booktitle = {2019 {{IEEE Hot Chips}} 31 {{Symposium}} ({{HCS}})},
  author = {Devaux, Fabrice},
  year = {2019},
  month = aug,
  pages = {1--24},
  publisher = {{IEEE Computer Society}},
  doi = {10.1109/HOTCHIPS.2019.8875680},
  abstract = {The following topics are dealt with: microprocessor chips; system-on-chip; learning (artificial intelligence); cache storage; inference mechanisms; performance evaluation; security; neural chips; memory architecture; graphics processing units.},
  isbn = {978-1-72812-089-8},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\US47B5VI\\Devaux - 2019 - The true Processing In Memory accelerator.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\WJL75S95\\1ehCtkMGwkU.html}
}

@inproceedings{ding2017efficient,
  title = {Efficient {{Protection}} of \{\vphantom\}{{Path-Sensitive}}\vphantom\{\} {{Control Security}}},
  booktitle = {26th {{USENIX Security Symposium}} ({{USENIX Security}} 17)},
  author = {Ding, Ren and Qian, Chenxiong and Song, Chengyu and Harris, Bill and Kim, Taesoo and Lee, Wenke},
  year = {2017},
  pages = {131--148},
  isbn = {978-1-931971-40-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XA5FUAAS\\Ding et al. - 2017 - Efficient Protection of Path-Sensitive Control S.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\FAHEPXYR\\ding.html}
}

@inproceedings{duck2022hardening,
  title = {Hardening Binaries against More Memory Errors},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Duck, Gregory J. and Zhang, Yuntong and Yap, Roland H. C.},
  year = {2022},
  month = mar,
  pages = {117--131},
  publisher = {{ACM}},
  address = {{Rennes France}},
  doi = {10.1145/3492321.3519580},
  abstract = {Memory errors, such as buffer overflows and use-after-free, remain the root cause of many security vulnerabilities in modern software. The use of closed source software further exacerbates the problem, as source-based memory error mitigation cannot be applied. While many memory error detection tools exist, most are based on a single error detection methodology with resulting known limitations, such as incomplete memory error detection (redzones) or false error detections (low-fat pointers). In this paper we introduce RedFat, a memory error hardening tool for stripped binaries that is fast, practical and scalable. The core idea behind RedFat is to combine complementary error detection methodologies\textemdash redzones and low-fat pointers\textemdash in order to detect more memory errors that can be detected by each individual methodology alone. However, complementary error detection also inherits the limitations of each approach, such as false error detections from low-fat pointers. To mitigate this, we introduce a profile-based analysis that automatically determines the strongest memory error protection possible without negative side effects.},
  isbn = {978-1-4503-9162-7},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BFSP83ZX\\Duck et al. - 2022 - Hardening binaries against more memory errors.pdf}
}

@article{duy2021confidential,
  title = {Confidential {{Machine Learning Computation}} in {{Untrusted Environments}}: {{A Systems Security Perspective}}},
  shorttitle = {Confidential {{Machine Learning Computation}} in {{Untrusted Environments}}},
  author = {Duy, Kha Dinh and Noh, Taehyun and Huh, Siwon and Lee, Hojoon},
  year = {2021},
  journal = {IEEE Access},
  volume = {9},
  pages = {168656--168677},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2021.3136889},
  abstract = {As machine learning (ML) technologies and applications are rapidly changing many computing domains, security issues associated with ML are also emerging. In the domain of systems security, many endeavors have been made to ensure ML model and data confidentiality. ML computations are often inevitably performed in untrusted environments and entail complex multi-party security requirements. Hence, researchers have leveraged the Trusted Execution Environments (TEEs) to build confidential ML computation systems. We conduct a systematic and comprehensive survey by classifying attack vectors and mitigation in confidential ML computation in untrusted environments, analyzing the complex security requirements in multi-party scenarios, and summarizing engineering challenges in confidential ML implementation. Lastly, we suggest future research directions based on our study.},
  copyright = {All rights reserved},
  keywords = {Codes,Computational modeling,Confidential machine learning computation,Data models,Hardware,Machine learning,multi-party ML computation,Security,side-channel attacks,Software,trusted execution},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6CTLBWFW\\Duy et al. - 2021 - Confidential Machine Learning Computation in Untru.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\S5XQXTAS\\9656734.html}
}

@inproceedings{elkaduwe2008kernel,
  title = {Kernel Design for Isolation and Assurance of Physical Memory},
  booktitle = {Proceedings of the 1st Workshop on {{Isolation}} and Integration in Embedded Systems},
  author = {Elkaduwe, Dhammika and Derrin, Philip and Elphinstone, Kevin},
  year = {2008},
  month = apr,
  series = {{{IIES}} '08},
  pages = {35--40},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1435458.1435465},
  abstract = {Embedded systems are evolving into increasingly complex software systems. One approach to managing this software complexity is to divide the system into smaller, tractable components and provide strong isolation guarantees between them. This paper focuses on one aspect of the system's behaviour that is critical to any such guarantee: management of physical memory resources. We present the design of a kernel that has formally demonstrated the ability to make strong isolation guarantees of physical memory. We also present the macro-level performance characteristics of a kernel implementing the proposed design.},
  isbn = {978-1-60558-126-2},
  keywords = {embedded systems,isolation,memory management,microkernels,seL4},
  annotation = {30 citations (Semantic Scholar/DOI) [2022-10-25]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BIPQD6LP\\Elkaduwe et al. - 2008 - Kernel design for isolation and assurance of physi.pdf}
}

@incollection{erdos2022minesweeper,
  title = {{{MineSweeper}}: A ``Clean Sweep'' for Drop-in Use-after-Free Prevention},
  shorttitle = {{{MineSweeper}}},
  booktitle = {Proceedings of the 27th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Erd{\H o}s, M{\'a}rton and Ainsworth, Sam and Jones, Timothy M.},
  year = {2022},
  month = feb,
  pages = {212--225},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  abstract = {Low-level languages, which require manual memory management from the programmer, remain in wide use for performance-critical applications. Memory-safety bugs are common, and now a major source of exploits. In particular, a use-after-free bug occurs when an object is erroneously deallocated, whilst pointers to it remain active in memory, and those (dangling) pointers are later used to access the object. An attacker can reallocate the memory area backing an erroneously freed object, then overwrite its contents, injecting carefully chosen data into the host program, thus altering its execution and achieving privilege escalation. We present MineSweeper, a system to mitigate use-after-free vulnerabilities by retaining freed allocations in a quarantine, until no pointers to them remain in program memory, thus preventing their reallocation until it is safe. MineSweeper performs efficient linear sweeps of memory to identify quarantined items that have no dangling pointers to them, and thus can be safely reallocated. This allows MineSweeper to be significantly more efficient than previous transitive marking procedure techniques. MineSweeper, attached to JeMalloc, improves security at an acceptable overhead in memory footprint (11.1\% on average) and an execution-time cost of only 5.4\% (geometric mean for SPEC CPU2006), with 9.6\% additional threaded CPU usage. These figures considerably improve on the state-of-the-art for non-probabilistic drop-in temporal-safety systems, and make MineSweeper the only such scheme suitable for deployment in real-world production environments.},
  isbn = {978-1-4503-9205-1},
  keywords = {programming language security,temporal safety,use-after-free},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6LYVK9PS\\ErdÅ‘s et al. - 2022 - MineSweeper a â€œclean sweepâ€ for drop-in use-after.pdf}
}

@incollection{erlingsson2010lowlevel,
  title = {Low-{{Level Software Security}} by {{Example}}},
  booktitle = {Handbook of {{Information}} and {{Communication Security}}},
  author = {Erlingsson, {\'U}lfar and Younan, Yves and Piessens, Frank},
  editor = {Stavroulakis, Peter and Stamp, Mark},
  year = {2010},
  pages = {633--658},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-04117-4_30},
  isbn = {978-3-642-04116-7 978-3-642-04117-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2I352FTW\\Erlingsson et al. - 2010 - Low-Level Software Security by Example.pdf}
}

@article{esswoodcherios,
  title = {{{CheriOS}}: {{Designing}} an Untrusted Single-Address-Space Capability Operating System Utilising Capability Hardware and a Minimal Hypervisor},
  author = {Esswood, Lawrence G},
  pages = {201},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TFFTPGNX\\Esswood - CheriOS Designing an untrusted single-address-spa.pdf}
}

@inproceedings{evans2015control,
  title = {Control {{Jujutsu}}: {{On}} the {{Weaknesses}} of {{Fine-Grained Control Flow Integrity}}},
  shorttitle = {Control {{Jujutsu}}},
  booktitle = {Proceedings of the 22nd {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Evans, Isaac and Long, Fan and Otgonbaatar, Ulziibayar and Shrobe, Howard and Rinard, Martin and Okhravi, Hamed and {Sidiroglou-Douskos}, Stelios},
  year = {2015},
  month = oct,
  pages = {901--913},
  publisher = {{ACM}},
  address = {{Denver Colorado USA}},
  doi = {10.1145/2810103.2813646},
  abstract = {Control flow integrity (CFI) has been proposed as an approach to defend against control-hijacking memory corruption attacks. CFI works by assigning tags to indirect branch targets statically and checking them at runtime. Coarse-grained enforcements of CFI that use a small number of tags to improve the performance overhead have been shown to be ineffective. As a result, a number of recent efforts have focused on fine-grained enforcement of CFI as it was originally proposed. In this work, we show that even a finegrained form of CFI with unlimited number of tags and a shadow stack (to check calls and returns) is ineffective in protecting against malicious attacks. We show that many popular code bases such as Apache and Nginx use coding practices that create flexibility in their intended control flow graph (CFG) even when a strong static analyzer is used to construct the CFG. These flexibilities allow an attacker to gain control of the execution while strictly adhering to a fine-grained CFI. We then construct two proof-of-concept exploits that attack an unlimited tag CFI system with a shadow stack. We also evaluate the difficulties of generating a precise CFG using scalable static analysis for real-world applications. Finally, we perform an analysis on a number of popular applications that highlights the availability of such attacks.},
  isbn = {978-1-4503-3832-5},
  langid = {english},
  keywords = {cfi,code reuse,control flow integrity,fine-grained cfi,memory corruption,return-oriented programming},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\79K2Q9VL\\Evans et al. - 2015 - Control Jujutsu On the Weaknesses of Fine-Grained.pdf}
}

@inproceedings{evans2015missing,
  title = {Missing the {{Point}}(Er): {{On}} the {{Effectiveness}} of {{Code Pointer Integrity}}},
  shorttitle = {Missing the {{Point}}(Er)},
  booktitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Evans, Isaac and Fingeret, Sam and Gonzalez, Julian and Otgonbaatar, Ulziibayar and Tang, Tiffany and Shrobe, Howard and {Sidiroglou-Douskos}, Stelios and Rinard, Martin and Okhravi, Hamed},
  year = {2015},
  month = may,
  pages = {781--796},
  issn = {2375-1207},
  doi = {10.1109/SP.2015.53},
  abstract = {Memory corruption attacks continue to be a major vector of attack for compromising modern systems. Numerous defenses have been proposed against memory corruption attacks, but they all have their limitations and weaknesses. Stronger defenses such as complete memory safety for legacy languages (C/C++) incur a large overhead, while weaker ones such as practical control flow integrity have been shown to be ineffective. A recent technique called code pointer integrity (CPI) promises to balance security and performance by focusing memory safety on code pointers thus preventing most control-hijacking attacks while maintaining low overhead. CPI protects access to code pointers by storing them in a safe region that is protected by instruction level isolation. On x86-32, this isolation is enforced by hardware, on x86-64 and ARM, isolation is enforced by information hiding. We show that, for architectures that do not support segmentation in which CPI relies on information hiding, CPI's safe region can be leaked and then maliciously modified by using data pointer overwrites. We implement a proof-of-concept exploit against Nginx and successfully bypass CPI implementations that rely on information hiding in 6 seconds with 13 observed crashes. We also present an attack that generates no crashes and is able to bypass CPI in 98 hours. Our attack demonstrates the importance of adequately protecting secrets in security mechanisms and the dangers of relying on difficulty of guessing without guaranteeing the absence of memory leaks.},
  keywords = {Computer crashes,Delays,Libraries,Safety,Security},
  annotation = {159 citations (Semantic Scholar/DOI) [2022-10-24]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\G5U4A8UN\\Evans et al. - 2015 - Missing the Point(er) On the Effectiveness of Cod.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\FKR37GSX\\7163060.html}
}

@inproceedings{evans2020rust,
  title = {Is {{Rust Used Safely}} by {{Software Developers}}?},
  booktitle = {2020 {{IEEE}}/{{ACM}} 42nd {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Evans, Ana Nora and Campbell, Bradford and Soffa, Mary Lou},
  year = {2020},
  month = oct,
  pages = {246--257},
  issn = {1558-1225},
  abstract = {Rust, an emerging programming language with explosive growth, provides a robust type system that enables programmers to write memory-safe and data-race free code. To allow access to a machine's hardware and to support low-level performance optimizations, a second language, Unsafe Rust, is embedded in Rust. It contains support for operations that are difficult to statically check, such as C-style pointers for access to arbitrary memory locations and mutable global variables. When a program uses these features, the compiler is unable to statically guarantee the safety properties Rust promotes. In this work, we perform a large-scale empirical study to explore how software developers are using Unsafe Rust in real-world Rust libraries and applications. Our results indicate that software engineers use the keyword unsafe in less than 30\% of Rust libraries, but more than half cannot be entirely statically checked by the Rust compiler because of Unsafe Rust hidden somewhere in a library's call chain. We conclude that although the use of the keyword unsafe is limited, the propagation of unsafeness offers a challenge to the claim of Rust as a memory-safe language. Furthermore, we recommend changes to the Rust compiler and to the central Rust repository's interface to help Rust software developers be aware of when their Rust code is unsafe.},
  keywords = {Hardware,Libraries,Optimization,Program processors,Safety,Software,Software engineering},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4IFHE2D9\\Evans et al. - 2020 - Is Rust Used Safely by Software Developers.pdf}
}

@inproceedings{fan2019smoke,
  title = {{{SMOKE}}: {{Scalable Path-Sensitive Memory Leak Detection}} for {{Millions}} of {{Lines}} of {{Code}}},
  shorttitle = {{{SMOKE}}},
  booktitle = {2019 {{IEEE}}/{{ACM}} 41st {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Fan, Gang and Wu, Rongxin and Shi, Qingkai and Xiao, Xiao and Zhou, Jinguo and Zhang, Charles},
  year = {2019},
  month = may,
  pages = {72--82},
  issn = {1558-1225},
  doi = {10.1109/ICSE.2019.00025},
  abstract = {Detecting memory leak at industrial scale is still not well addressed, in spite of the tremendous effort from both industry and academia in the past decades. Existing work suffers from an unresolved paradox - a highly precise analysis limits its scalability and an imprecise one seriously hurts its precision or recall. In this work, we present SMOKE, a staged approach to resolve this paradox. In the ?rst stage, instead of using a uniform precise analysis for all paths, we use a scalable but imprecise analysis to compute a succinct set of candidate memory leak paths. In the second stage, we leverage a more precise analysis to verify the feasibility of those candidates. The ?rst stage is scalable, due to the design of a new sparse program representation, the use-?ow graph (UFG), that models the problem as a polynomial-time state analysis. The second stage analysis is both precise and ef?cient, due to the smaller number of candidates and the design of a dedicated constraint solver. Experimental results show that SMOKE can ?nish checking industrial-sized projects, up to 8MLoC, in forty minutes with an average false positive rate of 24.4\%. Besides, SMOKE is signi?cantly faster than the state-of-the-art research techniques as well as the industrial tools, with the speedup ranging from 5.2X to 22.8X. In the twenty-nine mature and extensively checked benchmark projects, SMOKE has discovered thirty previously unknown memory leaks which were con?rmed by developers, and one even assigned a CVE ID.},
  keywords = {Benchmark testing,Complexity theory,Computer bugs,Correlation,Leak detection,memory leak; static bug finding; use-flow graph; value-flow graph,Scalability,Tools},
  annotation = {26 citations (Semantic Scholar/DOI) [2022-09-05]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GBLFDPEX\\Fan et al. - 2019 - SMOKE Scalable Path-Sensitive Memory Leak Detecti.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\N63YMGAG\\8812075.html}
}

@inproceedings{farkhani2021ptauth,
  title = {{{PTAuth}}: {{Temporal Memory Safety}} via {{Robust Points-to Authentication}}},
  shorttitle = {\{\vphantom\}{{PTAuth}}\vphantom\{\}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Farkhani, Reza Mirzazade and Ahmadi, Mansour and Lu, Long},
  year = {2021},
  pages = {1037--1054},
  isbn = {978-1-939133-24-3},
  langid = {english},
  keywords = {pointer authentication},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\VQX4PDQJ\\Farkhani et al. - 2021 - PTAuth Temporal Memory Safety via Robust Points.pdf}
}

@inproceedings{frassetto2022cfinsight,
  title = {{{CFInsight}}: {{A Comprehensive Metric}} for {{CFI Policies}}},
  shorttitle = {{{CFInsight}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Frassetto, Tommaso and Jauernig, Patrick and Koisser, David and Sadeghi, Ahmad-Reza},
  year = {2022},
  publisher = {{Internet Society}},
  address = {{San Diego, CA, USA}},
  doi = {10.14722/ndss.2022.23165},
  abstract = {Software vulnerabilities are one of the major threats to computer security and have caused substantial damage over the past decades. Consequently, numerous techniques have been proposed to mitigate the risk of exploitation of vulnerable programs. One of the most relevant defense mechanisms is ControlFlow Integrity (CFI): multiple variants have been introduced and extensively discussed in academia as well as deployed in the industry. However, it is hard to compare the security guarantees of these implementations as existing metrics (such as AIR) do not consider the different usefulness to the attacker of different basic blocks, which are the fundamental components that constitute the code of any application.},
  isbn = {978-1-891562-74-7},
  langid = {english},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MGLFUPBC\\Frassetto et al. - 2022 - CFInsight A Comprehensive Metric for CFI Policies.pdf}
}

@inproceedings{fu2021cpscan,
  title = {{{CPscan}}: {{Detecting Bugs Caused}} by {{Code Pruning}} in {{IoT Kernels}}},
  shorttitle = {{{CPscan}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Fu, Lirong and Ji, Shouling and Lu, Kangjie and Liu, Peiyu and Zhang, Xuhong and Duan, Yuxuan and Zhang, Zihui and Chen, Wenzhi and Wu, Yanjun},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {794--810},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484738},
  abstract = {To reduce the development costs, IoT vendors tend to construct IoT kernels by customizing the Linux kernel. Code pruning is common in this customization process. However, due to the intrinsic complexity of the Linux kernel and the lack of long-term effective maintenance, IoT vendors may mistakenly delete necessary security operations in the pruning process, which leads to various bugs such as memory leakage and NULL pointer dereference. Yet detecting bugs caused by code pruning in IoT kernels is difficult. Specifically, (1) a significant structural change makes precisely locating the deleted security operations (DSO ) difficult, and (2) inferring the security impact of a DSO is not trivial since it requires complex semantic understanding, including the developing logic and the context of the corresponding IoT kernel. In this paper, we present CPscan, a system for automatically detecting bugs caused by code pruning in IoT kernels. First, using a new graph-based approach that iteratively conducts a structure-aware basic block matching, CPscan can precisely and efficiently identify theDSOs in IoT kernels. Then, CPscan infers the security impact of a DSO by comparing the bounded use chains (where and how a variable is used within potentially influenced code segments) of the security-critical variable associated with it. Specifically, CPscan reports the deletion of a security operation as vulnerable if the bounded use chain of the associated security-critical variable remains the same before and after the deletion. This is because the unchanged uses of a security-critical variable likely need the security operation, and removing it may have security impacts. The experimental results on 28 IoT kernels from 10 popular IoT vendors show that CPscan is able to identify 3,193DSO s and detect 114 new bugs with a reasonably low false-positive rate. Many such bugs tend to have a long latent period (up to 9 years and 5 months). We believe CPscan paves a way for eliminating the bugs introduced by code pruning in IoT kernels. We will open-source CPscan to facilitate further research.},
  isbn = {978-1-4503-8454-4},
  keywords = {bug detection,inconsistency analysis,missing security operation,static analysis},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JCQJPI2B\\Fu et al. - 2021 - CPscan Detecting Bugs Caused by Code Pruning in I.pdf}
}

@inproceedings{gadepalli2020sledge,
  title = {Sledge: A {{Serverless-first}}, {{Light-weight Wasm Runtime}} for the {{Edge}}},
  shorttitle = {Sledge},
  booktitle = {Proceedings of the 21st {{International Middleware Conference}}},
  author = {Gadepalli, Phani Kishore and McBride, Sean and Peach, Gregor and Cherkasova, Ludmila and Parmer, Gabriel},
  year = {2020},
  month = dec,
  series = {Middleware '20},
  pages = {265--279},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3423211.3425680},
  abstract = {Emerging IoT applications with real-time latency constraints require new data processing systems operating at the Edge. Serverless computing offers a new compelling paradigm, where a user can execute a small application without handling the operational issues of server provisioning and resource management. Despite a variety of existing commercial and open source serverless platforms (utilizing VMs and containers), these solutions are too heavy-weight for a resource-constrained Edge systems (due to large memory footprint and high invocation time). Moreover, serverless workloads that focus on per-client, short-running computations are not an ideal fit for existing general purpose computing systems. In this paper, we present the design and implementation of Sledge -- a novel and efficient WebAssembly-based serverless framework for the Edge. Sledge is optimized for supporting unique properties of serverless workloads: the need for high density multi-tenancy, low startup time, bursty client request rates, and short-lived computations. Sledge is designed for these constraints by offering (i) optimized scheduling policies and efficient work-distribution for short-lived computations, and (ii) a light-weight function isolation model implemented using our own WebAssembly-based software fault isolation infrastructure. These lightweight sandboxes are designed to support high-density computation: with fast startup and teardown times to handle high client request rates. An extensive evaluation of Sledge with varying workloads and real-world serverless applications demonstrates the effectiveness of the designed serverless-first runtime for the Edge. Sledge supports up to 4 times higher throughput and 4 times lower latencies compared to Nuclio, one of the fastest open-source serverless frameworks.},
  isbn = {978-1-4503-8153-6},
  keywords = {Edge computing,IoT,serverless,WebAssembly},
  annotation = {16 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9WPXGM27\\Gadepalli et al. - 2020 - Sledge a Serverless-first, Light-weight Wasm Runt.pdf}
}

@book{garfinkel1994unixhaters,
  title = {The {{UNIX-haters}} Handbook},
  editor = {Garfinkel, Simson and Weise, Daniel and Strassmann, Steven},
  year = {1994},
  publisher = {{IDG Books}},
  address = {{San Mateo, CA}},
  isbn = {978-1-56884-203-5},
  langid = {english},
  lccn = {QA76.76.O63 U54518 1994},
  keywords = {Operating systems (Computers),UNIX (Computer file)},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8BQXI4Q9\\Garfinkel et al. - 1994 - The UNIX-haters handbook.pdf}
}

@inproceedings{ge2016finegrained,
  title = {Fine-{{Grained Control-Flow Integrity}} for {{Kernel Software}}},
  booktitle = {2016 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Ge, Xinyang and Talele, Nirupama and Payer, Mathias and Jaeger, Trent},
  year = {2016},
  month = mar,
  pages = {179--194},
  doi = {10.1109/EuroSP.2016.24},
  abstract = {Modern systems assume that privileged software always behaves as expected, however, such assumptions may not hold given the prevalence of kernel vulnerabilities. One idea is to employ defenses to restrict how adversaries may exploit such vulnerabilities, such as Control-Flow Integrity (CFI), which restricts execution to a Control-Flow Graph (CFG). However, proposed applications of CFI enforcement to kernel software are too coarse-grained to restrict the adversary effectively and either fail to enforce CFI comprehensively or are very expensive. We present a mostly-automated approach for retrofitting kernel software that leverages features of such software to enable comprehensive, efficient, fine-grained CFI enforcement. We achieve this goal by leveraging two insights. We first leverage the conservative function pointer usage patterns found in the kernel source code to develop a method to compute fine-grained CFGs for kernel software. Second, we identify two opportunities for removing CFI instrumentation relative to prior optimization techniques: reusing existing kernel instrumentation and creating direct transfers, where possible. Using these insights, we show how to choose optimized defenses for kernels to handle system events, enabling comprehensive and efficient CFI enforcement. We evaluate the effectiveness of the proposed fine-grained CFI instrumentation by applying the retrofitting approach comprehensively to FreeBSD, the MINIX microkernel system, and MINIX's user-space servers, and applying this approach partly to the BitVisor hypervisor. We show that our approach eliminates over 70\% of the indirect targets relative to the best current, fine-grained CFI techniques, while our optimizations reduce the instrumentation necessary to enforce coarse-grained CFI. The performance improvement due to our optimizations ranges from 51\%/25\% for MINIX to 12\%/17\% for FreeBSD for the average/maximum microbenchmark overhead. The evaluation shows that fine-grained CFI instrumentation can be computed for kernel software in practice and can be enforced more efficiently than coarse-grained CFI instrumentation.},
  keywords = {cfi,euros\&p,fine-grained cfi,Instruments,Kernel,Law,Optimization,Servers},
  annotation = {78 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\B3CL7M43\\Ge et al. - 2016 - Fine-Grained Control-Flow Integrity for Kernel Sof.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\CTP24RIC\\7467354.html}
}

@inproceedings{gershuni2019simple,
  title = {Simple and Precise Static Analysis of Untrusted {{Linux}} Kernel Extensions},
  booktitle = {Proceedings of the 40th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Gershuni, Elazar and Amit, Nadav and Gurfinkel, Arie and Narodytska, Nina and Navas, Jorge A. and Rinetzky, Noam and Ryzhyk, Leonid and Sagiv, Mooly},
  year = {2019},
  month = jun,
  series = {{{PLDI}} 2019},
  pages = {1069--1084},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3314221.3314590},
  abstract = {Extended Berkeley Packet Filter (eBPF) is a Linux subsystem that allows safely executing untrusted user-defined extensions inside the kernel. It relies on static analysis to protect the kernel against buggy and malicious extensions. As the eBPF ecosystem evolves to support more complex and diverse extensions, the limitations of its current verifier, including high rate of false positives, poor scalability, and lack of support for loops, have become a major barrier for developers. We design a static analyzer for eBPF within the framework of abstract interpretation. Our choice of abstraction is based on common patterns found in many eBPF programs. We observed that eBPF programs manipulate memory in a rather disciplined way which permits analyzing them successfully with a scalable mixture of very-precise abstraction of certain bounded regions with coarser abstractions of other parts of the memory. We use the Zone domain, a simple domain that tracks differences between pairs of registers and offsets, to achieve precise and scalable analysis. We demonstrate that this abstraction is as precise in practice as more costly abstract domains like Octagon and Polyhedra. Furthermore, our evaluation, based on hundreds of real-world eBPF programs, shows that the new tool generates no more false alarms than the existing Linux verifier, while it supports a wider class of programs (including programs with loops) and has better asymptotic complexity.},
  isbn = {978-1-4503-6712-7},
  keywords = {ebpf,kernel extensions,linux,static analysis},
  annotation = {31 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\C9GJD8KM\\Gershuni et al. - 2019 - Simple and precise static analysis of untrusted Li.pdf}
}

@inproceedings{ghavamnia2020confine,
  title = {Confine: {{Automated System Call Policy Generation}} for {{Container Attack Surface Reduction}}},
  shorttitle = {Confine},
  booktitle = {23rd {{International Symposium}} on {{Research}} in {{Attacks}}, {{Intrusions}} and {{Defenses}} ({{RAID}} 2020)},
  author = {Ghavamnia, Seyedhamed and Palit, Tapti and Benameur, Azzedine and Polychronakis, Michalis},
  year = {2020},
  pages = {443--458},
  isbn = {978-1-939133-18-2},
  langid = {english},
  keywords = {Debloating},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ACB3YV4E\\Ghavamnia et al. - 2020 - Confine Automated System Call Policy Generation f.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\MJLCJV86\\ghavanmnia.html}
}

@inproceedings{ghavamnia2020temporal,
  title = {Temporal {{System Call Specialization}} for {{Attack Surface Reduction}}},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Ghavamnia, Seyedhamed and Palit, Tapti and Mishra, Shachee and Polychronakis, Michalis},
  year = {2020},
  pages = {1749--1766},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\Q7JYZMBP\\Ghavamnia et al. - 2020 - Temporal System Call Specialization for Attack Sur.pdf}
}

@inproceedings{ghosn2021enclosure,
  title = {Enclosure: Language-Based Restriction of Untrusted Libraries},
  shorttitle = {Enclosure},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Ghosn, Adrien and Kogias, Marios and Payer, Mathias and Larus, James R. and Bugnion, Edouard},
  year = {2021},
  month = apr,
  series = {{{ASPLOS}} '21},
  pages = {255--267},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3445814.3446728},
  abstract = {Programming languages and systems have failed to address the security implications of the increasingly frequent use of public libraries to construct modern software. Most languages provide tools and online repositories to publish, import, and use libraries; however, this double-edged sword can incorporate a large quantity of unknown, unchecked, and unverified code into an application. The risk is real, as demonstrated by malevolent actors who have repeatedly inserted malware into popular open-source libraries. This paper proposes a solution: enclosures, a new programming language construct for library isolation that provides a developer with fine-grain control over the resources that a library can access, even for libraries with complex inter-library dependencies. The programming abstraction is language-independent and could be added to most languages. These languages would then be able to take advantage of hardware isolation mechanisms that are effective across language boundaries. The enclosure policies are enforced at run time by LitterBox, a language-independent framework that uses hardware mechanisms to provide uniform and robust isolation guarantees, even for libraries written in unsafe languages. LitterBox currently supports both Intel VT-x (with general-purpose extended page tables) and the emerging Intel Memory Protection Keys (MPK). We describe an enclosure implementation for the Go and Pythonlanguages. Our evaluation demonstrates that the Go implementation can protect sensitive data in real-world applications constructed using complex untrusted libraries with deep dependencies. It requires minimal code refactoring and incurs acceptable performance overhead. The Python implementation demonstrates LitterBox's ability to support dynamic languages.},
  isbn = {978-1-4503-8317-2},
  keywords = {intra-address space isolation,programming languages,Security,software packages},
  annotation = {8 citations (Semantic Scholar/DOI) [2022-10-28]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9EPC5XEQ\\Ghosn et al. - 2021 - Enclosure language-based restriction of untrusted.pdf}
}

@inproceedings{gil2018there,
  title = {There's a {{Hole}} in the {{Bottom}} of the {{C}}: {{On}} the {{Effectiveness}} of {{Allocation Protection}}},
  shorttitle = {There's a {{Hole}} in the {{Bottom}} of the {{C}}},
  booktitle = {2018 {{IEEE Cybersecurity Development}} ({{SecDev}})},
  author = {Gil, Ronald and Okhravi, Hamed and Shrobe, Howard},
  year = {2018},
  month = sep,
  pages = {102--109},
  doi = {10.1109/SecDev.2018.00021},
  abstract = {Memory corruption attacks have been a major vector of compromised computer systems for decades. Memory safety techniques proposed in the literature provide spatial and temporal safety properties to prevent such attacks. Since enforcing full memory safety on legacy languages such as C/C++ often incurs large runtime overhead, recent techniques have created a trade-off between the granularity of enforcement and overhead. By enforcing safety properties at the granularity of allocations instead of objects, these technique incur only a fraction of the overhead. Of particular note, are the recent software-based, so-called "low-fat" schemes, that encode a pointer's bound information in the pointer value itself, thus avoiding a separate metadata store, and additional lookup overhead. In this paper, we show that trading granularity with overhead is insecure. Specifically, we illustrate a new type of attack, which we call Pointer Stretching, that can bypass the recently proposed low-fat schemes using intra-object spatial corruption. Because of the limitations imposed by the low-fat schemes we devise some tricks that allows us to chain ROP gadgets together before a successful stack pivot. We illustrate a real-world exploit against Nginx that successfully hijacks control even when both stack and heap are protected with the software-based low-fat schemes. Furthermore, we show that the vulnerability is inherent in the design of such techniques, and not easily fixable without significant additional implementation and overhead. In addition, we develop an analysis tool to find such vulnerabilities and analyze many popular applications and servers. We find that the exploitable conditions are abundantly found in real-world code bases. Our findings strongly suggest that effective memory defenses must operate at the granularity of objects (and sub-objects) for them to provide meaningful protection against memory corruption attacks.},
  keywords = {Allocation Protection,Bounds checking,Buffer Overflows,Hardware,Memory corruption,Metadata,Resource management,Return Oriented Programming,Runtime,Safety,Software,Spatial Memory Safety,Tools},
  annotation = {12 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LYHDF2Y4\\Gil et al. - 2018 - There's a Hole in the Bottom of the C On the Effe.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\IBRUPVCF\\8543393.html}
}

@inproceedings{goktas2014out,
  title = {Out of {{Control}}: {{Overcoming Control-Flow Integrity}}},
  shorttitle = {Out of {{Control}}},
  booktitle = {2014 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {G{\"o}ktas, Enes and Athanasopoulos, Elias and Bos, Herbert and Portokalidis, Georgios},
  year = {2014},
  month = may,
  pages = {575--589},
  issn = {2375-1207},
  doi = {10.1109/SP.2014.43},
  abstract = {As existing defenses like ASLR, DEP, and stack cookies are not sufficient to stop determined attackers from exploiting our software, interest in Control Flow Integrity (CFI) is growing. In its ideal form, CFI prevents flows of control that were not intended by the original program, effectively putting a stop to exploitation based on return oriented programming (and many other attacks besides). Two main problems have prevented CFI from being deployed in practice. First, many CFI implementations require source code or debug information that is typically not available for commercial software. Second, in its ideal form, the technique is very expensive. It is for this reason that current research efforts focus on making CFI fast and practical. Specifically, much of the work on practical CFI is applicable to binaries, and improves performance by enforcing a looser notion of control flow integrity. In this paper, we examine the security implications of such looser notions of CFI: are they still able to prevent code reuse attacks, and if not, how hard is it to bypass its protection? Specifically, we show that with two new types of gadgets, return oriented programming is still possible. We assess the availability of our gadget sets, and demonstrate the practicality of these results with a practical exploit against Internet Explorer that bypasses modern CFI implementations.},
  keywords = {code-reuse attack,Control-flow integrity evaluation,Electronic mail,Integrated circuits,Internet,Payloads,Programming,Security,Software},
  annotation = {379 citations (Semantic Scholar/DOI) [2022-10-26]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\I2SXDM8Z\\GÃ¶ktas et al. - 2014 - Out of Control Overcoming Control-Flow Integrity.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\LPRKGV4L\\6956588.html}
}

@inproceedings{gomez-luna2021benchmarking,
  title = {Benchmarking {{Memory-Centric Computing Systems}}: {{Analysis}} of {{Real Processing-In-Memory Hardware}}},
  shorttitle = {Benchmarking {{Memory-Centric Computing Systems}}},
  booktitle = {2021 12th {{International Green}} and {{Sustainable Computing Conference}} ({{IGSC}})},
  author = {{G{\'o}mez-Luna}, Juan and El Hajj, Izzat and Fernandez, Ivan and Giannoula, Christina and Oliveira, Geraldo F. and Mutlu, Onur},
  year = {2021},
  month = oct,
  pages = {1--7},
  doi = {10.1109/IGSC54211.2021.9651614},
  abstract = {Many modern workloads such as neural network inference and graph processing are fundamentally memory-bound. For such workloads, data movement between memory and CPU cores imposes a significant overhead in terms of both latency and energy. A major reason is that this communication happens through a narrow bus with high latency and limited bandwidth, and the low data reuse in memory-bound workloads is insufficient to amortize the cost of memory access. Fundamentally addressing this data movement bottleneck requires a paradigm where the memory system assumes an active role in computing by integrating processing capabilities. This paradigm is known as processing-in-memory (PIM). Recent research explores different forms of PIM architectures, motivated by the emergence of new technologies that integrate memory with a logic layer, where processing elements can be easily placed. Past works evaluate these architectures in simulation or, at best, with simplified hardware prototypes. In contrast, the UPMEM company has designed and manufactured the first publicly-available real-world PIM architecture. The UPMEM PIM architecture combines traditional DRAM memory arrays with general-purpose in-order cores, called DRAM Processing Units (DPUs), integrated in the same chip. This paper presents key takeaways from the first comprehensive analysis [1] of the first publicly-available real-world PIM architecture. First, we introduce our experimental characterization of the UPMEM PIM architecture using microbenchmarks, and present PrIM (Processing-In-Memory benchmarks), a benchmark suite of 16 workloads from different application domains (e.g., dense/sparse linear algebra, databases, data analytics, graph processing, neural networks, bioinformatics, image processing), which we identify as memory-bound. Second, we provide four key takeaways about the UPMEM PIM architecture, which stem from our study of the performance and scaling characteristics of PrIM benchmarks on the UPMEM PIM architecture, and their performance and energy consumption comparison to their state-of-the-art CPU and GPU counterparts. More insights about suitability of different workloads to the PIM system, programming recommendations for software designers, and suggestions and hints for hardware and architecture designers of future PIM systems are available in [1].},
  keywords = {Benchmark testing,benchmarking,Computer architecture,data movement bottleneck,DRAM,Hardware,Memory management,memory systems,near-data processing,Neural networks,processing-in-memory,Programming,Prototypes,real-system characterization,upmem,workload characterization},
  annotation = {16 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JQEXRB5R\\GÃ³mez-Luna et al. - 2021 - Benchmarking Memory-Centric Computing Systems Ana.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\XGR5UXA6\\9651614.html}
}

@misc{gomez-luna2022benchmarking,
  title = {Benchmarking a {{New Paradigm}}: {{An Experimental Analysis}} of a {{Real Processing-in-Memory Architecture}}},
  shorttitle = {Benchmarking a {{New Paradigm}}},
  author = {{G{\'o}mez-Luna}, Juan and Hajj, Izzat El and Fernandez, Ivan and Giannoula, Christina and Oliveira, Geraldo F. and Mutlu, Onur},
  year = {2022},
  month = may,
  number = {arXiv:2105.03814},
  eprint = {2105.03814},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  abstract = {Many modern workloads, such as neural networks, databases, and graph processing, are fundamentally memory-bound. For such workloads, the data movement between main memory and CPU cores imposes a significant overhead in terms of both latency and energy. A major reason is that this communication happens through a narrow bus with high latency and limited bandwidth, and the low data reuse in memory-bound workloads is insufficient to amortize the cost of main memory access. Fundamentally addressing this data movement bottleneck requires a paradigm where the memory system assumes an active role in computing by integrating processing capabilities. This paradigm is known as processing-in-memory (PIM ). Recent research explores different forms of PIM architectures, motivated by the emergence of new 3D-stacked memory technologies that integrate memory with a logic layer where processing elements can be easily placed. Past works evaluate these architectures in simulation or, at best, with simplified hardware prototypes. In contrast, the UPMEM company has designed and manufactured the first publicly-available real-world PIM architecture. The UPMEM PIM architecture combines traditional DRAM memory arrays with general-purpose in-order cores, called DRAM Processing Units (DPUs), integrated in the same chip.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Distributed; Parallel; and Cluster Computing,Computer Science - Hardware Architecture,Computer Science - Performance},
  annotation = {24 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5R69EYJ4\\GÃ³mez-Luna et al. - 2022 - Benchmarking a New Paradigm An Experimental Analy.pdf}
}

@inproceedings{grubbs2020pancake,
  title = {Pancake: {{Frequency Smoothing}} for {{Encrypted Data Stores}}},
  shorttitle = {Pancake},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Grubbs, Paul and Khandelwal, Anurag and Lacharit{\'e}, Marie-Sarah and Brown, Lloyd and Li, Lucy and Agarwal, Rachit and Ristenpart, Thomas},
  year = {2020},
  pages = {2451--2468},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RBG2D6MC\\Grubbs et al. - 2020 - Pancake Frequency Smoothing for Encrypted Data St.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7XGTMJMA\\grubbs.html}
}

@inproceedings{gruss2015cache,
  title = {Cache {{Template Attacks}}: {{Automating Attacks}} on {{Inclusive}} \{\vphantom\}{{Last-Level}}\vphantom\{\} {{Caches}}},
  shorttitle = {Cache {{Template Attacks}}},
  booktitle = {24th {{USENIX Security Symposium}} ({{USENIX Security}} 15)},
  author = {Gruss, Daniel and Spreitzer, Raphael and Mangard, Stefan},
  year = {2015},
  pages = {897--912},
  isbn = {978-1-939133-11-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3XJEURMC\\Gruss et al. - 2015 - Cache Template Attacks Automating Attacks on Incl.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\E4R4FIRV\\gruss.html}
}

@inproceedings{gu2020harmonizing,
  title = {Harmonizing {{Performance}} and {{Isolation}} in {{Microkernels}} with {{Efficient Intra-kernel Isolation}} and {{Communication}}},
  booktitle = {2020 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 20)},
  author = {Gu, Jinyu and Wu, Xinyue and Li, Wentai and Liu, Nian and Mi, Zeyu and Xia, Yubin and Chen, Haibo},
  year = {2020},
  pages = {401--417},
  isbn = {978-1-939133-14-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5KUIBR6W\\Gu et al. - 2020 - Harmonizing Performance and Isolation in Microkern.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\QC23PHAW\\gu.html}
}

@inproceedings{gudka2015clean,
  title = {Clean {{Application Compartmentalization}} with {{SOAAP}}},
  booktitle = {Proceedings of the 22nd {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Gudka, Khilan and Watson, Robert N.M. and Anderson, Jonathan and Chisnall, David and Davis, Brooks and Laurie, Ben and Marinos, Ilias and Neumann, Peter G. and Richardson, Alex},
  year = {2015},
  month = oct,
  series = {{{CCS}} '15},
  pages = {1016--1031},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2810103.2813611},
  abstract = {Application compartmentalization, a vulnerability mitigation technique employed in programs such as OpenSSH and the Chromium web browser, decomposes software into isolated components to limit privileges leaked or otherwise available to attackers. However, compartmentalizing applications -- and maintaining that compartmentalization -- is hindered by ad hoc methodologies and significantly increased programming effort. In practice, programmers stumble through (rather than overtly reason about) compartmentalization spaces of possible decompositions, unknowingly trading off correctness, security, complexity, and performance. We present a new conceptual framework embodied in an LLVM-based tool: the Security-Oriented Analysis of Application Programs (SOAAP) that allows programmers to reason about compartmentalization using source-code annotations (compartmentalization hypotheses). We demonstrate considerable benefit when creating new compartmentalizations for complex applications, and analyze existing compartmentalized applications to discover design faults and maintenance issues arising from application evolution.},
  isbn = {978-1-4503-3832-5},
  keywords = {compartmentalization,security,vulnerability mitigation},
  annotation = {59 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6H7PG2T3\\Gudka et al. - 2015 - Clean Application Compartmentalization with SOAAP.pdf}
}

@inproceedings{guo2022adversarial,
  title = {Adversarial {{Prefetch}}: {{New Cross-Core Cache Side Channel Attacks}}},
  shorttitle = {Adversarial {{Prefetch}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Guo, Yanan and Zigerelli, Andrew and Zhang, Youtao and Yang, Jun},
  year = {2022},
  month = apr,
  pages = {1550--1550},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00121},
  abstract = {Modern x86 processors have many prefetch instructions that can be used by programmers to boost performance. However, these instructions may also cause security problems. In particular, we found that on Intel processors, there are two security flaws in the implementation of PREFETCHW, an instruction for accelerating future writes. First, this instruction can execute on data with read-only permission. Second, the execution time of this instruction leaks the current coherence state of the target data. Based on these two design issues, we build two cross-core private cache attacks that work with both inclusive and non-inclusive LLCs, named Prefetch+Reload and Prefetch+Prefetch. We demonstrate the significance of our attacks in different scenarios. First, in the covert channel case, Prefetch+Reload and Prefetch+Prefetch achieve 782 KB/s and 822 KB/s channel capacities, when using only one shared cache line between the sender and receiver, the largest-to-date single-line capacities for CPU cache covert channels. Further, in the side channel case, our attacks can monitor the access pattern of the victim on the same processor, with almost zero error rate. We show that they can be used to leak private information of real-world applications such as cryptographic keys. Finally, our attacks can be used in transient execution attacks in order to leak more secrets within the transient window than prior work. From the experimental results, our attacks allow leaking about 2 times as many secret bytes, compared to Flush+Reload, which is widely used in transient execution attacks.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TLBHLW6P\\1CIO7X1LGi4.html}
}

@article{haasbringing,
  title = {Bringing the {{Web}} up to {{Speed}} with {{WebAssembly}}},
  author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L and Titzer, Ben L and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
  pages = {16},
  abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only builtin language of the Web is not well-equipped to meet these requirements, especially as a compilation target.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5EAZ2V9A\\Haas et al. - Bringing the Web up to Speed with WebAssembly.pdf}
}

@inproceedings{hardin2018application,
  title = {Application {{Memory Isolation}} on {{Ultra-Low-Power MCUs}}},
  booktitle = {2018 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 18)},
  author = {Hardin, Taylor and Scott, Ryan and Proctor, Patrick and Hester, Josiah and Sorber, Jacob and Kotz, David},
  year = {2018},
  pages = {127--132},
  isbn = {978-1-939133-01-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4WDRTSV2\\Hardin et al. - 2018 - Application Memory Isolation on Ultra-Low-Power .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\L9DHIKZT\\hardin.html}
}

@article{hasan2022decap,
  title = {Decap: {{Deprivileging Programs}} by {{Reducing Their Capabilities}}},
  author = {Hasan, Mehedi},
  year = {2022},
  pages = {14},
  abstract = {Linux enables non-root users to perform certain privileged operations through the use of the setuid (``set user ID'') mechanism. This represents a glaring violation of the principle of least privilege, as setuid programs run with full superuser privileges\textemdash with disastrous outcomes when vulnerabilities are found in them. Linux capabilities aim to improve this situation by splitting superuser privileges into distinct units that can be assigned individually. Despite the clear benefits of capabilities in reducing the risk of privilege escalation, their actual use is scarce, and setuid programs are still prevalent in modern Linux distributions. The lack of a systematic way for developers to identify the capabilities needed by a given program is a contributing factor that hinders their applicability.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\HX566C7K\\Hasan - 2022 - Decap Deprivileging Programs by Reducing Their Ca.pdf}
}

@inproceedings{he2022freewilla,
  title = {{{FreeWill}}: {{Automatically Diagnosing Use-after-free Bugs}} via {{Reference Miscounting Detection}} on {{Binaries}}},
  shorttitle = {\{\vphantom\}{{FreeWill}}\vphantom\{\}},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {He, Liang},
  year = {2022},
  langid = {english},
  keywords = {uaf},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\AYI7RPL6\\2022 - FreeWill Automatically Diagnosing Use-after-fre.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\EGDKXMPI\\He et al. - 2022 - FreeWill Automatically Diagnosing Use-after-fre.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\SPMFZ4UB\\he-liang.html}
}

@inproceedings{hedayati2019hodor,
  title = {Hodor: {{Intra-Process Isolation}} for {{High-Throughput Data Plane Libraries}}},
  shorttitle = {Hodor},
  booktitle = {2019 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 19)},
  author = {Hedayati, Mohammad and Gravani, Spyridoula and Johnson, Ethan and Criswell, John and Scott, Michael L. and Shen, Kai and Marty, Mike},
  year = {2019},
  pages = {489--504},
  isbn = {978-1-939133-03-8},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8KATVCDF\\Hedayati et al. - 2019 - Hodor Intra-Process Isolation for High-Through.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\PHA9XQSC\\hedayati-hodor.html}
}

@article{hedayatihodor,
  title = {Hodor: {{Intra-Process Isolation}} for {{High-Throughput Data Plane Libraries}}},
  author = {Hedayati, Mohammad and Criswell, John and Gravani, Spyridoula and Scott, Michael L and Johnson, Ethan and Shen, Kai and Marty, Mike},
  pages = {16},
  abstract = {As network, I/O, accelerator, and NVM devices capable of a million operations per second make their way into data centers, the software stack managing such devices has been shifting from implementations within the operating system kernel to more specialized kernel-bypass approaches. While the in-kernel approach guarantees safety and provides resource multiplexing, it imposes too much overhead on microsecondscale tasks. Kernel-bypass approaches improve throughput substantially but sacrifice safety and complicate resource management: if applications are mutually distrusting, then either each application must have exclusive access to its own device or else the device itself must implement resource management. This paper shows how to attain both safety and performance via intra-process isolation for data plane libraries. We propose protected libraries as a new OS abstraction which provides separate user-level protection domains for different services (e.g., network and in-memory database), with performance approaching that of unprotected kernel bypass. We also show how this new feature can be utilized to enable sharing of data plane libraries across distrusting applications. Our proposed solution uses Intel's memory protection keys (PKU) in a safe way to change the permissions associated with subsets of a single address space. In addition, it uses hardware watchpoints to delay asynchronous event delivery and to guarantee independent failure of applications sharing a protected library. We show that our approach can efficiently protect highthroughput in-memory databases and user-space network stacks. Our implementation allows up to 2.3 million library entrances per second per core, outperforming both kernellevel protection and two alternative implementations that use system calls and Intel's VMFUNC switching of user-level address spaces, respectively.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\EJHRRH72\\Hedayati et al. - Hodor Intra-Process Isolation for High-Throughput.pdf}
}

@inproceedings{hester2016amulet,
  title = {Amulet: {{An Energy-Efficient}}, {{Multi-Application Wearable Platform}}},
  shorttitle = {Amulet},
  booktitle = {Proceedings of the 14th {{ACM Conference}} on {{Embedded Network Sensor Systems CD-ROM}}},
  author = {Hester, Josiah and Peters, Travis and Yun, Tianlong and Peterson, Ronald and Skinner, Joseph and Golla, Bhargav and Storer, Kevin and Hearndon, Steven and Freeman, Kevin and Lord, Sarah and Halter, Ryan and Kotz, David and Sorber, Jacob},
  year = {2016},
  month = nov,
  series = {{{SenSys}} '16},
  pages = {216--229},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2994551.2994554},
  abstract = {Wearable technology enables a range of exciting new applications in health, commerce, and beyond. For many important applications, wearables must have battery life measured in weeks or months, not hours and days as in most current devices. Our vision of wearable platforms aims for long battery life but with the flexibility and security to support multiple applications. To achieve long battery life with a workload comprising apps from multiple developers, these platforms must have robust mechanisms for app isolation and developer tools for optimizing resource usage. We introduce the Amulet Platform for constrained wearable devices, which includes an ultra-low-power hardware architecture and a companion software framework, including a highly efficient event-driven programming model, low-power operating system, and developer tools for profiling ultra-low-power applications at compile time. We present the design and evaluation of our prototype Amulet hardware and software, and show how the framework enables developers to write energy-efficient applications. Our prototype has battery lifetime lasting weeks or even months, depending on the application, and our interactive resource-profiling tool predicts battery lifetime within 6-10\% of the measured lifetime.},
  isbn = {978-1-4503-4263-6},
  keywords = {Energy,Low power,Mobile health,Wearables},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4U4RBXP4\\Hester et al. - 2016 - Amulet An Energy-Efficient, Multi-Application Wea.pdf}
}

@inproceedings{hof2022blackbox,
  title = {{{BlackBox}}: {{A Container Security Monitor}} for {{Protecting Containers}} on {{Untrusted Operating Systems}}},
  shorttitle = {\{\vphantom\}{{BlackBox}}\vphantom\{\}},
  booktitle = {16th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 22)},
  author = {Hof, Alexander Van't and Nieh, Jason},
  year = {2022},
  pages = {683--700},
  isbn = {978-1-939133-28-1},
  langid = {english},
  keywords = {container},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2II4T4LL\\Hof and Nieh - 2022 - BlackBox A Container Security Monitor for Prote.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\RTVKGGBS\\vant-hof.html}
}

@misc{hohentanner2022pacsafe,
  title = {{{PACSafe}}: {{Leveraging ARM Pointer Authentication}} for {{Memory Safety}} in {{C}}/{{C}}++},
  shorttitle = {{{PACSafe}}},
  author = {Hohentanner, Konrad and Zieris, Philipp and Horsch, Julian},
  year = {2022},
  month = feb,
  number = {arXiv:2202.08669},
  eprint = {2202.08669},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2202.08669},
  abstract = {Memory safety bugs remain in the top ranks of security vulnerabilities, even after decades of research on their detection and prevention. Various mitigations have been proposed for C/C++, ranging from language dialects to instrumentation. Among these, compiler-based instrumentation is particularly promising, not requiring manual code modifications and being able to achieve precise memory safety. Unfortunately, existing compiler-based solutions compromise in many areas, including performance but also usability and memory safety guarantees. New developments in hardware can help improve performance and security of compiler-based memory safety. ARM Pointer Authentication, added in the ARMv8.3 architecture, is intended to enable hardware-assisted Control Flow Integrity. But since its operations are relatively generic, it also enables other, more comprehensive hardware-supported runtime integrity approaches. As such, we propose PACSafe, a memory safety approach based on ARM Pointer Authentication. PACSafe uses pointer signatures to retrofit full memory safety to C/C++ programs, protecting heap, stack, and globals against temporal and spatial vulnerabilities. We present a full, LLVM-based prototype implementation, running on an M1 MacBook Pro, i.e., on actual ARMv8.3 hardware. Our prototype evaluation shows that the system outperforms similar approaches under real-world conditions. This, together with its compatibility with uninstrumented libraries and cryptographic protection against attacks on metadata, makes PACSafe a viable solution for retrofitting memory safety to C/C++ programs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Programming Languages,Computer Science - Software Engineering,pac,pointer authentication},
  annotation = {0 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UGU6MP29\\Hohentanner et al. - 2022 - PACSafe Leveraging ARM Pointer Authentication for.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\5TLCDA86\\2202.html}
}

@inproceedings{hong2020saver,
  title = {{{SAVER}}: Scalable, Precise, and Safe Memory-Error Repair},
  shorttitle = {{{SAVER}}},
  booktitle = {Proceedings of the {{ACM}}/{{IEEE}} 42nd {{International Conference}} on {{Software Engineering}}},
  author = {Hong, Seongjoon and Lee, Junhee and Lee, Jeongsoo and Oh, Hakjoo},
  year = {2020},
  month = jun,
  pages = {271--283},
  publisher = {{ACM}},
  address = {{Seoul South Korea}},
  doi = {10.1145/3377811.3380323},
  abstract = {We present SAVER, a new memory-error repair technique for C programs. Memory errors such as memory leak, double-free, and use-after-free are highly prevalent and fixing them requires significant effort. Automated program repair techniques hold the promise of reducing this burden but the state-of-the-art is still unsatisfactory. In particular, no existing techniques are able to fix those errors in a scalable, precise, and safe way, all of which are required for a truly practical tool. SAVER aims to address these shortcomings. To this end, we propose a method based on a novel representation of the program called object flow graph, which summarizes the program's heap-related behavior using static analysis. We show that fixing memory errors can be formulated as a graph labeling problem over object flow graph and present an efficient algorithm. We evaluated SAVER in combination with Infer, an industrial-strength static bug-finder, and show that 74\% of the reported errors can be fixed automatically for a range of open-source C programs.},
  isbn = {978-1-4503-7121-6},
  langid = {english},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IPQXR48S\\Hong et al. - 2020 - SAVER scalable, precise, and safe memory-error re.pdf}
}

@inproceedings{hsu2016enforcing,
  title = {Enforcing {{Least Privilege Memory Views}} for {{Multithreaded Applications}}},
  booktitle = {Proceedings of the 2016 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Hsu, Terry Ching-Hsiang and Hoffman, Kevin and Eugster, Patrick and Payer, Mathias},
  year = {2016},
  month = oct,
  series = {{{CCS}} '16},
  pages = {393--405},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2976749.2978327},
  abstract = {Failing to properly isolate components in the same address space has resulted in a substantial amount of vulnerabilities. Enforcing the least privilege principle for memory accesses can selectively isolate software components to restrict attack surface and prevent unintended cross-component memory corruption. However, the boundaries and interactions between software components are hard to reason about and existing approaches have failed to stop attackers from exploiting vulnerabilities caused by poor isolation. We present the secure memory views (SMV) model: a practical and efficient model for secure and selective memory isolation in monolithic multithreaded applications. SMV is a third generation privilege separation technique that offers explicit access control of memory and allows concurrent threads within the same process to partially share or fully isolate their memory space in a controlled and parallel manner following application requirements. An evaluation of our prototype in the Linux kernel (TCB {$<$} 1,800 LOC) shows negligible runtime performance overhead in real-world applications including Cherokee web server ({$<$} 0.69\%), Apache httpd web server ({$<$} 0.93\%), and Mozilla Firefox web browser ({$<$} 1.89\%) with at most 12 LOC changes.},
  isbn = {978-1-4503-4139-4},
  keywords = {operating system security,privilege separation,threads isolation},
  annotation = {45 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\E4CVKHFN\\Hsu et al. - 2016 - Enforcing Least Privilege Memory Views for Multith.pdf}
}

@inproceedings{hu2016dataoriented,
  title = {Data-{{Oriented Programming}}: {{On}} the {{Expressiveness}} of {{Non-control Data Attacks}}},
  shorttitle = {Data-{{Oriented Programming}}},
  booktitle = {2016 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Hu, Hong and Shinde, Shweta and Adrian, Sendroiu and Chua, Zheng Leong and Saxena, Prateek and Liang, Zhenkai},
  year = {2016},
  month = may,
  pages = {969--986},
  issn = {2375-1207},
  doi = {10.1109/SP.2016.62},
  abstract = {As control-flow hijacking defenses gain adoption, it is important to understand the remaining capabilities of adversaries via memory exploits. Non-control data exploits are used to mount information leakage attacks or privilege escalation attacks program memory. Compared to control-flow hijacking attacks, such non-control data exploits have limited expressiveness, however, the question is: what is the real expressive power of non-control data attacks? In this paper we show that such attacks are Turing-complete. We present a systematic technique called data-oriented programming (DOP) to construct expressive non-control data exploits for arbitrary x86 programs. In the experimental evaluation using 9 programs, we identified 7518 data-oriented x86 gadgets and 5052 gadget dispatchers, which are the building blocks for DOP. 8 out of 9 real-world programs have gadgets to simulate arbitrary computations and 2 of them are confirmed to be able to build Turing-complete attacks. We build 3 end-to-end attacks to bypass randomization defenses without leaking addresses, to run a network bot which takes commands from the attacker, and to alter the memory permissions. All the attacks work in the presence of ASLR and DEP, demonstrating how the expressiveness offered by DOP significantly empowers the attacker.},
  keywords = {Browsers,Linux,Payloads,Programming,Security,Servers,Systematics},
  annotation = {257 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\675AJRBK\\Hu et al. - 2016 - Data-Oriented Programming On the Expressiveness o.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\BW86QZM8\\7546545.html}
}

@inproceedings{hu2018enforcinga,
  title = {Enforcing {{Unique Code Target Property}} for {{Control-Flow Integrity}}},
  booktitle = {Proceedings of the 2018 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Hu, Hong and Qian, Chenxiong and Yagemann, Carter and Chung, Simon Pak Ho and Harris, William R. and Kim, Taesoo and Lee, Wenke},
  year = {2018},
  month = oct,
  series = {{{CCS}} '18},
  pages = {1470--1486},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3243734.3243797},
  abstract = {The goal of control-flow integrity (CFI) is to stop control-hijacking attacks by ensuring that each indirect control-flow transfer (ICT) jumps to its legitimate target. However, existing implementations of CFI have fallen short of this goal because their approaches are inaccurate and as a result, the set of allowable targets for an ICT instruction is too large, making illegal jumps possible. In this paper, we propose the Unique Code Target (UCT) property for CFI. Namely, for each invocation of an ICT instruction, there should be one and only one valid target. We develop a prototype called uCFI to enforce this new property. During compilation, uCFI identifies the sensitive instructions that influence ICT and instruments the program to record necessary execution context. At runtime, uCFI monitors the program execution in a different process, and performs points-to analysis by interpreting sensitive instructions using the recorded execution context in a memory safe manner. It checks runtime ICT targets against the analysis results to detect CFI violations. We apply uCFI to SPEC benchmarks and 2 servers (nginx and vsftpd) to evaluate its efficacy of enforcing UCT and its overhead. We also test uCFI against control-hijacking attacks, including 5 real-world exploits, 1 proof of concept COOP attack, and 2 synthesized attacks that bypass existing defenses. The results show that uCFI strictly enforces the UCT property for protected programs, successfully detects all attacks, and introduces less than 10\% performance overhead.},
  isbn = {978-1-4503-5693-0},
  keywords = {control-flow integrity,Intel PT,performance,unique code target},
  annotation = {77 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\485634YJ\\Hu et al. - 2018 - Enforcing Unique Code Target Property for Control-.pdf}
}

@inproceedings{huang2021beacon,
  title = {{{BEACON}} : {{Directed Grey-Box Fuzzing}} with {{Provable Path Pruning}}},
  shorttitle = {{{BEACON}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Huang, Heqing and Guo, Yiyuan and Shi, Qingkai and Yao, Peisen and Wu, Rongxin and Zhang, Charles},
  year = {2021},
  month = sep,
  pages = {104--118},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00007},
  abstract = {Unlike coverage-based fuzzing that gives equal at- tention to every part of a code, directed fuzzing aims to direct a fuzzer to a specific target in the code, e.g., the code with potential vulnerabilities. Despite much progress, we observe that existing directed fuzzers are still not efficient as they often symbolically or concretely execute a lot of program paths that cannot reach the target code. They thus waste a lot of computational resources. This paper presents BEACON, which can effectively direct a gray-box fuzzer in the sea of paths in a provable manner. That is, assisted by a lightweight static analysis that computes abstracted preconditions for reaching the target, we can prune 82.94\% of the executing paths at runtime with negligible analysis overhead (\u{a}5h) but with the guarantee that the pruned paths must be spurious with respect to the target. We have implemented our approach, BEACON, and compared it to five state-of-the- art (directed) fuzzers in the application scenario of vulnerability reproduction. The evaluation results demonstrate that BEACON is 11.50x faster on average than existing directed gray-box fuzzers and it can also improve the speed of the conventional coverage-guided fuzzers, AFL, AFL++, and Mopt, to reproduce specific bugs with 6.31x ,11.86x and 10.92x speedup, respectively. More interestingly, when used to test the vulnerability patches, BEACON found 14 incomplete fixes of existing CVE-identified vulnerabilities and 8 new bugs while 10 of them are exploitable with new CVE ids assigned.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UVYCMEHE\\1wKCe5wtqM0.html}
}

@inproceedings{huang2022beacon,
  title = {{{BEACON}}: {{Directed Grey-Box Fuzzing}} with {{Provable Path Pruning}}},
  shorttitle = {{{BEACON}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Huang, Heqing and Guo, Yiyuan and Shi, Qingkai and Yao, Peisen and Wu, Rongxin and Zhang, Charles},
  year = {2022},
  month = may,
  pages = {36--50},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.9833751},
  abstract = {Unlike coverage-based fuzzing that gives equal attention to every part of a code, directed fuzzing aims to direct a fuzzer to a specific target in the code, e.g., the code with potential vulnerabilities. Despite much progress, we observe that existing directed fuzzers are still not efficient as they often symbolically or concretely execute a lot of program paths that cannot reach the target code. They thus waste a lot of computational resources. This paper presents BEACON, which can effectively direct a grey-box fuzzer in the sea of paths in a provable manner. That is, assisted by a lightweight static analysis that computes abstracted preconditions for reaching the target, we can prune 82.94\% of the executing paths at runtime with negligible analysis overhead ({$<$}5h) but with the guarantee that the pruned paths must be spurious with respect to the target. We have implemented our approach, BEACON, and compared it to five state-of-the-art (directed) fuzzers in the application scenario of vulnerability reproduction. The evaluation results demonstrate that BEACON is 11.50x faster on average than existing directed grey-box fuzzers and it can also improve the speed of the conventional coverage-guided fuzzers, AFL, AFL++, and Mopt, to reproduce specific bugs with 6.31x, 11.86x, and 10.92x speedup, respectively. More interestingly, when used to test the vulnerability patches, BEACON found 14 incomplete fixes of existing CVE-identified vulnerabilities and 8 new bugs while 10 of them are exploitable with new CVE ids assigned.},
  keywords = {Codes,Computer bugs,Costs,Directed fuzzing,Fuzzing,precondition inference,Privacy,program transformation,Runtime,Static analysis},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-29]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ABCMJ9AG\\Huang et al. - 2022 - BEACON Directed Grey-Box Fuzzing with Provable Pa.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7F2IYYR7\\9833751.html}
}

@inproceedings{huang2022ksplit,
  title = {{{KSplit}}: {{Automating Device Driver Isolation}}},
  shorttitle = {\{\vphantom\}{{KSplit}}\vphantom\{\}},
  booktitle = {16th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 22)},
  author = {Huang, Yongzhe and Narayanan, Vikram and Detweiler, David and Huang, Kaiming and Tan, Gang and Jaeger, Trent and Burtsev, Anton},
  year = {2022},
  pages = {613--631},
  isbn = {978-1-939133-28-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\K257MFH6\\Huang et al. - 2022 - KSplit Automating Device Driver Isolation.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\XI9B2PB3\\Huang et al. - KSplit Automating Device Driver Isolation.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\9DUJKYE3\\huang-yongzhe.html}
}

@inproceedings{huang2022taming,
  title = {The {{Taming}} of the {{Stack}}: {{Isolating Stack Data}} from {{Memory Errors}}},
  shorttitle = {The {{Taming}} of the {{Stack}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Huang, Kaiming and Huang, Yongzhe and Payer, Mathias and Qian, Zhiyun and Sampson, Jack and Tan, Gang and Jaeger, Trent},
  year = {2022},
  publisher = {{Internet Society}},
  address = {{San Diego, CA, USA}},
  doi = {10.14722/ndss.2022.23060},
  abstract = {Despite vast research on defenses to protect stack objects from the exploitation of memory errors, much stack data remains at risk. Historically, stack defenses focus on the protection of code pointers, such as return addresses, but emerging techniques to exploit memory errors motivate the need for practical solutions to protect stack data objects as well. However, recent approaches provide an incomplete view of security by not accounting for memory errors comprehensively and by limiting the set of objects that can be protected unnecessarily. In this paper, we present the DATAGUARD system that identifies which stack objects are safe statically from spatial, type, and temporal memory errors to protect those objects efficiently. DATAGUARD improves security through a more comprehensive and accurate safety analysis that proves a larger number of stack objects are safe from memory errors, while ensuring that no unsafe stack objects are mistakenly classified as safe. DATAGUARD's analysis of server programs and the SPEC CPU2006 benchmark suite shows that DATAGUARD improves security by: (1) ensuring that no memory safety violations are possible for any stack objects classified as safe, removing 6.3\% of the stack objects previously classified safe by the Safe Stack method, and (2) blocking exploit of all 118 stack vulnerabilities in the CGC Binaries. DATAGUARD extends the scope of stack protection by validating as safe over 70\% of the stack objects classified as unsafe by the Safe Stack method, leading to an average of 91.45\% of all stack objects that can only be referenced safely. By identifying more functions with only safe stack objects, DATAGUARD reduces the overhead of using Clang's Safe Stack defense for protection of the SPEC CPU2006 benchmarks from 11.3\% to 4.3\%. Thus, DATAGUARD shows that a comprehensive and accurate analysis can both increase the scope of stack data protection and reduce overheads.},
  isbn = {978-1-891562-74-7},
  langid = {english},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\AHYB33LH\\Huang et al. - 2022 - The Taming of the Stack Isolating Stack Data from.pdf}
}

@article{huangbeacon,
  title = {{{BEACON}} : {{Directed Grey-Box Fuzzing}} with {{Provable Path Pruning}}},
  author = {Huang, Heqing and Guo, Yiyuan and Shi, Qingkai and Yao, Peisen and Wu, Rongxin and Zhang, Charles},
  pages = {15},
  abstract = {Unlike coverage-based fuzzing that gives equal attention to every part of a code, directed fuzzing aims to direct a fuzzer to a specific target in the code, e.g., the code with potential vulnerabilities. Despite much progress, we observe that existing directed fuzzers are still not efficient as they often symbolically or concretely execute a lot of program paths that cannot reach the target code. They thus waste a lot of computational resources. This paper presents BEACON, which can effectively direct a greybox fuzzer in the sea of paths in a provable manner. That is, assisted by a lightweight static analysis that computes abstracted preconditions for reaching the target, we can prune 82.94\% of the executing paths at runtime with negligible analysis overhead (\u{a}5h) but with the guarantee that the pruned paths must be spurious with respect to the target. We have implemented our approach, BEACON, and compared it to five state-of-the-art (directed) fuzzers in the application scenario of vulnerability reproduction. The evaluation results demonstrate that BEACON is 11.50x faster on average than existing directed grey-box fuzzers and it can also improve the speed of the conventional coverage-guided fuzzers, AFL, AFL++, and Mopt, to reproduce specific bugs with 6.31x ,11.86x, and 10.92x speedup, respectively. More interestingly, when used to test the vulnerability patches, BEACON found 14 incomplete fixes of existing CVE-identified vulnerabilities and 8 new bugs while 10 of them are exploitable with new CVE ids assigned.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KKBE5H6X\\Huang et al. - BEACON  Directed Grey-Box Fuzzing with Provable P.pdf}
}

@inproceedings{ibnziad2021zero,
  title = {{{ZeR\O}}: {{Zero-Overhead Resilient Operation Under Pointer Integrity Attacks}}},
  shorttitle = {{{ZeR\O}}},
  booktitle = {2021 {{ACM}}/{{IEEE}} 48th {{Annual International Symposium}} on {{Computer Architecture}} ({{ISCA}})},
  author = {Ibn Ziad, Mohamed Tarek and Arroyo, Miguel A. and Manzhosov, Evgeny and Sethumadhavan, Simha},
  year = {2021},
  month = jun,
  pages = {999--1012},
  issn = {2575-713X},
  doi = {10.1109/ISCA52012.2021.00082},
  abstract = {A large class of today's systems require high levels of availability and security. Unfortunately, state-of-the-art security solutions tend to induce crashes and raise exceptions when under attack, trading off availability for security. In this work, we propose ZeR\O, a pointer integrity mechanism that can continue program execution even when under attack. ZeR\O{} proposes unique memory instructions and a novel metadata encoding scheme to protect code and data pointers. The combination of instructions and metadata allows ZeR\O{} to avoid explicitly tagging every word in memory, eliminating performance overheads. Moreover, ZeR\O{} is a deterministic security primitive that requires minor microarchitectural changes. We show that ZeR\O{} is better than commercially available state-of-the-art hardware primitives, e.g., ARM's Pointer Authentication (PAC), by a significant margin. ZeR\O{} incurs zero performance overheads on the SPEC CPU2017 benchmarks, and our VLSI measurements show low power and area overheads.},
  keywords = {Authentication,Caches,Code-Reuse Defenses,Exploit Mitigation,Hardware,Memory Safety,Metadata,Picture archiving and communication systems,Pointer Integrity,Runtime,Tagging,Very large scale integration},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2S6E9J7N\\Ibn Ziad et al. - 2021 - ZeRÃ˜ Zero-Overhead Resilient Operation Under Poin.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\USEC3B4C\\9499806.html}
}

@inproceedings{ismail2021vip,
  title = {{{VIP}}: {{Safeguard Value Invariant Property}} for {{Thwarting Critical Memory Corruption Attacks}}},
  shorttitle = {{{VIP}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Ismail, Mohannad and Yom, Jinwoo and Jelesnianski, Christopher and Jang, Yeongjin and Min, Changwoo},
  year = {2021},
  month = nov,
  pages = {1612--1626},
  publisher = {{ACM}},
  address = {{Virtual Event Republic of Korea}},
  doi = {10.1145/3460120.3485376},
  abstract = {Most modern software attacks are rooted in memory corruption vulnerabilities, which are capable of altering security-sensitive data (e.g., function pointers) to unintended values. This paper introduces a new security property, the Value Invariant Property (VIP), and HyperSpace, our prototype that enforces VIP on security-sensitive data. HyperSpace safeguards the integrity of ``data values'' instead of enforcing control/data flow, allowing for low runtime overhead, yet defeating critical attacks effectively. We implement four representative security policies including Control Flow Integrity (VIP-CFI), Code Pointer Integrity (VIP-CPI), Virtual function Table protection (VIP-VTPtr), and heap metadata protection based on HyperSpace. We evaluate HyperSpace with SPEC CPU2006 benchmarks and real-world applications (NGINX and PostgreSQL) and test how HyperSpace defeats memory corruption-based attacks, including three real-world exploits and six attacks that bypass existing defenses (COOP, heap exploits, etc.). Our experimental evaluation shows that HyperSpace successfully stops all these attacks with low runtime overhead: 0.88\% and 6.18\% average performance overhead for VIP-CFI and VIP-CPI, respectively, and overall approximately 13.18\% memory overhead with VIP-CPI in SPEC CPU2006.},
  isbn = {978-1-4503-8454-4},
  langid = {english},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JYR6DI4X\\Ismail et al. - 2021 - VIP Safeguard Value Invariant Property for Thwart.pdf}
}

@article{ismail2022tightly,
  title = {Tightly {{Seal Your Sensitive Pointers}} with {{PACTIGHT}}},
  author = {Ismail, Mohannad and Quach, Andrew and Jelesnianski, Christopher and Jang, Yeongjin and Min, Changwoo and Tech, Virginia},
  year = {2022},
  pages = {18},
  abstract = {ARM is becoming more popular in desktops and data centers, opening a new realm in terms of security attacks against ARM. ARM has released Pointer Authentication, a new hardware security feature that is intended to ensure pointer integrity with cryptographic primitives. In this paper, we utilize Pointer Authentication (PA) to build a novel scheme to completely prevent any misuse of security-sensitive pointers. We propose PACTIGHT to tightly seal these pointers. PACTIGHT utilizes a strong and unique modifier that addresses the current issues with the state-of-the-art PA defense mechanisms. We implement four defenses based on the PACTIGHT mechanism. Our security and performance evaluation results show that PACTIGHT defenses are more efficient and secure. Using real PA instructions, we evaluated PACTIGHT on 30 different applications, including NGINX web server, with an average performance overhead of 4.07\% even when enforcing our strongest defense. PACTIGHT demonstrates its effectiveness and efficiency with real PA instructions on real hardware.},
  langid = {english},
  keywords = {cfi,pac,pointer authentication},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\CTLPR6SV\\Ismail et al. - Tightly Seal Your Sensitive Pointers with PACTIGHT.pdf}
}

@article{jero2022tag,
  title = {{{TAG}}: {{Tagged Architecture Guide}}},
  shorttitle = {{{TAG}}},
  author = {Jero, Samuel and Burow, Nathan and Ward, Bryan and Skowyra, Richard and Khazan, Roger and Shrobe, Howard and Okhravi, Hamed},
  year = {2022},
  month = may,
  journal = {ACM Computing Surveys},
  pages = {3533704},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3533704},
  abstract = {Software security defenses are routinely broken by the persistence of both security researchers and attackers. Hardware solutions based on tagging are emerging as a promising technique that provides strong security guarantees (               e.g.,               memory safety) while incurring minimal runtime overheads and maintaining compatibility with existing codebases. Such schemes extend every word in memory with a tag and enforce security policies across them. This paper provides a survey of existing work on tagged architectures and describe the types of attacks such architectures aim to prevent as well as the guarantees they provide. It highlights the main distinguishing factors among tagged architectures and presents the diversity of designs and implementations that have been proposed. The survey reveals several real-world challenges have been neglected relating to both security and practical deployment. The challenges relate to the provisioning and enforcement phases of tagged architectures, and various overheads they incur. This work identifies these challenges as open research problems and provides suggestions for improving their security and practicality.},
  langid = {english},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\A7LSHXY4\\Jero et al. - 2022 - TAG Tagged Architecture Guide.pdf}
}

@inproceedings{jia2021boki,
  title = {Boki: {{Stateful Serverless Computing}} with {{Shared Logs}}},
  shorttitle = {Boki},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 28th {{Symposium}} on {{Operating Systems Principles}}},
  author = {Jia, Zhipeng and Witchel, Emmett},
  year = {2021},
  month = oct,
  series = {{{SOSP}} '21},
  pages = {691--707},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3477132.3483541},
  abstract = {Boki is a new serverless runtime that exports a shared log API to serverless functions. Boki shared logs enable stateful serverless applications to manage their state with durability, consistency, and fault tolerance. Boki shared logs achieve high throughput and low latency. The key enabler is the metalog, a novel mechanism that allows Boki to address ordering, consistency and fault tolerance independently. The metalog orders shared log records with high throughput and it provides read consistency while allowing service providers to optimize the write and read path of the shared log in different ways. To demonstrate the value of shared logs for stateful serverless applications, we build Boki support libraries that implement fault-tolerant workflows, durable object storage, and message queues. Our evaluation shows that shared logs can speed up important serverless workloads by up to 4.7x.},
  isbn = {978-1-4503-8709-5},
  keywords = {consistency,function-as-a-service,Serverless computing,shared log},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TJXUEJDG\\Jia and Witchel - 2021 - Boki Stateful Serverless Computing with Shared Lo.pdf}
}

@inproceedings{jia2021nightcore,
  title = {Nightcore: Efficient and Scalable Serverless Computing for Latency-Sensitive, Interactive Microservices},
  shorttitle = {Nightcore},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Jia, Zhipeng and Witchel, Emmett},
  year = {2021},
  month = apr,
  series = {{{ASPLOS}} 2021},
  pages = {152--166},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3445814.3446701},
  abstract = {The microservice architecture is a popular software engineering approach for building flexible, large-scale online services. Serverless functions, or function as a service (FaaS), provide a simple programming model of stateless functions which are a natural substrate for implementing the stateless RPC handlers of microservices, as an alternative to containerized RPC servers. However, current serverless platforms have millisecond-scale runtime overheads, making them unable to meet the strict sub-millisecond latency targets required by existing interactive microservices. We present Nightcore, a serverless function runtime with microsecond-scale overheads that provides container-based isolation between functions. Nightcore's design carefully considers various factors having microsecond-scale overheads, including scheduling of function requests, communication primitives, threading models for I/O, and concurrent function executions. Nightcore currently supports serverless functions written in C/C++, Go, Node.js, and Python. Our evaluation shows that when running latency-sensitive interactive microservices, Nightcore achieves 1.36\texttimes\textendash 2.93\texttimes{} higher throughput and up to 69\% reduction in tail latency.},
  isbn = {978-1-4503-8317-2},
  keywords = {Cloud computing,function-as-a-service,microservices,serverless computing},
  annotation = {35 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LLWYY3XK\\Jia and Witchel - 2021 - Nightcore efficient and scalable serverless compu.pdf}
}

@inproceedings{jin2021annotating,
  title = {Annotating, {{Tracking}}, and {{Protecting Cryptographic Secrets}} with {{CryptoMPK}}},
  shorttitle = {Cryptompk},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Jin, Xuancheng and Xiao, Xuangan and Jia, Songlin and Gao, Wang and Zhang, Hang and Gu, Dawu and Ma, Siqi and Qian, Zhiyun and Li, Juanru},
  year = {2021},
  month = sep,
  pages = {473--488},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00028},
  abstract = {Protecting confidential data against memory disclosure attacks is crucial to many critical applications, especially those involve cryptographic operations. However, it is neither easy to identify involved cryptographic confidential data in a program nor to implement a fine-grained and yet efficient protection. Existing defensive techniques face many shortcomings such as coarse-grained protection or  exorbitant overhead. As a result, real world crypto applications seldom applied this kind of protection in practice.    To make the protection of cryptographic confidential data practical, we design and implement CRYPTOMPK, a source code analysis and transformation system to implement a domain-based memory isolation. CRYPTOMPK first automatically tracks and labels all sensitive memory buffers and operations in source code with a context-sensitive, crypto-aware information flow analysis. Then it partitions the source code into crypto and non-crypto domains with a context-dependent privilege switch instrumentation. By further utilizing Intel Memory ProtectionKeys (MPK), CRYPTOMPK generates executables with efficient domain switching, protecting them against typical memory disclosure vulnerabilities such as arbitrary memory read. In particular, by using CRYPTOMPK, a large number of intermediate memory buffers that have been previously ignored before are well protected, and thus the security risks are reduced significantly. We leveraged CRYPTOMPK to protect prevalent applications such as Apache and Nginx with widely used cryptolibraries (e.g., OpenSSL, LibSodium). CRYPTOMPK only needs several minutes to analyze each of these complex cryptographic programs and incurs at most 9.53\% performance overhead for the protected programs.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\DTM22J5Y\\1wKCewebEuk.html}
}

@inproceedings{jin2021lessons,
  title = {Lessons Learned from Migrating Complex Stateful Applications onto Serverless Platforms},
  booktitle = {Proceedings of the 12th {{ACM SIGOPS Asia-Pacific Workshop}} on {{Systems}}},
  author = {Jin, Zewen and Zhu, Yiming and Zhu, Jiaan and Yu, Dongbo and Li, Cheng and Chen, Ruichuan and Akkus, Istemi Ekin and Xu, Yinlong},
  year = {2021},
  month = aug,
  series = {{{APSys}} '21},
  pages = {89--96},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3476886.3477510},
  abstract = {Serverless computing is increasingly seen as a pivot cloud computing paradigm that has great potential to simplify application development while removing the burden of operational tasks from developers. Despite these advantages, the use of serverless computing has been limited to few application scenarios exhibiting stateless and parallel executions. In addition, the significant effort and cost associated with rearchitecting existing codebase limits the range of these applications and hinder efforts to enhance serverless computing platforms to better suit the needs of current applications. In this paper, we report our experience and observations from migrating four complex and stateful microservice applications (involving 8 programming languages, 5 application frameworks, and 40 application logic services) to ApacheOpenWhisk, a widely used serverless computing platform. We highlight a number of patterns and guidelines that facilitate this migration with minimal code changes and practical performance considerations, and imply a path towards further automating this process. We hope our guidelines will help increase the applicability of serverless computing and improve serverless platforms to be more application friendly.},
  isbn = {978-1-4503-8698-2},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\36XZHECG\\Jin et al. - 2021 - Lessons learned from migrating complex stateful ap.pdf}
}

@inproceedings{jing2022operating,
  title = {Operating {{System Support}} for {{Safe}} and {{Efficient Auxiliary Execution}}},
  booktitle = {16th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 22)},
  author = {Jing, Yuzhuo and Huang, Peng},
  year = {2022},
  pages = {633--648},
  isbn = {978-1-939133-28-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\U2SIDFXG\\Jing and Huang - 2022 - Operating System Support for Safe and Efficient Au.pdf}
}

@article{jung2017rustbelt,
  title = {{{RustBelt}}: Securing the Foundations of the {{Rust}} Programming Language},
  shorttitle = {{{RustBelt}}},
  author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  year = {2017},
  month = dec,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {POPL},
  pages = {66:1--66:34},
  doi = {10.1145/3158154},
  abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
  keywords = {concurrency,logical relations,Rust,separation logic,type systems},
  annotation = {200 citations (Semantic Scholar/DOI) [2022-10-26]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\33YVV4RT\\Jung et al. - 2017 - RustBelt securing the foundations of the Rust pro.pdf}
}

@article{jungunderstanding,
  title = {{Understanding and Evolving the Rust Programming Language}},
  author = {Jung, Ralf},
  pages = {297},
  langid = {ngerman},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4LQWG5J9\\Jung - Understanding and Evolving the Rust Programming La.pdf}
}

@article{keshav2007how,
  title = {How to Read a Paper},
  author = {Keshav, S.},
  year = {2007},
  month = jul,
  journal = {ACM SIGCOMM Computer Communication Review},
  volume = {37},
  number = {3},
  pages = {83--84},
  issn = {0146-4833},
  doi = {10.1145/1273445.1273458},
  abstract = {Researchers spend a great deal of time reading research papers. However, this skill is rarely taught, leading to much wasted effort. This article outlines a practical and efficient three-pass method for reading research papers. I also describe how to use this method to do a literature survey.},
  keywords = {hints,paper,reading},
  annotation = {36 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\56YIJRQ3\\Keshav - 2007 - How to read a paper.pdf}
}

@inproceedings{khandaker2019adaptive,
  title = {Adaptive {{Call-Site Sensitive Control Flow Integrity}}},
  booktitle = {2019 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Khandaker, Mustakimur and Naser, Abu and Liu, Wenqing and Wang, Zhi and Zhou, Yajin and Cheng, Yueqiang},
  year = {2019},
  month = jun,
  pages = {95--110},
  doi = {10.1109/EuroSP.2019.00017},
  abstract = {Low-level languages like C/C++ are widely used in various applications for their performance and flexibility. Unfortunately, these languages are prone to memory corruption vulnerabilities, leading to control-flow hijacking attacks. Control flow integrity (CFI) is a general principle to enforce run-time control flow of a program to a pre-computed control-flow graph (CFG). While the traditional context-insensitive CFI falls short in protecting critical control transfers, recent context-sensitive CFI research shows promising improvements but has various limitations. We present Control Flow Integrity with Look Back (CFI-LB), a call-site sensitive CFI in which a conventional source-target control transfer is strengthened by a look back into its call-sites (return addresses). CFI-LB features the adaptive call-site sensitivity in which each indirect call has its own level of sensitivity and the multi-scope CFG to improve the security even if a precise context-sensitive static CFG is not available, especially for large programs such as GCC and NGINX. One of the CFGs is constructed by our localized concolic execution, which significantly extends the dynamic CFG with very low false positives. In addition, CFI-LB is the first CFI system explicitly designed to protect its reference monitors from race conditions. We have built a prototype of CFI-LB. The evaluation with SPEC CPU2006 benchmarks and NGINX indicates that CFI-LB has a low-performance overhead (less than 5\% on average for the full protection) while increasing the security.},
  keywords = {call sites,CFI,Context,context sensitive,Hardware,Kernel,Monitoring,Prototypes,Security,Sensitivity},
  annotation = {13 citations (Semantic Scholar/DOI) [2022-10-25]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4WGPDU3J\\Khandaker et al. - 2019 - Adaptive Call-Site Sensitive Control Flow Integrit.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\6BW6ZB2E\\8806734.html}
}

@inproceedings{khandaker2019originsensitive,
  title = {Origin-Sensitive {{Control Flow Integrity}}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Khandaker, Mustakimur Rahman and Liu, Wenqing and Naser, Abu and Wang, Zhi and Yang, Jie},
  year = {2019},
  pages = {195--211},
  isbn = {978-1-939133-06-9},
  langid = {english},
  keywords = {cfi,fine-grained cfi},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7L4RN5XA\\Khandaker et al. - 2019 - Origin-sensitive Control Flow Integrity.pdf}
}

@inproceedings{kilpatrick2003privman,
  title = {Privman: {{A Library}} for {{Partitioning Applications}}},
  shorttitle = {Privman},
  booktitle = {2003 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 03)},
  author = {Kilpatrick, Douglas},
  year = {2003},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JE6GULTQ\\Kilpatrick - 2003 - Privman A Library for Partitioning Applications.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\Q9ISRT2J\\privman-library-partitioning-applications.html}
}

@inproceedings{kim2018securing,
  title = {Securing {{Real-Time Microcontroller Systems}} through {{Customized Memory View Switching}}},
  booktitle = {Proceedings 2018 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Kim, Chung Hwan and Kim, Taegyu and Choi, Hongjun and Gu, Zhongshu and Lee, Byoungyoung and Zhang, Xiangyu and Xu, Dongyan},
  year = {2018},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2018.23107},
  abstract = {Real-time microcontrollers have been widely adopted in cyber-physical systems that require both real-time and security guarantees. Unfortunately, security is sometimes traded for real-time performance in such systems. Notably, memory isolation, which is one of the most established security features in modern computer systems, is typically not available in many real-time microcontroller systems due to its negative impacts on performance and violation of real-time constraints. As such, the memory space of these systems has created an open, monolithic attack surface that attackers can target to subvert the entire systems. In this paper, we present MINION, a security architecture that intends to virtually partition the memory space and enforce memory access control of a real-time microcontroller. MINION can automatically identify the reachable memory regions of realtime processes through off-line static analysis on the system's firmware and conduct run-time memory access control through hardware-based enforcement. Our evaluation results demonstrate that, by significantly reducing the memory space that each process can access, MINION can effectively protect a microcontroller from various attacks that were previously viable. In addition, unlike conventional memory isolation mechanisms that might incur substantial performance overhead, the lightweight design of MINION is able to maintain the real-time properties of the microcontroller.},
  isbn = {978-1-891562-49-5},
  langid = {english},
  keywords = {embedded},
  annotation = {64 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ZFAFR68N\\Kim et al. - 2018 - Securing Real-Time Microcontroller Systems through.pdf}
}

@inproceedings{kim2020hardwarebased,
  title = {Hardware-Based {{Always-On Heap Memory Safety}}},
  shorttitle = {{{AOS}}},
  booktitle = {2020 53rd {{Annual IEEE}}/{{ACM International Symposium}} on {{Microarchitecture}} ({{MICRO}})},
  author = {Kim, Yonghae and Lee, Jaekyu and Kim, Hyesoon},
  year = {2020},
  month = oct,
  pages = {1153--1166},
  doi = {10.1109/MICRO50266.2020.00095},
  abstract = {Memory safety violations, caused by illegal use of pointers in unsafe programming languages such as C and C++, have been a major threat to modern computer systems. However, implementing a low-overhead yet robust runtime memory safety solution is still challenging. Various hardware-based mechanisms have been proposed, but their significant hardware requirements have limited their feasibility, and their performance overhead is too high to be an always-on solution. In this paper, we propose AOS, a low-overhead always-on heap memory safety solution that implements a novel bounds-checking mechanism. We identify that the major challenges of existing bounds-checking approaches are 1) the extra instruction overhead for memory checking and metadata propagation and 2) the complex metadata addressing. To address these challenges, using Arm PA primitives, we leverage unused upper bits of a pointer to store a key and have it propagated along with the pointer address, eliminating propagation overhead. Then, we use the embedded key to index a hashed bounds table to achieve efficient metadata management. We also introduce a micro-architectural unit to remove the need for memory checking instructions. We show that AOS overcomes all the aforementioned challenges and demonstrate its feasibility as an efficient runtime memory safety solution. Our evaluation for SPEC 2006 workloads shows an 8.4\% performance overhead on average.},
  keywords = {Indexes,Memory management,Metadata,pac,Picture archiving and communication systems,pointer authentication,Runtime,Safety,Security,software and system safety},
  annotation = {11 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BNPIYDXZ\\Kim et al. - 2020 - Hardware-based Always-On Heap Memory Safety.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\LT9CH6Y4\\9251969.html}
}

@inproceedings{kim2021refining,
  title = {Refining {{Indirect Call Targets}} at the {{Binary Level}}},
  booktitle = {Proceedings 2021 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Kim, Sun Hyoung and Sun, Cong and Zeng, Dongrui and Tan, Gang},
  year = {2021},
  publisher = {{Internet Society}},
  address = {{Virtual}},
  doi = {10.14722/ndss.2021.24386},
  abstract = {Enforcing fine-grained Control-Flow Integrity (CFI) is critical for increasing software security. However, for commercial off-the-shelf (COTS) binaries, constructing highprecision Control-Flow Graphs (CFGs) is challenging, because there is no source-level information, such as symbols and types, to assist in indirect-branch target inference. The lack of sourcelevel information brings extra challenges to inferring targets for indirect calls compared to other kinds of indirect branches. Points-to analysis could be a promising solution for this problem, but there is no practical points-to analysis framework for inferring indirect call targets at the binary level. Value set analysis (VSA) is the state-of-the-art binary-level points-to analysis but does not scale to large programs. It is also highly conservative by design and thus leads to low-precision CFG construction. In this paper, we present a binary-level points-to analysis framework called BPA to construct sound and high-precision CFGs. It is a new way of performing points-to analysis at the binary level with the focus on resolving indirect call targets. BPA employs several major techniques, including assuming a block memory model and a memory access analysis for partitioning memory into blocks, to achieve a better balance between scalability and precision. In evaluation, we demonstrate that BPA achieves a 34.5\% precision improvement rate over the current state-of-theart technique without introducing false negatives.},
  isbn = {978-1-891562-66-2},
  langid = {english},
  keywords = {cfi,fine-grained cfi},
  annotation = {9 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GNALXSF2\\Kim et al. - 2021 - Refining Indirect Call Targets at the Binary Level.pdf}
}

@inproceedings{kirth2022pkrusafe,
  title = {{{PKRU-safe}}: Automatically Locking down the Heap between Safe and Unsafe Languages},
  shorttitle = {{{PKRU-safe}}},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Kirth, Paul and Dickerson, Mitchel and Crane, Stephen and Larsen, Per and Dabrowski, Adrian and Gens, David and Na, Yeoul and Volckaert, Stijn and Franz, Michael},
  year = {2022},
  month = mar,
  series = {{{EuroSys}} '22},
  pages = {132--148},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3492321.3519582},
  abstract = {After more than twenty-five years of research, memory safety violations remain one of the major causes of security vulnerabilities in real-world software. Memory-safe languages, like Rust, have demonstrated that compiler technology can assist developers in writing efficient low-level code without the risk of memory corruption. However, many memory-safe languages still have to interface with unsafe code to some extent, which opens up the possibility for attackers to exploit memory-corruption vulnerabilities in the unsafe part of the system and subvert the safety guarantees provided by the memory-safe language. In this paper, we present PKRU-Safe, an automated method for enforcing the principle of least privilege on unsafe components in mixed-language environments. PKRU-Safe ensures that unsafe (external) code cannot corrupt or otherwise abuse memory used exclusively by the safe-language components. Our approach is automated using traditional compiler infrastructure to limit memory accesses for developer-designated components efficiently. PKRU-Safe does not require any modifications to the program's original data flows or execution model. It can be adopted by projects containing legacy code with minimal effort, requiring only a small number of changes to a project's build files and dependencies, and a few lines of annotations for each untrusted library. We apply PKRU-Safe to Servo, one of the largest Rust projects with approximately two million lines of Rust code (including dependencies) to automatically partition and protect the browser's heap from its JavaScript engine written in unsafe C/C++. Our detailed evaluation shows that PKRU-Safe is able to thwart real-world exploits, often without measurable overhead, and with a mean overhead under 11.55\% in our most pessimistic benchmark suite. As the method is language agnostic and major prototype components operate directly on LLVM IR, applying our techniques to other languages is straightforward.},
  isbn = {978-1-4503-9162-7},
  keywords = {compartmentalization,compilers,MPK,security},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RPRN6PUC\\Kirth et al. - 2022 - PKRU-safe automatically locking down the heap bet.pdf}
}

@inproceedings{klein2009sel4,
  title = {{{seL4}}: Formal Verification of an {{OS}} Kernel},
  shorttitle = {{{seL4}}},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on {{Operating}} Systems Principles - {{SOSP}} '09},
  author = {Klein, Gerwin and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal},
  year = {2009},
  pages = {207},
  publisher = {{ACM Press}},
  address = {{Big Sky, Montana, USA}},
  doi = {10.1145/1629575.1629596},
  abstract = {Complete formal verification is the only known way to guarantee that a system is free of programming errors. We present our experience in performing the formal, machine-checked verification of the seL4 microkernel from an abstract specification down to its C implementation. We assume correctness of compiler, assembly code, and hardware, and we used a unique design approach that fuses formal and operating systems techniques. To our knowledge, this is the first formal proof of functional correctness of a complete, general-purpose operating-system kernel. Functional correctness means here that the implementation always strictly follows our high-level abstract specification of kernel behaviour. This encompasses traditional design and implementation safety properties such as the kernel will never crash, and it will never perform an unsafe operation. It also proves much more: we can predict precisely how the kernel will behave in every possible situation.},
  isbn = {978-1-60558-752-3},
  langid = {english},
  annotation = {1628 citations (Semantic Scholar/DOI) [2022-10-25]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RD7S83LU\\Klein et al. - 2009 - seL4 formal verification of an OS kernel.pdf}
}

@inproceedings{koeberl2014trustlite,
  title = {{{TrustLite}}: A Security Architecture for Tiny Embedded Devices},
  shorttitle = {{{TrustLite}}},
  booktitle = {Proceedings of the {{Ninth European Conference}} on {{Computer Systems}}},
  author = {Koeberl, Patrick and Schulz, Steffen and Sadeghi, Ahmad-Reza and Varadharajan, Vijay},
  year = {2014},
  month = apr,
  series = {{{EuroSys}} '14},
  pages = {1--14},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2592798.2592824},
  abstract = {Embedded systems are increasingly pervasive, interdependent and in many cases critical to our every day life and safety. Tiny devices that cannot afford sophisticated hardware security mechanisms are embedded in complex control infrastructures, medical support systems and entertainment products [51]. As such devices are increasingly subject to attacks, new hardware protection mechanisms are needed to provide the required resilience and dependency at low cost. In this work, we present the TrustLite security architecture for flexible, hardware-enforced isolation of software modules. We describe mechanisms for secure exception handling and communication between protected modules, enabling seamless interoperability with untrusted operating systems and tasks. TrustLite scales from providing a simple protected firmware runtime to advanced functionality such as attestation and trusted execution of userspace tasks. Our FPGA prototype shows that these capabilities are achievable even on low-cost embedded systems.},
  isbn = {978-1-4503-2704-6},
  annotation = {279 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QA4WDHAS\\Koeberl et al. - 2014 - TrustLite a security architecture for tiny embedd.pdf}
}

@inproceedings{koo2019configurationdriven,
  title = {Configuration-{{Driven Software Debloating}}},
  booktitle = {Proceedings of the 12th {{European Workshop}} on {{Systems Security}}},
  author = {Koo, Hyungjoon and Ghavamnia, Seyedhamed and Polychronakis, Michalis},
  year = {2019},
  month = mar,
  series = {{{EuroSec}} '19},
  pages = {1--6},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3301417.3312501},
  abstract = {With legitimate code becoming an attack surface due to the proliferation of code reuse attacks, software debloating is an effective mitigation that reduces the amount of instruction sequences that may be useful for an attacker, in addition to eliminating potentially exploitable bugs in the removed code. Existing debloating approaches either statically remove code that is guaranteed to not run (e.g., non-imported functions from shared libraries), or rely on profiling with realistic workloads to pinpoint and keep only the subset of code that was executed. In this work, we explore an alternative configuration-driven software debloating approach that removes feature-specific code that is exclusively needed only when certain configuration directives are specified---which are often disabled by default. Using a semi-automated approach, our technique identifies libraries solely needed for the implementation of a particular functionality and maps them to certain configuration directives. Based on this mapping, feature-specific libraries are not loaded at all if their corresponding directives are disabled. The results of our experimental evaluation with Nginx, VSFTPD, and OpenSSH show that using the default configuration in each case, configuration-driven debloating can remove 77\% of the code for Nginx, 53\% for VSFTPD, and 20\% for OpenSSH, which represent a significant attack surface reduction.},
  isbn = {978-1-4503-6274-0},
  annotation = {36 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TRLGDRW3\\Koo et al. - 2019 - Configuration-Driven Software Debloating.pdf}
}

@inproceedings{koromilas2016grim,
  title = {{{GRIM}}: {{Leveraging GPUs}} for {{Kernel Integrity Monitoring}}},
  shorttitle = {{{GRIM}}},
  booktitle = {Research in {{Attacks}}, {{Intrusions}}, and {{Defenses}}},
  author = {Koromilas, Lazaros and Vasiliadis, Giorgos and Athanasopoulos, Elias and Ioannidis, Sotiris},
  editor = {Monrose, Fabian and Dacier, Marc and Blanc, Gregory and {Garcia-Alfaro}, Joaquin},
  year = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {3--23},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-45719-2_1},
  abstract = {Kernel rootkits can exploit an operating system and enable future accessibility and control, despite all recent advances in software protection. A promising defense mechanism against rootkits is Kernel Integrity Monitor (KIM) systems, which inspect the kernel text and data to discover any malicious changes. A KIM can be implemented either in software, using a hypervisor, or using extra hardware. The latter option is more attractive due to better performance and higher security, since the monitor is isolated from the potentially vulnerable host. To remain under the radar and avoid detection it is paramount for a rootkit to conceal its malicious activities. In order to detect self-hiding rootkits researchers have proposed snooping for inferring suspicious behaviour in kernel memory. This is accomplished by constantly monitoring all memory accesses on the bus and not the actual memory area where the kernel is mapped.},
  isbn = {978-3-319-45719-2},
  langid = {english},
  keywords = {Address Space,hardware-assisted security,Kernel Module,Memory Bandwidth,Memory Region,Page Table},
  annotation = {15 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SUU9TBQA\\Koromilas et al. - 2016 - GRIM Leveraging GPUs for Kernel Integrity Monitor.pdf}
}

@inproceedings{koruyeh2020speccfi,
  title = {{{SpecCFI}}: {{Mitigating Spectre Attacks}} Using {{CFI Informed Speculation}}},
  shorttitle = {{{SpecCFI}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Koruyeh, Esmaeil Mohammadian and Haji Amin Shirazi, Shirin and Khasawneh, Khaled N. and Song, Chengyu and {Abu-Ghazaleh}, Nael},
  year = {2020},
  month = may,
  pages = {39--53},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00033},
  abstract = {Spectre attacks and their many subsequent variants are a new vulnerability class affecting modern CPUs. The attacks rely on the ability to misguide speculative execution, generally by exploiting the branch prediction structures, to execute a vulnerable code sequence speculatively. In this paper, we propose to use Control-Flow Integrity (CFI), a security technique used to stop control-flow hijacking attacks, on the committed path, to prevent speculative control-flow from being hijacked to launch the most dangerous variants of the Spectre attacks (Spectre-BTB and Spectre-RSB). Specifically, CFI attempts to constrain the possible targets of an indirect branch to a set of legal targets defined by a pre-calculated control-flow graph (CFG). As CFI is being adopted by commodity software (e.g., Windows and Android) and commodity hardware (e.g., Intel's CET and ARM's BTI), the CFI information becomes readily available through the hardware CFI extensions. With the CFI information, we apply CFI principles to also constrain illegal control-flow during speculative execution. Specifically, our proposed defense, SpecCFI, ensures that control flow instructions target legal destinations to constrain dangerous speculation on forward control-flow paths (indirect calls and branches). We augment this protection with a precise speculation-aware hardware stack to constrain speculation on backward control-flow edges (returns). We combine this solution with existing solutions against branch target predictor attacks (Spectre-PHT) to close all known non-vendor-specific Spectre vulnerabilities. We show that SpecCFI results in small overheads both in terms of performance and additional hardware complexity.},
  keywords = {Androids,cfi,Complexity theory,Hardware,Law,Security,Software,spectre},
  annotation = {33 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XN7WGIH7\\Koruyeh et al. - 2020 - SpecCFI Mitigating Spectre Attacks using CFI Info.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZESFKZJS\\9152786.html}
}

@inproceedings{kotni2021faastlane,
  title = {Faastlane: {{Accelerating}} \{\vphantom\}{{Function-as-a-Service}}\vphantom\{\} {{Workflows}}},
  shorttitle = {Faastlane},
  booktitle = {2021 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 21)},
  author = {Kotni, Swaroop and Nayak, Ajay and Ganapathy, Vinod and Basu, Arkaprava},
  year = {2021},
  pages = {805--820},
  isbn = {978-1-939133-23-6},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\42HU22VU\\Kotni et al. - 2021 - Faastlane Accelerating Function-as-a-Service Wo.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZFIKE4C2\\kotni.html}
}

@inproceedings{kulkarni2018splinter,
  title = {Splinter: {{Bare-Metal Extensions}} for {{Multi-Tenant Low-Latency Storage}}},
  shorttitle = {Splinter},
  booktitle = {13th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 18)},
  author = {Kulkarni, Chinmay and Moore, Sara and Naqvi, Mazhar and Zhang, Tian and Ricci, Robert and Stutsman, Ryan},
  year = {2018},
  pages = {627--643},
  isbn = {978-1-939133-08-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\M3AKRUXD\\Kulkarni et al. - 2018 - Splinter Bare-Metal Extensions for Multi-Tenan.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\CDIJV49V\\kulkarni.html}
}

@inproceedings{kuo2020linux,
  title = {A {{Linux}} in Unikernel Clothing},
  booktitle = {Proceedings of the {{Fifteenth European Conference}} on {{Computer Systems}}},
  author = {Kuo, Hsuan-Chi and Williams, Dan and Koller, Ricardo and Mohan, Sibin},
  year = {2020},
  month = apr,
  pages = {1--15},
  publisher = {{ACM}},
  address = {{Heraklion Greece}},
  doi = {10.1145/3342195.3387526},
  abstract = {Unikernels leverage library OS architectures to run isolated workloads on the cloud. They have garnered attention in part due to their promised performance characteristics such as small image size, fast boot time, low memory footprint and application performance. However, those that aimed at generality fall short of the application compatibility, robustness and, more importantly, community that is available for Linux. In this paper, we describe and evaluate Lupine Linux, a standard Linux system that\textemdash through kernel configuration specialization and system call overhead elimination\textemdash achieves unikernel-like performance, in fact outperforming at least one reference unikernel in all of the above dimensions. At the same time, Lupine can run any application (since it is Linux) when faced with more general workloads, whereas many unikernels simply crash. We demonstrate a graceful degradation of unikernel-like performance properties.},
  isbn = {978-1-4503-6882-7},
  langid = {english},
  annotation = {16 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BGXX9ZK8\\Kuo et al. - 2020 - A Linux in unikernel clothing.pdf}
}

@article{kuo2020set,
  title = {Set the {{Configuration}} for the {{Heart}} of the {{OS}}: {{On}} the {{Practicality}} of {{Operating System Kernel Debloating}}},
  shorttitle = {Set the {{Configuration}} for the {{Heart}} of the {{OS}}},
  author = {Kuo, Hsuan-Chi and Chen, Jianyan and Mohan, Sibin and Xu, Tianyin},
  year = {2020},
  month = may,
  journal = {Proceedings of the ACM on Measurement and Analysis of Computing Systems},
  volume = {4},
  number = {1},
  pages = {1--27},
  issn = {2476-1249},
  doi = {10.1145/3379469},
  abstract = {This paper presents a study on the practicality of operating system (OS) kernel debloating---reducing kernel code that is not needed by the target applications---in real-world systems. Despite their significant benefits regarding security (attack surface reduction) and performance (fast boot times and reduced memory footprints), the state-of-the-art OS kernel debloating techniques are seldom adopted in practice, especially in production systems. We identify the limitations of existing kernel debloating techniques that hinder their practical adoption, including both accidental and essential limitations. To understand these limitations, we build an advanced debloating framework named \textbackslash tool which enables us to conduct a number of experiments on different types of OS kernels (including Linux and the L4 microkernel) with a wide variety of applications (including HTTPD, Memcached, MySQL, NGINX, PHP and Redis). Our experimental results reveal the challenges and opportunities towards making kernel debloating techniques practical for real-world systems. The main goal of this paper is to share these insights and our experiences to shed light on addressing the limitations of kernel debloating in future research and development efforts.},
  langid = {english},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XHEKGCM8\\Kuo et al. - 2020 - Set the Configuration for the Heart of the OS On .pdf}
}

@inproceedings{kuo2022verified,
  title = {Verified Programs Can Party: Optimizing Kernel Extensions via Post-Verification Merging},
  shorttitle = {Verified Programs Can Party},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Kuo, Hsuan-Chi and Chen, Kai-Hsun and Lu, Yicheng and Williams, Dan and Mohan, Sibin and Xu, Tianyin},
  year = {2022},
  month = mar,
  series = {{{EuroSys}} '22},
  pages = {283--299},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3492321.3519562},
  abstract = {Operating system (OS) extensions are more popular than ever. For example, Linux BPF is marketed as a "superpower" that allows user programs to be downloaded into the kernel, verified to be safe and executed at kernel hook points. So, BPF extensions have high performance and are often placed at performance-critical paths for tracing and filtering. However, although BPF extension programs execute in a shared kernel environment and are already individually verified, they are often executed independently in chains. We observe that the chain pattern has large performance overhead, due to indirect jumps penalized by security mitigations (e.g., Spectre), loops, and memory accesses. In this paper, we argue for a separation of concerns. We propose to decouple the execution of BPF extensions from their verification requirements---BPF extension programs can be collectively optimized, after each BPF extension program is individually verified and loaded into the shared kernel. We present KFuse, a framework that dynamically and automatically merges chains of BPF programs by transforming indirect jumps into direct jumps, unrolling loops, and saving memory accesses, without loss of security or flexibility. KFuse can merge BPF programs that are (1) installed by multiple principals, (2) maintained to be modular and separate, (3) installed at different points of time, and (4) split into smaller, verifiable programs via BPF tail calls. KFuse demonstrates 85\% performance improvement of BPF chain execution and 7\% of application performance improvement over existing BPF use cases (systemd's Seccomp BPF filters). It achieves more significant benefits for longer chains.},
  isbn = {978-1-4503-9162-7},
  keywords = {BPF,eBPF,indirect jump,kernel extension,retpoline,spectre,transient attack},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\P9LYRQAD\\Kuo et al. - 2022 - Verified programs can party optimizing kernel ext.pdf}
}

@inproceedings{kuznetsov2014codepointer,
  title = {Code-{{Pointer Integrity}}},
  booktitle = {11th \{\vphantom\}{{USENIX}}\vphantom\{\} {{Symposium}} on {{Operating Systems Design}} and {{Implementation}} (\{\vphantom\}{{OSDI}}\vphantom\{\} 14)},
  author = {Kuznetsov, Volodymyr and Szekeres, Laszlo and Payer, Mathias and Candea, George and Sekar, R. and Song, Dawn},
  year = {2014},
  pages = {147--163},
  isbn = {978-1-931971-16-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\Z25YXVKN\\Kuznetsov et al. - 2014 - Code-Pointer Integrity.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7X8EJ9M5\\kuznetsov.html}
}

@inproceedings{kuznetsov2022privbox,
  title = {Privbox: {{Faster System Calls Through Sandboxed Privileged Execution}}},
  shorttitle = {Privbox},
  booktitle = {2022 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 22)},
  author = {Kuznetsov, Dmitry and Morrison, Adam},
  year = {2022},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5CENLPMX\\Kuznetsov and Morrison - 2022 - Privbox Faster System Calls Through Sandboxed Pri.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\I57SYGAV\\kuznetsov.html}
}

@inproceedings{kwon2019uxom,
  title = {{{uXOM}}: {{Efficient eXecute-Only Memory}} on {{ARM Cortex-M}}},
  shorttitle = {\{\vphantom\}{{uXOM}}\vphantom\{\}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Kwon, Donghyun and Shin, Jangseop and Kim, Giyeol and Lee, Byoungyoung and Cho, Yeongpil and Paek, Yunheung},
  year = {2019},
  pages = {231--247},
  isbn = {978-1-939133-06-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8S95M8C7\\Kwon et al. - 2019 - uXOM Efficient eXecute-Only Memory on ARM .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\9B544IJU\\kwon.html}
}

@article{kwon2021zerokernel,
  title = {{{ZeroKernel}}: {{Secure Context-Isolated Execution}} on {{Commodity GPUs}}},
  shorttitle = {{{ZeroKernel}}},
  author = {Kwon, Ohmin and Kim, Yonggon and Huh, Jaehyuk and Yoon, Hyunsoo},
  year = {2021},
  month = jul,
  journal = {IEEE Transactions on Dependable and Secure Computing},
  volume = {18},
  number = {4},
  pages = {1974--1988},
  issn = {1941-0018},
  doi = {10.1109/TDSC.2019.2946250},
  abstract = {In the last decade, the dedicated graphics processing unit (GPU) has emerged as an architecture for high-performance computing workloads. Recently, researchers have also focused on the isolation property of a dedicated GPU and suggested GPU-based secure computing environments with several promising applications. However, despite the security analysis conducted by the prior studies, it has been unclear whether a dedicated GPU can be leveraged as a secure processor in the presence of a kernel-privileged attacker. In this paper, we first demonstrate the security of dedicated GPUs through comprehensive studies on context information for GPU execution. The paper shows that a kernel-privileged attacker can manipulate the GPU contexts to redirect memory accesses or execute arbitrary GPU codes on the running GPU kernel. Based on the security analysis, this paper proposes a new on-chip execution model for the dedicated GPU and a novel defense mechanism supporting the security of the on-chip execution. With comprehensive evaluation, the paper assures that the proposed solutions effectively isolate sensitive data in on-chip storages and defend against known attack vectors from a privileged attacker, supporting that the commodity GPUs can be leveraged as a secure processor.},
  keywords = {Computer architecture,Context,Graphics processing units,Graphics processors,Kernel,on-chip execution,Registers,reverse engineering,security,Security,System-on-chip},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\R33RKPIA\\Kwon et al. - 2021 - ZeroKernel Secure Context-Isolated Execution on C.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\QVNRUBKS\\8863993.html}
}

@misc{labpurdue,
  title = {Purdue {{OWL}} // {{Purdue Writing Lab}}},
  author = {Lab, Purdue Writing},
  journal = {Purdue Writing Lab},
  abstract = {The Purdue University Online Writing Lab serves writers from around the world and the Purdue University Writing Lab helps writers on Purdue's campus.},
  howpublished = {https://owl.purdue.edu/owl/purdue\_owl.html},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\B5WG2PCV\\purdue_owl.html}
}

@inproceedings{lamowski2017sandcrust,
  title = {Sandcrust: {{Automatic Sandboxing}} of {{Unsafe Components}} in {{Rust}}},
  shorttitle = {Sandcrust},
  booktitle = {Proceedings of the 9th {{Workshop}} on {{Programming Languages}} and {{Operating Systems}}},
  author = {Lamowski, Benjamin and Weinhold, Carsten and Lackorzynski, Adam and H{\"a}rtig, Hermann},
  year = {2017},
  month = oct,
  series = {{{PLOS}}'17},
  pages = {51--57},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3144555.3144562},
  abstract = {System-level development has been dominated by traditional programming languages such as C and C++ for decades. These languages are inherently unsafe regarding memory management. Even experienced developers make mistakes that open up security holes or compromise the safety properties of software. The Rust programming language is targeted at the systems domain and aims to eliminate memory-related programming errors by enforcing a strict memory model at the language and compiler level. Unfortunately, these compile-time guarantees no longer hold when a Rust program is linked against a library written in unsafe C, which is commonly required for functionality where an implementation in Rust is not yet available. In this paper, we present Sandcrust, an easy-to-use sand-boxing solution for isolating code and data of a C library in a separate process. This isolation protects the Rust-based main program from any memory corruption caused by bugs in the unsafe library, which would otherwise invalidate the memory safety guarantees of Rust. Sandcrust is based on the Rust macro system and requires no modification to the compiler or runtime, but only straightforward annotation of functions that call the library's API.},
  isbn = {978-1-4503-5153-9},
  annotation = {19 citations (Semantic Scholar/DOI) [2022-10-25]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SVV645LK\\Lamowski et al. - 2017 - Sandcrust Automatic Sandboxing of Unsafe Componen.pdf}
}

@article{lampson1974protection,
  title = {Protection},
  author = {Lampson, Butler W.},
  year = {1974},
  month = jan,
  journal = {ACM SIGOPS Operating Systems Review},
  volume = {8},
  number = {1},
  pages = {18--24},
  issn = {0163-5980},
  doi = {10.1145/775265.775268},
  abstract = {Abstract models are given which reflect the properties of most existing mechanisms for enforcing protection or access control, together with some possible implementations. The properties of existing systems are explicated in terms of the model and implementations.},
  annotation = {30 citations (Semantic Scholar/DOI) [2022-10-30]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7N63Z5P5\\Lampson - 1974 - Protection.pdf}
}

@inproceedings{lee2015preventing,
  title = {Preventing {{Use-after-free}} with {{Dangling Pointers Nullification}}},
  booktitle = {Proceedings 2015 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Lee, Byoungyoung and Song, Chengyu and Jang, Yeongjin and Wang, Tielei and Kim, Taesoo and Lu, Long and Lee, Wenke},
  year = {2015},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2015.23238},
  abstract = {Many system components and network applications are written in languages that are prone to memory corruption vulnerabilities. There have been countless cases where simple mistakes by developers resulted in memory corruption vulnerabilities and consequently security exploits. While there have been tremendous research efforts to mitigate these vulnerabilities, useafter-free still remains one of the most critical and popular attack vectors because existing proposals have not adequately addressed the challenging program analysis and runtime performance issues.},
  isbn = {978-1-891562-38-9},
  langid = {english},
  keywords = {use-after-free},
  annotation = {112 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SNXTYX3H\\Lee et al. - 2015 - Preventing Use-after-free with Dangling Pointers N.pdf}
}

@inproceedings{lee2021constraintguided,
  title = {Constraint-Guided {{Directed Greybox Fuzzing}}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Lee, Gwangmu and Shim, Woochul and Lee, Byoungyoung},
  year = {2021},
  pages = {3559--3576},
  isbn = {978-1-939133-24-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\L36QIS65\\Lee et al. - 2021 - Constraint-guided Directed Greybox Fuzzing.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\E5NH473S\\lee-gwangmu.html}
}

@inproceedings{lefeuvre2022flexos,
  title = {{{FlexOS}}: Towards Flexible {{OS}} Isolation},
  shorttitle = {{{FlexOS}}},
  booktitle = {Proceedings of the 27th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Lefeuvre, Hugo and B{\u a}doiu, Vlad-Andrei and Jung, Alexander and Teodorescu, Stefan Lucian and Rauch, Sebastian and Huici, Felipe and Raiciu, Costin and Olivier, Pierre},
  year = {2022},
  month = feb,
  pages = {467--482},
  publisher = {{ACM}},
  address = {{Lausanne Switzerland}},
  doi = {10.1145/3503222.3507759},
  abstract = {At design time, modern operating systems are locked in a specific safety and isolation strategy that mixes one or more hardware/software protection mechanisms (e.g. user/kernel separation); revisiting these choices after deployment requires a major refactoring effort. This rigid approach shows its limits given the wide variety of modern applications' safety/performance requirements, when new hardware isolation mechanisms are rolled out, or when existing ones break.},
  isbn = {978-1-4503-9205-1},
  langid = {english},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6VNUIJME\\Lefeuvre et al. - 2022 - FlexOS towards flexible OS isolation.pdf}
}

@inproceedings{lemay2021cryptographic,
  title = {Cryptographic {{Capability Computing}}},
  booktitle = {{{MICRO-54}}: 54th {{Annual IEEE}}/{{ACM International Symposium}} on {{Microarchitecture}}},
  author = {LeMay, Michael and Rakshit, Joydeep and Deutsch, Sergej and Durham, David M. and Ghosh, Santosh and Nori, Anant and Gaur, Jayesh and Weiler, Andrew and Sultana, Salmin and Grewal, Karanvir and Subramoney, Sreenivas},
  year = {2021},
  month = oct,
  series = {{{MICRO}} '21},
  pages = {253--267},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3466752.3480076},
  abstract = {Capability architectures for memory safety have traditionally required expanding pointers and radically changing microarchitectural structures throughout processors, while only providing superficial hardening. We hence propose Cryptographic Capability Computing (C3) - the first memory safety mechanism that is stateless to avoid requiring extra metadata storage. C3 retains 64-bit pointer sizes providing legacy binary compatibility while imposing minimal touchpoints. Pointers are encrypted to unforgeably (within cryptographic bounds) reference each object. Data is encrypted even in caches and entangled with pointers for both spatial and temporal object-granular protection. Pointers become like unique keys for each allocation. C3 deploys a novel form of prediction for address translation that mitigates performance overheads even when addresses are partially encrypted. Use of a low-latency, low-area cipher from the NIST Lightweight Cryptography project avoids delaying loads by readying a data keystream by the time data is returned from the L1 cache. C3 is compatible with legacy binaries. Simulated performance overhead on SPEC CPU2006 is negligible with no memory overhead, which is a big leap forward compared to the overheads imposed by past memory safety approaches. C3 effectively replaces inefficient metadata with efficient cryptography.},
  isbn = {978-1-4503-8557-2},
  keywords = {capabilities,memory encryption,memory safety},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MKMZD64V\\LeMay et al. - 2021 - Cryptographic Capability Computing.pdf}
}

@inproceedings{levy2015ownership,
  title = {Ownership Is Theft: Experiences Building an Embedded {{OS}} in Rust},
  shorttitle = {Ownership Is Theft},
  booktitle = {Proceedings of the 8th {{Workshop}} on {{Programming Languages}} and {{Operating Systems}}},
  author = {Levy, Amit and Andersen, Michael P. and Campbell, Bradford and Culler, David and Dutta, Prabal and Ghena, Branden and Levis, Philip and Pannuto, Pat},
  year = {2015},
  month = oct,
  series = {{{PLOS}} '15},
  pages = {21--26},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2818302.2818306},
  abstract = {Rust, a new systems programming language, provides compile-time memory safety checks to help eliminate runtime bugs that manifest from improper memory management. This feature is advantageous for operating system development, and especially for embedded OS development, where recovery and debugging are particularly challenging. However, embedded platforms are highly event-based, and Rust's memory safety mechanisms largely presume threads. In our experience developing an operating system for embedded systems in Rust, we have found that Rust's ownership model prevents otherwise safe resource sharing common in the embedded domain, conflicts with the reality of hardware resources, and hinders using closures for programming asynchronously. We describe these experiences and how they relate to memory safety as well as illustrate our workarounds that preserve the safety guarantees to the largest extent possible. In addition, we draw from our experience to propose a new language extension to Rust that would enable it to provide better memory safety tools for event-driven platforms.},
  isbn = {978-1-4503-3942-1},
  keywords = {embedded operating systems,linear types,ownership,rust},
  annotation = {34 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SACI44NV\\Levy et al. - 2015 - Ownership is theft experiences building an embedd.pdf}
}

@inproceedings{levy2017multiprogramming,
  title = {Multiprogramming a {{64kB Computer Safely}} and {{Efficiently}}},
  booktitle = {Proceedings of the 26th {{Symposium}} on {{Operating Systems Principles}}},
  author = {Levy, Amit and Campbell, Bradford and Ghena, Branden and Giffin, Daniel B. and Pannuto, Pat and Dutta, Prabal and Levis, Philip},
  year = {2017},
  month = oct,
  series = {{{SOSP}} '17},
  pages = {234--251},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3132747.3132786},
  abstract = {Low-power microcontrollers lack some of the hardware features and memory resources that enable multiprogrammable systems. Accordingly, microcontroller-based operating systems have not provided important features like fault isolation, dynamic memory allocation, and flexible concurrency. However, an emerging class of embedded applications are software platforms, rather than single purpose devices, and need these multiprogramming features. Tock, a new operating system for low-power platforms, takes advantage of limited hardware-protection mechanisms as well as the type-safety features of the Rust programming language to provide a multiprogramming environment for microcontrollers. Tock isolates software faults, provides memory protection, and efficiently manages memory for dynamic application workloads written in any language. It achieves this while retaining the dependability requirements of long-running applications.},
  isbn = {978-1-4503-5085-3},
  annotation = {85 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8JH936DQ\\Levy et al. - 2017 - Multiprogramming a 64kB Computer Safely and Effici.pdf}
}

@article{li2019improving,
  title = {Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks},
  author = {Li, Yi and Wang, Shaohua and Nguyen, Tien N. and Van Nguyen, Son},
  year = {2019},
  month = oct,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {OOPSLA},
  pages = {162:1--162:30},
  doi = {10.1145/3360588},
  abstract = {Bug detection has been shown to be an effective way to help developers in detecting bugs early, thus, saving much effort and time in software development process. Recently, deep learning-based bug detection approaches have gained successes over the traditional machine learning-based approaches, the rule-based program analysis approaches, and mining-based approaches. However, they are still limited in detecting bugs that involve multiple methods and suffer high rate of false positives. In this paper, we propose a combination approach with the use of contexts and attention neural network to overcome those limitations. We propose to use as the global context the Program Dependence Graph (PDG) and Data Flow Graph (DFG) to connect the method under investigation with the other relevant methods that might contribute to the buggy code. The global context is complemented by the local context extracted from the path on the AST built from the method's body. The use of PDG and DFG enables our model to reduce the false positive rate, while to complement for the potential reduction in recall, we make use of the attention neural network mechanism to put more weights on the buggy paths in the source code. That is, the paths that are similar to the buggy paths will be ranked higher, thus, improving the recall of our model. We have conducted several experiments to evaluate our approach on a very large dataset with +4.973M methods in 92 different project versions. The results show that our tool can have a relative improvement up to 160\% on F-score when comparing with the state-of-the-art bug detection approaches. Our tool can detect 48 true bugs in the list of top 100 reported bugs, which is 24 more true bugs when comparing with the baseline approaches. We also reported that our representation is better suitable for bug detection and relatively improves over the other representations up to 206\% in accuracy.},
  keywords = {Attention Neural Networks,Bug Detection,Code Representation Learning,Deep Learning,Network Embedding,Program Graphs},
  annotation = {61 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\M27PZ25Y\\Li et al. - 2019 - Improving bug detection via context-based code rep.pdf}
}

@inproceedings{li2020dlfix,
  title = {{{DLFix}}: Context-Based Code Transformation Learning for Automated Program Repair},
  shorttitle = {{{DLFix}}},
  booktitle = {Proceedings of the {{ACM}}/{{IEEE}} 42nd {{International Conference}} on {{Software Engineering}}},
  author = {Li, Yi and Wang, Shaohua and Nguyen, Tien N.},
  year = {2020},
  month = jun,
  series = {{{ICSE}} '20},
  pages = {602--614},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3377811.3380345},
  abstract = {Automated Program Repair (APR) is very useful in helping developers in the process of software development and maintenance. Despite recent advances in deep learning (DL), the DL-based APR approaches still have limitations in learning bug-fixing code changes and the context of the surrounding source code of the bug-fixing code changes. These limitations lead to incorrect fixing locations or fixes. In this paper, we introduce DLFix, a two-tier DL model that treats APR as code transformation learning from the prior bug fixes and the surrounding code contexts of the fixes. The first layer is a tree-based RNN model that learns the contexts of bug fixes and its result is used as an additional weighting input for the second layer designed to learn the bug-fixing code transformations. We conducted several experiments to evaluate DLFix in two benchmarks: Defect4j and Bugs.jar, and a newly built bug datasets with a total of +20K real-world bugs in eight projects. We compared DLFix against a total of 13 state-of-the-art pattern-based APR tools. Our results show that DLFix can auto-fix more bugs than 11 of them, and is comparable and complementary to the top two pattern-based APR tools in which there are 7 and 11 unique bugs that they cannot detect, respectively, but we can. Importantly, DLFix is fully automated and data-driven, and does not require hard-coding of bug-fixing patterns as in those tools. We compared DLFix against 4 state-of-the-art deep learning based APR models. DLFix is able to fix 2.5 times more bugs than the best performing baseline.},
  isbn = {978-1-4503-7121-6},
  keywords = {automated program repair,context-based code transformation learning,deep learning},
  annotation = {8 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GW4DUGF5\\Li et al. - 2020 - DLFix context-based code transformation learning .pdf}
}

@incollection{li2020finding,
  title = {Finding {{Cracks}} in {{Shields}}: {{On}} the {{Security}} of {{Control Flow Integrity Mechanisms}}},
  shorttitle = {Finding {{Cracks}} in {{Shields}}},
  booktitle = {Proceedings of the 2020 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Li, Yuan and Wang, Mingzhe and Zhang, Chao and Chen, Xingman and Yang, Songtao and Liu, Ying},
  year = {2020},
  month = oct,
  pages = {1821--1835},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  abstract = {Control-flow integrity (CFI) is a promising technique to mitigate control-flow hijacking attacks. In the past decade, dozens of CFI mechanisms have been proposed by researchers. Despite the claims made by themselves, the security promises of these mechanisms have not been carefully evaluated, and thus are questionable. In this paper, we present a solution to measure the gap between the practical security and the claimed theoretical security. First, we propose CScan to precisely measure runtime feasible targets of indirect control transfer (ICT) instructions protected by CFI, by enumerating all potential code addresses and testing whether ICTs are allowed to jump to them. Second, we propose CBench as a sanity check for verifying CFI solutions? effectiveness against typical attacks, by exploiting a comprehensive set of vulnerable programs protected by CFI and verifying the recognized feasible targets. We evaluated 12 most recent open-source CFI mechanisms and discovered 10 flaws in most CFI mechanisms or implementations. For some CFIs, their security policies or protected ICT sets do not match what they claimed. Some CFIs even expand the attack surface (e.g. introducing unintended targets). To facilitate a deeper understanding of CFI, we summarize the flaws into 7 common pitfalls which cover the whole lifetime of CFI mechanisms and reveal issues that affect CFI mechanisms in practical security.},
  isbn = {978-1-4503-7089-9},
  keywords = {cfi,control flow integrity,evaluation,practical security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WKRC4VCL\\Li et al. - 2020 - Finding Cracks in Shields On the Security of Cont.pdf}
}

@inproceedings{li2021arbitrar,
  title = {{{ARBITRAR}}: {{User-Guided API Misuse Detection}}},
  shorttitle = {{{ARBITRAR}}},
  booktitle = {2021 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Li, Ziyang and Machiry, Aravind and Chen, Binghong and Naik, Mayur and Wang, Ke and Song, Le},
  year = {2021},
  month = may,
  pages = {1400--1415},
  issn = {2375-1207},
  doi = {10.1109/SP40001.2021.00090},
  abstract = {Software APIs exhibit rich diversity and complexity which not only renders them a common source of programming errors but also hinders program analysis tools for checking them. Such tools either expect a precise API specification, which requires program analysis expertise, or presume that correct API usages follow simple idioms that can be automatically mined from code, which suffers from poor accuracy. We propose a new approach that allows regular programmers to find API misuses. Our approach interacts with the user to classify valid and invalid usages of each target API method. It minimizes user burden by employing an active learning algorithm that ranks API usages by their likelihood of being invalid. We implemented our approach in a tool called ARBITRAR for C/C++ programs, and applied it to check the uses of 18 API methods in 21 large real-world programs, including OpenSSL and Linux Kernel. Within just 3 rounds of user interaction on average per API method, ARBITRAR found 40 new bugs, with patches accepted for 18 of them. Moreover, ARBITRAR finds all known bugs reported by a state-of-the-art tool APISAN in a benchmark suite comprising 92 bugs with a false positive rate of only 51.5\% compared to APISAN's 87.9\%.},
  keywords = {Classification algorithms,Computer bugs,Linux,Privacy,Programming,Software,Tools},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TPZRQAKE\\Li et al. - 2021 - ARBITRAR User-Guided API Misuse Detection.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\8GERGMUN\\9519443.html}
}

@inproceedings{li2021mirchecker,
  title = {{{MirChecker}}: {{Detecting Bugs}} in {{Rust Programs}} via {{Static Analysis}}},
  shorttitle = {{{MirChecker}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Li, Zhuohua and Wang, Jincheng and Sun, Mingshen and Lui, John C.S.},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {2183--2196},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484541},
  abstract = {Safe system programming is often a crucial requirement due to its critical role in system software engineering. Conventional low-level programming languages such as C and assembly are efficient, but their inherent unsafe nature makes it undesirable for security-critical scenarios. Recently, Rust has become a promising alternative for safe system-level programming. While giving programmers fine-grained hardware control, its strong type system enforces many security properties including memory safety. However, Rust's security guarantee is not a silver bullet. Runtime crashes and memory-safety errors still harass Rust developers, causing damaging exploitable vulnerabilities, as reported by numerous studies. In this paper, we present and evaluate MirChecker, a fully automated bug detection framework for Rust programs by performing static analysis on Rust's Mid-level Intermediate Representation (MIR). Based on the observation of existing bugs found in Rust codebases, our approach keeps track of both numerical and symbolic information, detects potential runtime crashes and memory-safety errors by using constraint solving techniques, and outputs informative diagnostics to users. We evaluate MirChecker on both buggy code snippets extracted from existing Common Vulnerabilities and Exposures (CVE) and real-world Rust codebases. Our experiments show that MirChecker can detect all the issues in our code snippets, and is capable of performing bug finding in real-world scenarios, where it detected a total of 33 previously unknown bugs including 16 memory-safety issues from 12 Rust packages (crates) with an acceptable false-positive rate.},
  isbn = {978-1-4503-8454-4},
  keywords = {abstract interpretation,rust,static analysis},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8JVZYQE3\\Li et al. - 2021 - MirChecker Detecting Bugs in Rust Programs via St.pdf}
}

@inproceedings{li2022detecting,
  title = {Detecting {{Cross-language Memory Management Issues}} in~{{Rust}}},
  booktitle = {Computer {{Security}} \textendash{} {{ESORICS}} 2022},
  author = {Li, Zhuohua and Wang, Jincheng and Sun, Mingshen and Lui, John C. S.},
  editor = {Atluri, Vijayalakshmi and Di Pietro, Roberto and Jensen, Christian D. and Meng, Weizhi},
  year = {2022},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {680--700},
  publisher = {{Springer Nature Switzerland}},
  address = {{Cham}},
  doi = {10.1007/978-3-031-17143-7_33},
  abstract = {Rust is a promising system-level programming language that can prevent memory corruption bugs using its strong type system and ownership-based memory management scheme. In practice, programmers usually write Rust code in conjunction with other languages such as C/C++ through Foreign Function Interface (FFI). For example, many notable projects are developed using Rust and other programming languages, such as Firefox, Google Fuchsia OS, and the Linux kernel. Although it is widely believed that gradually re-implementing security-critical components in Rust is a way of enhancing software security, however, using FFI is inherently unsafe. In this paper, we show that memory management across the FFI boundaries is error-prone. Any incorrect use of FFI may corrupt Rust's ownership system, leading to memory safety issues. To tackle this problem, we design and build FFIChecker, an automated static analysis and bug detection tool dedicated to memory management issues across the Rust/C FFI. We evaluate our tool by checking 987 Rust packages crawled from the official package registry and reveal 34 bugs in 12 packages. Our experiments show that FFIChecker is a useful tool to detect real-world cross-language memory management issues with a reasonable amount of computational resources.},
  isbn = {978-3-031-17143-7},
  langid = {english},
  keywords = {Bug detection,Rust,Static analysis},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-10-28]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SPLLRYNF\\Li et al. - 2022 - Detecting Cross-language Memory Management Issues .pdf}
}

@misc{li2022pacsan,
  title = {{{PACSan}}: {{Enforcing Memory Safety Based}} on {{ARM PA}}},
  shorttitle = {{{PACSan}}},
  author = {Li, Yuan and Tan, Wende and Lv, Zhizheng and Yang, Songtao and Payer, Mathias and Liu, Ying and Zhang, Chao},
  year = {2022},
  month = feb,
  number = {arXiv:2202.03950},
  eprint = {2202.03950},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  abstract = {Memory safety is a key security property that stops memory corruption vulnerabilities. Existing sanitizers enforce checks and catch such bugs during development and testing. However, they either provide partial memory safety or have overwhelmingly high performance overheads.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {68M25,Computer Science - Cryptography and Security,D.2.5,pac,pointer authentication},
  annotation = {1 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\V5Y8KNLJ\\Li et al. - 2022 - PACSan Enforcing Memory Safety Based on ARM PA.pdf}
}

@inproceedings{li2022polycruise,
  title = {\{\vphantom\}{{PolyCruise}}\vphantom\{\}: {{A}} \{\vphantom\}{{Cross-Language}}\vphantom\{\} {{Dynamic Information Flow Analysis}}},
  shorttitle = {\{\vphantom\}{{PolyCruise}}\vphantom\{\}},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {Li, Wen and Ming, Jiang and Luo, Xiapu and Cai, Haipeng},
  year = {2022},
  pages = {2513--2530},
  isbn = {978-1-939133-31-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\I2ZTH4PE\\Li et al. - 2022 - PolyCruise A Cross-Language Dynamic Informati.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\6MWQHMBL\\li-wen.html}
}

@inproceedings{li2022systematic,
  title = {A {{Systematic Look}} at {{Ciphertext Side Channels}} on {{AMD SEV-SNP}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Li, Mengyuan and Wilke, Luca and Wichelmann, Jan and Eisenbarth, Thomas and Teodorescu, Radu and Zhang, Yinqian},
  year = {2022},
  month = apr,
  pages = {1541--1541},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00112},
  abstract = {Hardware-assisted memory encryption offers strong confidentiality guarantees for trusted execution environments like Intel SGX and AMD SEV. However, a recent study by Li et al. presented at USENIX Security 2021 has demonstrated the CipherLeaks attack, which monitors ciphertext changes in the special VMSA page. By leaking register values saved by the VM during context switches, they broke state-of-the-art constant- time cryptographic implementations, including RSA and ECDSA in the OpenSSL. In this paper, we perform a comprehensive study on the cipher-text side channels. Our work suggests that while the CipherLeaks attack targets only the VMSA page, a generic ciphertext side-channel attack may exploit the ciphertext leakage from any memory pages, including those for kernel data structures, stacks and heaps. As such, AMD's existing countermeasures to the CipherLeaks attack, a firmware patch that introduces randomness into the ciphertext of the VMSA page, is clearly insufficient. The root cause of the leakage in AMD SEV's memory encryption\textemdash the use of a stateless yet unauthenticated encryption mode and the unrestricted read accesses to the ciphertext of the encrypted memory\textemdash remains unfixed. Given the challenges faced by AMD to eradicate the vulnerability from the hardware design, we propose a set of software countermeasures to the ciphertext side channels, including patches to the OS kernel and cryptographic libraries. We are working closely with AMD to merge these changes into affected open-source projects},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\J9BM3C4G\\1CIO7MTBnri.html}
}

@inproceedings{liang2021pata,
  title = {{{PATA}}: {{Fuzzing}} with {{Path Aware Taint Analysis}}},
  shorttitle = {{{PATA}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Liang, Jie and Wang, Mingzhe and Zhou, Chijin and Wu, Zhiyong and Jiang, Yu and Liu, Jianzhong and Liu, Zhe and Sun, Jiaguang},
  year = {2021},
  month = sep,
  pages = {154--170},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00010},
  abstract = {Taint analysis assists fuzzers in solving complex fuzzing constraints by inferring the influencing input bytes. Execution paths in real-world programs often reach loops, where constraints in these loops can be visited and recorded multiple times. Conventional taint analysis techniques experience difficulties when distinguishing between multiple occurrences of the same constraint. In this paper, we propose PATA, a fuzzer that implements path-aware taint analysis, i.e. one that distinguishes between multiple occurrences of the same variable based on the execution path information. PATA does so using the following steps. First, PATA identifies variables used in constraints and constructs the Representative Variable Sequence (RVS), consisting of occurrences of all representative constraint variables and their values. Next, PATA perturbs the input, matches its RVS with that of the original input, and looks for value changes to identify the influencing input bytes for each entry in the RVS. Finally, PATA mutates the corresponding input bytes to solve constraints in the given path. To demonstrate the effectiveness of PATA over conventional taint analysis methods, we evaluated its performance on the benchmarks Google's fuzzer-test-suite and LAVA-M against AFL, MOPT, TortoriseFuzz, VUzzer, Angora, REDQUEEN, and GREYONE. On Google's fuzzer-test-suite, PATA outperformed these state-of-the-art fuzzers by 29\%\textendash 1830\% and 7\%\textendash 87\% in the number of unique paths found and basic blocks covered, respectively. More importantly, it found more bugs than the comparison fuzzers, including 17 unlisted ones. On LAVA-M, PATA performed the best out of all evaluated fuzzers and found 2602 bugs. On open-source projects, PATA found 40 previously unknown bugs, with 12 of them confirmed as CVEs.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\E7Z66I6A\\1wKCe9rJFfi.html}
}

@inproceedings{liljestrand2019pac,
  title = {{{PAC}} It up: {{Towards Pointer Integrity}} Using {{ARM Pointer Authentication}}},
  shorttitle = {\{\vphantom\}{{PAC}}\vphantom\{\} It Up},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Liljestrand, Hans and Nyman, Thomas and Wang, Kui and Perez, Carlos Chinea and Ekberg, Jan-Erik and Asokan, N.},
  year = {2019},
  pages = {177--194},
  isbn = {978-1-939133-06-9},
  langid = {english},
  keywords = {pac,poiner authentication},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\846HXT8E\\Liljestrand et al. - 2019 - PAC it up Towards Pointer Integrity using ARM .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\G6U57HE2\\liljestrand.html}
}

@inproceedings{liljestrand2021pacstack,
  title = {{{PACStack}}: An {{Authenticated Call Stack}}},
  shorttitle = {\{\vphantom\}{{PACStack}}\vphantom\{\}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Liljestrand, Hans and Nyman, Thomas and Gunn, Lachlan J. and Ekberg, Jan-Erik and Asokan, N.},
  year = {2021},
  pages = {357--374},
  isbn = {978-1-939133-24-3},
  langid = {english},
  keywords = {pac,pointer authentication},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\K3IJIP8S\\Liljestrand et al. - 2021 - PACStack an Authenticated Call Stack.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\967VE46A\\liljestrand.html}
}

@misc{liljestrand2022color,
  title = {Color {{My World}}: {{Deterministic Tagging}} for {{Memory Safety}}},
  shorttitle = {Color {{My World}}},
  author = {Liljestrand, Hans and Chinea, Carlos and {Denis-Courmont}, R{\'e}mi and Ekberg, Jan-Erik and Asokan, N.},
  year = {2022},
  month = apr,
  number = {arXiv:2204.03781},
  eprint = {2204.03781},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2204.03781},
  abstract = {Hardware-assisted memory protection features are increasingly being deployed in COTS processors. ARMv8.5 Memory Tagging Extensions (MTE) is a recent example, which has been used to provide probabilistic checks for memory safety. This use of MTE is not secure against the standard adversary with arbitrary read/write access to memory. Consequently MTE is used as a software development tool. In this paper we present the first design for deterministic memory protection using MTE that can resist the standard adversary, and hence is suitable for post-deployment memory safety. We describe our compiler extensions for LLVM Clang implementing static analysis and subsequent MTE instrumentation. Via a comprehensive evaluation we show that our scheme is effective.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security,mte},
  annotation = {0 citations (Semantic Scholar/arXiv) [2022-08-22] 0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\JNEAYV94\\Liljestrand et al. - 2022 - Color My World Deterministic Tagging for Memory S.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\8EXPHCAI\\2204.html}
}

@inproceedings{lin2021flashcube,
  title = {{{FlashCube}}: {{Fast Provisioning}} of {{Serverless Functions}} with {{Streamlined Container Runtimes}}},
  shorttitle = {{{FlashCube}}},
  booktitle = {Proceedings of the 11th {{Workshop}} on {{Programming Languages}} and {{Operating Systems}}},
  author = {Lin, Zhen and Hsieh, Kao-Feng and Sun, Yu and Shin, Seunghee and Lu, Hui},
  year = {2021},
  month = oct,
  series = {{{PLOS}} '21},
  pages = {38--45},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3477113.3487273},
  abstract = {Fast provisioning of serverless functions is salient for serverless platforms. Though lightweight sandboxes (e.g., containers) enclose only necessary files and libraries, a cold launch still requires up to a few seconds to complete. Such slow provisioning prolongs the response time of serverless functions and negatively impacts users' experiences. This paper analyzes the main reasons for such slowdown and introduces an effective containerization framework, FlashCube. Instead of building a container from scratch, FlashCube quickly and efficiently assembles it through a group of pre-created general container parts (e.g., namespaces, cgroups, and language runtimes). In addition, FlashCube's user-space implementation makes it easily applicable to existing commodity serverless platforms. Our preliminary evaluation demonstrates that FlashCube can quickly provision containerized functions in less than 10 ms (vs. \textasciitilde 400 ms using Docker containers).},
  isbn = {978-1-4503-8707-1},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\V72J5GPH\\Lin et al. - 2021 - FlashCube Fast Provisioning of Serverless Functio.pdf}
}

@inproceedings{lin2022grebe,
  title = {{{GREBE}}: {{Unveiling Exploitation Potential}} for {{Linux Kernel Bugs}}},
  shorttitle = {{{GREBE}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Lin, Zhenpeng and Chen, Yueqi and Wu, Yuhang and Mu, Dongliang and Yu, Chensheng and Xing, Xinyu and Li, Kang},
  year = {2022},
  month = may,
  pages = {2078--2095},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.9833683},
  abstract = {Nowadays, dynamic testing tools have significantly expedited the discovery of bugs in the Linux kernel. When unveiling kernel bugs, they automatically generate reports, specifying the errors the Linux encounters. The error in the report implies the possible exploitability of the corresponding kernel bug. As a result, many security analysts use the manifested error to infer a bug's exploitability and thus prioritize their exploit development effort. However, using the error in the report, security researchers might underestimate a bug's exploitability. The error exhibited in the report may depend upon how the bug is triggered. Through different paths or under different contexts, a bug may manifest various error behaviors implying very different exploitation potentials. This work proposes a new kernel fuzzing technique to explore all the possible error behaviors that a kernel bug might bring about. Unlike conventional kernel fuzzing techniques concentrating on kernel code coverage, our fuzzing technique is more directed towards the buggy code fragment. It introduces an object-driven kernel fuzzing technique to explore various contexts and paths to trigger the reported bug, making the bug manifest various error behaviors. With the newly demonstrated errors, security researchers could better infer a bug's possible exploitability. To evaluate our proposed technique's effectiveness, efficiency, and impact, we implement our fuzzing technique as a tool GREBE and apply it to 60 real-world Linux kernel bugs. On average, GREBE could manifest 2+ additional error behaviors for each of the kernel bugs. For 26 kernel bugs, GREBE discovers higher exploitation potential. We report to kernel vendors some of the bugs \textendash{} the exploitability of which was wrongly assessed and the corresponding patch has not yet been carefully applied \textendash{} resulting in their rapid patch adoption.},
  keywords = {Codes,Computer bugs,Fuzzing,Linux,OS-Security,Privacy,Security,Vulnerability-Exploitation},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\EYLDI6P2\\Lin et al. - 2022 - GREBE Unveiling Exploitation Potential for Linux .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\XE95BQCK\\9833683.html}
}

@inproceedings{lind2017glamdring,
  title = {Glamdring: {{Automatic Application Partitioning}} for {{Intel}} \{\vphantom\}{{SGX}}\vphantom\{\}},
  shorttitle = {Glamdring},
  booktitle = {2017 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 17)},
  author = {Lind, Joshua and Priebe, Christian and Muthukumaran, Divya and O'Keeffe, Dan and Aublin, Pierre-Louis and Kelbert, Florian and Reiher, Tobias and Goltzsche, David and Eyers, David and Kapitza, R{\"u}diger and Fetzer, Christof and Pietzuch, Peter},
  year = {2017},
  pages = {285--298},
  isbn = {978-1-931971-38-6},
  langid = {english},
  keywords = {compartmentalization},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ZBLBJ3JA\\Lind et al. - 2017 - Glamdring Automatic Application Partitioning for .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\WV2ZHCND\\lind.html}
}

@inproceedings{liu2017ptrsplit,
  title = {{{PtrSplit}}: {{Supporting General Pointers}} in {{Automatic Program Partitioning}}},
  shorttitle = {{{PtrSplit}}},
  booktitle = {Proceedings of the 2017 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Liu, Shen and Tan, Gang and Jaeger, Trent},
  year = {2017},
  month = oct,
  series = {{{CCS}} '17},
  pages = {2359--2371},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3133956.3134066},
  abstract = {Partitioning a security-sensitive application into least-privileged components and putting each into a separate protection domain have long been a goal of security practitioners and researchers. However, a stumbling block to automatically partitioning C/C++ applications is the presence of pointers in these applications. Pointers make calculating data dependence, a key step in program partitioning, difficult and hard to scale; furthermore, C/C++ pointers do not carry bounds information, making it impossible to automatically marshall and unmarshall pointer data when they are sent across the boundary of partitions. In this paper, we propose a set of techniques for supporting general pointers in automatic program partitioning. Our system, called PtrSplit, constructs a Program Dependence Graph (PDG) for tracking data and control dependencies in the input program and employs a parameter-tree approach for representing data of pointer types; this approach is modular and avoids global pointer analysis. Furthermore, it performs selective pointer bounds tracking to enable automatic marshalling/unmarshalling of pointer data, even when there is circularity and arbitrary aliasing. As a result, PtrSplit can automatically generate executable partitions for C applications that contain arbitrary pointers.},
  isbn = {978-1-4503-4946-8},
  keywords = {automatic program partitioning,bounds tracking,compartmentalization,compiler,data marshalling,pdg,program analysis},
  annotation = {34 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NMA6ZIJW\\Liu et al. - 2017 - PtrSplit Supporting General Pointers in Automatic.pdf}
}

@inproceedings{liu2019programmandering,
  title = {Program-Mandering: {{Quantitative Privilege Separation}}},
  shorttitle = {Program-Mandering},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Liu, Shen and Zeng, Dongrui and Huang, Yongzhe and Capobianco, Frank and McCamant, Stephen and Jaeger, Trent and Tan, Gang},
  year = {2019},
  month = nov,
  series = {{{CCS}} '19},
  pages = {1023--1040},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3319535.3354218},
  abstract = {Privilege separation is an effective technique to improve software security. However, past partitioning systems do not allow programmers to make quantitative tradeoffs between security and performance. In this paper, we describe our toolchain called PM. It can automatically find the optimal boundary in program partitioning. This is achieved by solving an integer-programming model that optimizes for a user-chosen metric while satisfying the remaining security and performance constraints on other metrics. We choose security metrics to reason about how well computed partitions enforce information flow control to: (1) protect the program from low-integrity inputs or (2) prevent leakage of program secrets. As a result, functions in the sensitive module that fall on the optimal partition boundaries automatically identify where declassification is necessary. We used PM to experiment on a set of real-world programs to protect confidentiality and integrity; results show that, with moderate user guidance, PM can find partitions that have better balance between security and performance than partitions found by a previous tool that requires manual declassification.},
  isbn = {978-1-4503-6747-9},
  keywords = {automatic program partitioning,compartmentalization,integer programming,privilege separation},
  annotation = {15 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WCC2GKJV\\Liu et al. - 2019 - Program-mandering Quantitative Privilege Separati.pdf}
}

@inproceedings{liu2020securing,
  title = {Securing Unsafe Rust Programs with {{XRust}}},
  booktitle = {Proceedings of the {{ACM}}/{{IEEE}} 42nd {{International Conference}} on {{Software Engineering}}},
  author = {Liu, Peiming and Zhao, Gang and Huang, Jeff},
  year = {2020},
  month = jun,
  series = {{{ICSE}} '20},
  pages = {234--245},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3377811.3380325},
  abstract = {Rust is a promising systems programming language that embraces both high-level memory safety and low-level resource manipulation. However, the dark side of Rust, unsafe Rust, leaves a large security hole as it bypasses the Rust type system in order to support low-level operations. Recently, several real-world memory corruption vulnerabilities have been discovered in Rust's standard libraries. We present XRust, a new technique that mitigates the security threat of unsafe Rust by ensuring the integrity of data flow from unsafe Rust code to safe Rust code. The cornerstone of XRust is a novel heap allocator that isolates the memory of unsafe Rust from that accessed only in safe Rust, and prevents any cross-region memory corruption. Our design of XRust supports both single-and multi-threaded Rust programs. Our extensive experiments on real-world Rust applications and standard libraries show that XRust is both highly efficient and effective in practice.},
  isbn = {978-1-4503-7121-6},
  annotation = {6 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3JVCVK32\\Liu et al. - 2020 - Securing unsafe rust programs with XRust.pdf}
}

@inproceedings{liu2021kubo,
  title = {{{KUBO}}: {{Precise}} and {{Scalable Detection}} of {{User-triggerable Undefined Behavior Bugs}} in {{OS Kernel}}},
  shorttitle = {{{KUBO}}},
  booktitle = {Proceedings 2021 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Liu, Changming and Chen, Yaohui and Lu, Long},
  year = {2021},
  publisher = {{Internet Society}},
  address = {{Virtual}},
  doi = {10.14722/ndss.2021.24461},
  abstract = {Undefined Behavior bugs (UB) often refer to a wide range of programming errors that mainly reside in software implemented in relatively low-level programming languages e.g., C/C++. OS kernels are particularly plagued by UB due to their close interactions with the hardware. A triggered UB can often lead to exploitation from unprivileged userspace programs and cause critical security and reliability issues inside the OS. The previous works on detecting UB in kernels had to sacrifice precision for scalability, and in turn, suffered from extremely high false positives which severely impaired their usability.},
  isbn = {978-1-891562-66-2},
  langid = {english},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\V4IR9R7Z\\Liu et al. - 2021 - KUBO Precise and Scalable Detection of User-trigg.pdf}
}

@inproceedings{lu2019where,
  title = {Where {{Does It Go}}? {{Refining Indirect-Call Targets}} with {{Multi-Layer Type Analysis}}},
  shorttitle = {Where {{Does It Go}}?},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Lu, Kangjie and Hu, Hong},
  year = {2019},
  month = nov,
  series = {{{CCS}} '19},
  pages = {1867--1881},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3319535.3354244},
  abstract = {System software commonly uses indirect calls to realize dynamic program behaviors. However, indirect-calls also bring challenges to constructing a precise control-flow graph that is a standard pre-requisite for many static program-analysis and system-hardening techniques. Unfortunately, identifying indirect-call targets is a hard problem. In particular, modern compilers do not recognize indirect-call targets by default. Existing approaches identify indirect-call targets based on type analysis that matches the types of function pointers and the ones of address-taken functions. Such approaches, however, suffer from a high false-positive rate as many irrelevant functions may share the same types. In this paper, we propose a new approach, namely Multi-Layer Type Analysis (MLTA), to effectively refine indirect-call targets for C/C++ programs. MLTA relies on an observation that function pointers are commonly stored into objects whose types have a multi-layer type hierarchy; before indirect calls, function pointers will be loaded from objects with the same type hierarchy "layer by layer". By matching the multi-layer types of function pointers and functions, MLTA can dramatically refine indirect-call targets. MLTA is effective because multi-layer types are more restrictive than single-layer types. It does not introduce false negatives by conservatively tracking targets propagation between multi-layer types, and the layered design allows MLTA to safely fall back whenever the analysis for a layer becomes infeasible. We have implemented MLTA in a system, namely TypeDive, based on LLVM and extensively evaluated it with the Linux kernel, the FreeBSD kernel, and the Firefox browser. Evaluation results show that TypeDive can eliminate 86\% to 98\% more indirect-call targets than existing approaches do, without introducing new false negatives. We also demonstrate that TypeDive not only improves the scalability of static analysis but also benefits semantic-bug detection. With TypeDive, we have found 35 new deep semantic bugs in the Linux kernel.},
  isbn = {978-1-4503-6747-9},
  keywords = {cfi,function pointers,indirect-call targets,layered type analysis},
  annotation = {34 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\AHYKH5VX\\Lu and Hu - 2019 - Where Does It Go Refining Indirect-Call Targets w.pdf}
}

@inproceedings{lyu2022efficient,
  title = {Towards Efficient Processing of Latency-Sensitive Serverless {{DAGs}} at the Edge},
  booktitle = {Proceedings of the 5th {{International Workshop}} on {{Edge Systems}}, {{Analytics}} and {{Networking}}},
  author = {Lyu, Xiaosu and Cherkasova, Ludmila and Aitken, Robert and Parmer, Gabriel and Wood, Timothy},
  year = {2022},
  month = apr,
  series = {{{EdgeSys}} '22},
  pages = {49--54},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3517206.3526274},
  abstract = {Many emerging novel applications expect "near real-time" processing and responses, which can not be guaranteed by today's Cloud and would require processing at the Edge. Serverless computing is a particularly promising architecture for edge environments since it offers to improve efficiency by precisely scaling resources to meet application needs. As the edge applications grow more complex and get composed from a subset of simpler functions or microservices, there is a need to support more complicated function topologies which can be represented as directed acyclic graphs (DAGs). However, running DAG functions on a serverless platform poses new challenges related to interconnecting, instantiating, and scheduling function sandboxes. In this paper1, we explore how Sledge, a Wasm-based serverless runtime, can be extended to support DAG functions. Sledge's unique design allows for extremely lightweight sandbox instantiation - a new sandbox can be started for each function invocation in under 30{$\mu$}sec - which mitigates the cold start problems that can be especially detrimental to DAGs. Rather than relying on expensive coordination via shared storage, the enhanced Sledge framework provides a fast memory communication channel to propagate data through the DAG. We consider the DAGs with service level objectives, defined by their execution deadlines. To ensure the DAGs meet their performance requirements, we consider, analyze, and compare two deadline-aware pluggable schedulers (that we implemented in Sledge) on a variety of realistic workloads.},
  isbn = {978-1-4503-9253-2},
  keywords = {DAGs,edge computing,serverless,SLOs,WebAssembly},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\YX9L6EED\\Lyu et al. - 2022 - Towards efficient processing of latency-sensitive .pdf}
}

@inproceedings{lyu2022goshawk,
  title = {Goshawk: {{Hunting Memory Corruptions}} via {{Structure-Aware}} and {{Object-Centric Memory Operation Synopsis}}},
  shorttitle = {Goshawk},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Lyu, Yunlong and Fang, Yi and Zhang, Yiwei and Sun, Qibin and Ma, Siqi and Bertino, Elisa and Lu, Kangjie and Li, Juanru},
  year = {2022},
  month = may,
  pages = {2096--2113},
  publisher = {{IEEE}},
  address = {{San Francisco, CA, USA}},
  doi = {10.1109/SP46214.2022.9833613},
  abstract = {Existing tools for the automated detection of memory corruption bugs are not very effective in practice. They typically recognize only standard memory management (MM) APIs (e.g., malloc and free) and assume a naive paired-use model\textemdash an allocator is followed by a specific deallocator. However, we observe that programmers very often design their own MM functions and that these functions often manifest two major characteristics: (1) Custom allocator functions perform multiobject or nested allocation which then requires structure-aware deallocation functions. (2) Custom allocators and deallocators follow an unpaired-use model. A more effective detection thus needs to adapt those characteristics and capture memory bugs related to non-standard MM behaviors.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  keywords = {bug hunting},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PFNL5DIZ\\Lyu et al. - 2022 - Goshawk Hunting Memory Corruptions via Structure-.pdf}
}

@inproceedings{machiry2017dr,
  title = {{{DR}}. {{CHECKER}}: {{A Soundy Analysis}} for {{Linux Kernel Drivers}}},
  shorttitle = {\{\vphantom\}{{DR}}\vphantom\{\}. \{\vphantom\}{{CHECKER}}\vphantom\{\}},
  booktitle = {26th {{USENIX Security Symposium}} ({{USENIX Security}} 17)},
  author = {Machiry, Aravind and Spensky, Chad and Corina, Jake and Stephens, Nick and Kruegel, Christopher and Vigna, Giovanni},
  year = {2017},
  pages = {1007--1024},
  isbn = {978-1-931971-40-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XHMVBUCK\\Machiry et al. - 2017 - DR . CHECKER A Soundy Analysis for Linux Kerne.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\VAG4GNEV\\machiry.html}
}

@article{mampage2022holistic,
  title = {A {{Holistic View}} on {{Resource Management}} in {{Serverless Computing Environments}}: {{Taxonomy}} and {{Future Directions}}},
  shorttitle = {A {{Holistic View}} on {{Resource Management}} in {{Serverless Computing Environments}}},
  author = {Mampage, Anupama and Karunasekera, Shanika and Buyya, Rajkumar},
  year = {2022},
  month = jan,
  journal = {ACM Computing Surveys},
  issn = {0360-0300},
  doi = {10.1145/3510412},
  abstract = {Serverless computing has emerged as an attractive deployment option for cloud applications in recent times. The unique features of this computing model include rapid auto-scaling, strong isolation, fine-grained billing options and access to a massive service ecosystem which autonomously handles resource management decisions. This model is increasingly being explored for deployments in geographically distributed edge and fog computing networks as well, due to these characteristics. Effective management of computing resources has always gained a lot of attention among researchers. The need to automate the entire process of resource provisioning, allocation, scheduling, monitoring and scaling, has resulted in the need for specialized focus on resource management under the serverless model. In this article, we identify the major aspects covering the broader concept of resource management in serverless environments and propose a taxonomy of elements which influence these aspects, encompassing characteristics of system design, workload attributes and stakeholder expectations. We take a holistic view on serverless environments deployed across edge, fog and cloud computing networks. We also analyse existing works discussing aspects of serverless resource management using this taxonomy. This article further identifies gaps in literature and highlights future research directions for improving capabilities of this computing model.},
  keywords = {Application Modelling,Performance Prediction,Resource Management,Resource Scaling,Resource Scheduling,Serverless Computing,Workload Characterization},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22] Just Accepted},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UV9IJSLV\\Mampage et al. - 2022 - A Holistic View on Resource Management in Serverle.pdf}
}

@inproceedings{manco2017my,
  title = {My {{VM}} Is {{Lighter}} (and {{Safer}}) than Your {{Container}}},
  booktitle = {Proceedings of the 26th {{Symposium}} on {{Operating Systems Principles}}},
  author = {Manco, Filipe and Lupu, Costin and Schmidt, Florian and Mendes, Jose and Kuenzer, Simon and Sati, Sumit and Yasukata, Kenichi and Raiciu, Costin and Huici, Felipe},
  year = {2017},
  month = oct,
  series = {{{SOSP}} '17},
  pages = {218--233},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3132747.3132763},
  abstract = {Containers are in great demand because they are lightweight when compared to virtual machines. On the downside, containers offer weaker isolation than VMs, to the point where people run containers in virtual machines to achieve proper isolation. In this paper, we examine whether there is indeed a strict tradeoff between isolation (VMs) and efficiency (containers). We find that VMs can be as nimble as containers, as long as they are small and the toolstack is fast enough. We achieve lightweight VMs by using unikernels for specialized applications and with Tinyx, a tool that enables creating tailor-made, trimmed-down Linux virtual machines. By themselves, lightweight virtual machines are not enough to ensure good performance since the virtualization control plane (the toolstack) becomes the performance bottleneck. We present LightVM, a new virtualization solution based on Xen that is optimized to offer fast boot-times regardless of the number of active VMs. LightVM features a complete redesign of Xen's control plane, transforming its centralized operation to a distributed one where interactions with the hypervisor are reduced to a minimum. LightVM can boot a VM in 2.3ms, comparable to fork/exec on Linux (1ms), and two orders of magnitude faster than Docker. LightVM can pack thousands of LightVM guests on modest hardware with memory and CPU usage comparable to that of processes.},
  isbn = {978-1-4503-5085-3},
  keywords = {containers,hypervisor,operating systems,specialization,unikernels,virtual machine,Virtualization,Xen},
  annotation = {203 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6Z7V3M5I\\Manco et al. - 2017 - My VM is Lighter (and Safer) than your Container.pdf}
}

@article{manes2021art,
  title = {The {{Art}}, {{Science}}, and {{Engineering}} of {{Fuzzing}}: {{A Survey}}},
  shorttitle = {The {{Art}}, {{Science}}, and {{Engineering}} of {{Fuzzing}}},
  author = {Man{\`e}s, Valentin J.M. and Han, HyungSeok and Han, Choongwoo and Cha, Sang Kil and Egele, Manuel and Schwartz, Edward J. and Woo, Maverick},
  year = {2021},
  month = nov,
  journal = {IEEE Transactions on Software Engineering},
  volume = {47},
  number = {11},
  pages = {2312--2331},
  issn = {1939-3520},
  doi = {10.1109/TSE.2019.2946563},
  abstract = {Among the many software testing techniques available today, fuzzing has remained highly popular due to its conceptual simplicity, its low barrier to deployment, and its vast amount of empirical evidence in discovering real-world software vulnerabilities. At a high level, fuzzing refers to a process of repeatedly running a program with generated inputs that may be syntactically or semantically malformed. While researchers and practitioners alike have invested a large and diverse effort towards improving fuzzing in recent years, this surge of work has also made it difficult to gain a comprehensive and coherent view of fuzzing. To help preserve and bring coherence to the vast literature of fuzzing, this paper presents a unified, general-purpose model of fuzzing together with a taxonomy of the current fuzzing literature. We methodically explore the design decisions at every stage of our model fuzzer by surveying the related literature and innovations in the art, science, and engineering that make modern-day fuzzers effective.},
  keywords = {automated software testing,Computer bugs,fuzz testing,fuzzing,Fuzzing,Security,Software security,Terminology},
  annotation = {147 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9V2HDVU7\\ManÃ¨s et al. - 2021 - The Art, Science, and Engineering of Fuzzing A Su.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\EPN78PXX\\8863940.html}
}

@inproceedings{marcelli2022how,
  title = {How {{Machine Learning Is Solving}} the {{Binary Function Similarity Problem}}},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {Marcelli, Andrea and Graziano, Mariano and {Ugarte-Pedrero}, Xabier and Fratantonio, Yanick and Mansouri, Mohamad and Balzarotti, Davide},
  year = {2022},
  pages = {2099--2116},
  isbn = {978-1-939133-31-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9ZS6AZFE\\Marcelli et al. - 2022 - How Machine Learning Is Solving the Binary Functio.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\Z9MVU5L9\\marcelli.html}
}

@inproceedings{mckee2022preventing,
  title = {Preventing {{Kernel Hacks}} with {{HAKCs}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {McKee, Derrick and Giannaris, Yianni and Ortega, Carolina and Shrobe, Howard and Payer, Mathias and Okhravi, Hamed and Burow, Nathan},
  year = {2022},
  publisher = {{Internet Society}},
  address = {{San Diego, CA, USA}},
  doi = {10.14722/ndss.2022.24026},
  abstract = {Commodity operating system kernels remain monolithic for practical and historical reasons. All kernel code shares a single address space, executes with elevated processor privileges, and has largely unhindered access to all data, including data irrelevant to the completion of a specific task. Applying the principle of least privilege, which limits available resources only to those needed to perform a particular task, to compartmentalize the kernel would realize major security gains, similar to microkernels yet without the major redesign effort. Here, we introduce a compartmentalization design, called a Hardware-Assisted Kernel Compartmentalization (HAKC), that approximates least privilege separation, while minimizing both developer effort and performance overhead. HAKC divides code and data into separate partitions, and specifies an access policy for each partition. Data is owned by a single partition, and a partition's access-control policy is enforced at runtime, preventing unauthorized data access. When a partition needs to transfer control flow to outside itself, data ownership is transferred to the target, and transferred back upon return. The HAKC design allows for isolating code and data from the rest of the kernel, without utilizing any additional Trusted Computing Base while compartmentalized code is executing. Instead, HAKC relies on hardware for enforcement.},
  isbn = {978-1-891562-74-7},
  langid = {english},
  keywords = {pac,pointer authentication},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ACHFV49W\\McKee et al. - 2022 - Preventing Kernel Hacks with HAKCs.pdf}
}

@inproceedings{mera2022dbox,
  title = {D-{{Box}}: {{DMA-enabled Compartmentalization}} for {{Embedded Applications}}},
  shorttitle = {D-{{Box}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Mera, Alejandro and Chen, Yi Hui and Sun, Ruimin and Kirda, Engin and Lu, Long},
  year = {2022},
  eprint = {2201.05199},
  eprinttype = {arxiv},
  primaryclass = {cs},
  doi = {10.14722/ndss.2022.24053},
  abstract = {Embedded and Internet-of-Things (IoT) devices have seen an increase in adoption in many domains. The security of these devices is of great importance as they are often used to control critical infrastructure, medical devices, and vehicles. Existing solutions to isolate microcontroller (MCU) resources in order to increase their security face significant challenges such as specific hardware unavailability, Memory Protection Unit (MPU) limitations and a significant lack of Direct Memory Access (DMA) support. Nevertheless, DMA is fundamental for the power and performance requirements of embedded applications. In this paper, we present D-Box, a systematic approach to enable secure DMA operations for compartmentalization solutions of embedded applications using real-time operating systems (RTOS). D-Box defines a reference architecture and a workflow to protect DMA operations holistically. It provides practical methods to harden the kernel and define capability-based security policies for easy definition of DMA operations with strong security properties. We implemented a D-Box prototype for the Cortex-M3/M4 on top of the popular FreeRTOS-MPU (F-MPU). The D-Box procedures and a stricter security model enabled DMA operations, yet it exposed 41 times less ROP (return-orienting-programming) gadgets when compared with the standard F-MPU. D-Box adds only a 2\% processor overhead while reducing the power consumption of peripheral operation benchmarks by 18.2\%. The security properties and performance of D-Box were tested and confirmed on a real-world case study of a Programmable Logic Controller (PLC) application.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security},
  annotation = {1 citations (Semantic Scholar/arXiv) [2022-08-22] 1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NQLFK73V\\Mera et al. - 2022 - D-Box DMA-enabled Compartmentalization for Embedd.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\62VMUFXU\\2201.html}
}

@inproceedings{mergendahl2022crosslanguage,
  title = {Cross-{{Language Attacks}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Mergendahl, Samuel and Burow, Nathan and Okhravi, Hamed},
  year = {2022},
  publisher = {{Internet Society}},
  address = {{San Diego, CA, USA}},
  doi = {10.14722/ndss.2022.24078},
  abstract = {Memory corruption attacks against unsafe programming languages like C/C++ have been a major threat to computer systems for multiple decades. Various sanitizers and runtime exploit mitigation techniques have been shown to only provide partial protection at best. Recently developed `safe' programming languages such as Rust and Go hold the promise to change this paradigm by preventing memory corruption bugs using a strong type system and proper compile-time and runtime checks. Gradual deployment of these languages has been touted as a way of improving the security of existing applications before entire applications can be developed in safe languages. This is notable in popular applications such as Firefox and Tor. In this paper, we systematically analyze the security of multi-language applications. We show that because language safety checks in safe languages and exploit mitigation techniques applied to unsafe languages (e.g., Control-Flow Integrity) break different stages of an exploit to prevent control hijacking attacks, an attacker can carefully maneuver between the languages to mount a successful attack. In essence, we illustrate that the incompatible set of assumptions made in various languages enables attacks that are not possible in each language alone. We study different variants of these attacks and analyze Firefox to illustrate the feasibility and extent of this problem. Our findings show that gradual deployment of safe programming languages, if not done with extreme care, can indeed be detrimental to security.},
  isbn = {978-1-891562-74-7},
  langid = {english},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ISDB8T5S\\Mergendahl et al. - 2022 - Cross-Language Attacks.pdf}
}

@misc{microsoft2019control,
  title = {Control {{Flow Guard}}},
  author = {Microsoft},
  year = {2019},
  abstract = {Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.},
  howpublished = {https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard},
  langid = {american},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\Z422PM5H\\control-flow-guard.html}
}

@inproceedings{midi2017memory,
  title = {Memory {{Safety}} for {{Embedded Devices}} with {{nesCheck}}},
  booktitle = {Proceedings of the 2017 {{ACM}} on {{Asia Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Midi, Daniele and Payer, Mathias and Bertino, Elisa},
  year = {2017},
  month = apr,
  series = {{{ASIA CCS}} '17},
  pages = {127--139},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3052973.3053014},
  abstract = {Applications for TinyOS, a popular operating system for embedded systems and wireless sensor networks, are written in nesC, a C dialect prone to the same type and memory safety vulnerabilities as C. While availability and integrity are critical requirements, the distributed and concurrent nature of such applications, combined with the intrinsic unsafety of the language, makes those security goals hard to achieve. Traditional memory safety techniques cannot be applied, due to the strict platform constraints and hardware differences of embedded systems. We design nesCheck, an approach that combines static analysis and dynamic checking to automatically enforce memory safety on nesC programs without requiring source modifications. nesCheck analyzes the source code, identifies the minimal conservative set of vulnerable pointers, finds static memory bugs, and instruments the code with the required dynamic runtime checks. Our prototype extends the existing TinyOS compiler toolchain with LLVM-based passes. Our evaluation shows that nesCheck effectively and efficiently enforces memory protection, catching all memory errors with an overhead of 0.84\% on energy, 5.3\% on code size, up to 8.4\% on performance, and 16.7\% on RAM.},
  isbn = {978-1-4503-4944-4},
  keywords = {instrumentation,memory safety,nesC,static analysis,wireless sensor networks},
  annotation = {22 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7G4I2NJ6\\Midi et al. - 2017 - Memory Safety for Embedded Devices with nesCheck.pdf}
}

@inproceedings{milburn2021mitigating,
  title = {Mitigating {{Information Leakage Vulnerabilities}} with {{Type-based Data Isolation}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Milburn, Alyssa and van der Kouwe, Erik and Giuffrida, Cristiano},
  year = {2021},
  month = sep,
  pages = {259--275},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00016},
  abstract = {Information leakage vulnerabilities (or simply info leaks) such as out-of-bounds/uninitialized reads in the architectural or speculative domain pose a significant security threat, allowing attackers to leak sensitive data such as crypto keys. At the same time, such vulnerabilities are hard to efficiently mitigate, as every (even speculative) memory load operation needs to be potentially instrumented against unauthorized reads. Existing confidentiality-preserving solutions based on data isolation label memory objects with different (e.g., sensitive vs. nonsensitive) colors, color load operations accordingly using static points-to analysis, and instrument them to enforce color-matching invariants at run time. Unfortunately, the reliance on conservative points-to analysis introduces overapproximations that are detrimental to security (or further degrade performance). In this paper, we propose Type-based Data Isolation (TDI), a new practical design point in the data isolation space to mitigate info leaks. TDI isolates memory objects of different colors in separate memory arenas and uses efficient compiler instrumentation to constrain loads to the arena of the intended color by construction. TDI's arena-based design moves the instrumentation from loads to pointer arithmetic operations, enabling new aggressive speculation-aware performance optimizations and eliminating the need for points-to analysis. Moreover, TDI's color management is flexible. TDI can support a few-color scheme with sensitive data annotations similar to prior work (e.g., 2 colors) or a many-color scheme based on basic type analysis (i.e., one color per object type). The latter approach provides fine-grained data isolation, eliminates the need for annotations, and enforces strong color-matching invariants equivalent to ideal (context-sensitive) type-based points-to analysis. Our results show that TDI can efficiently support such strong security invariants, at average performance overheads of {$<$}10\% on SPEC CPU2006 and nginx.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KHTWXH79\\1wKCegS92dW.html}
}

@article{milburnmitigating,
  title = {Mitigating {{Information Leakage Vulnerabilities}} with {{Type-based Data Isolation}}},
  author = {Milburn, Alyssa},
  pages = {17},
  abstract = {Information leakage vulnerabilities (or simply info leaks) such as out-of-bounds/uninitialized reads in the architectural or speculative domain pose a significant security threat, allowing attackers to leak sensitive data such as crypto keys. At the same time, such vulnerabilities are hard to efficiently mitigate, as every (even speculative) memory load operation needs to be potentially instrumented against unauthorized reads. Existing confidentiality-preserving solutions based on data isolation label memory objects with different (e.g., sensitive vs. nonsensitive) colors, color load operations accordingly using static pointsto analysis, and instrument them to enforce color-matching invariants at run time. Unfortunately, the reliance on conservative points-to analysis introduces overapproximations that are detrimental to security (or further degrade performance).},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\VQGW4AA9\\Milburn - Mitigating Information Leakage Vulnerabilities wit.pdf}
}

@inproceedings{mishra2020saffire,
  title = {Saffire: {{Context-sensitive Function Specialization}} against {{Code Reuse Attacks}}},
  shorttitle = {Saffire},
  booktitle = {2020 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Mishra, Shachee and Polychronakis, Michalis},
  year = {2020},
  month = sep,
  pages = {17--33},
  doi = {10.1109/EuroSP48549.2020.00010},
  abstract = {The sophistication and complexity of recent exploitation techniques, which rely on memory disclosure and whole-function reuse to bypass address space layout randomization and control flow integrity, is indicative of the effect that the combination of exploit mitigations has in challenging the construction of reliable exploits. In addition to software diversification and control flow enforcement, recent efforts have focused on the complementary approach of code and API specialization to restrict further the critical operations that an attacker can perform as part of a code reuse exploit. In this paper we propose Saffire, a compiler-level defense against code reuse attacks. For each calling context of a critical function, Saffire creates a specialized and hardened replica of the function with a restricted interface that can accommodate only that particular invocation. This is achieved by applying staticargumentbinding, to eliminate arguments with static values and concretize them within the function body, and dynamicargumentbinding, which applies a narrow-scope form of data flow integrity to restrict the acceptable values of arguments that cannot be statically derived. We have implemented Saffire on top of LLVM, and applied it to a set of 11 applications, including Nginx, Firefox, and Chrome. The results of our experimental evaluation with a set of 17 real-world ROP exploits and three whole-function reuse exploits demonstrate the effectiveness of Saffire in preventing these attacks while incurring a negligible runtime overhead.},
  keywords = {Complexity theory,Layout,Libraries,return into libc,Return Oriented Programming,Runtime,Software,software debloating,Software reliability,Transforms},
  annotation = {7 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\F9NCYK47\\Mishra and Polychronakis - 2020 - Saffire Context-sensitive Function Specialization.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\99DELD8M\\9230416.html}
}

@article{moghimi2017cachezoom,
  title = {{{CacheZoom}}: {{How SGX Amplifies The Power}} of {{Cache Attacks}}},
  shorttitle = {{{CacheZoom}}},
  author = {Moghimi, Ahmad and Irazoqui, Gorka and Eisenbarth, Thomas},
  year = {2017},
  month = aug,
  journal = {arXiv:1703.06986 [cs]},
  eprint = {1703.06986},
  eprinttype = {arxiv},
  primaryclass = {cs},
  abstract = {In modern computing environments, hardware resources are commonly shared, and parallel computation is widely used. Parallel tasks can cause privacy and security problems if proper isolation is not enforced. Intel proposed SGX to create a trusted execution environment within the processor. SGX relies on the hardware, and claims runtime protection even if the OS and other software components are malicious. However, SGX disregards side-channel attacks. We introduce a powerful cache side-channel attack that provides system adversaries a high resolution channel. Our attack tool named CacheZoom is able to virtually track all memory accesses of SGX enclaves with high spatial and temporal precision. As proof of concept, we demonstrate AES key recovery attacks on commonly used implementations including those that were believed to be resistant in previous scenarios. Our results show that SGX cannot protect critical data sensitive computations, and efficient AES key recovery is possible in a practical environment. In contrast to previous works which require hundreds of measurements, this is the first cache side-channel attack on a real system that can recover AES keys with a minimal number of measurements. We can successfully recover AES keys from T-Table based implementations with as few as ten measurements.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Cryptography and Security,side channel attacks},
  annotation = {228 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UV72G8UI\\Moghimi et al. - 2017 - CacheZoom How SGX Amplifies The Power of Cache At.pdf}
}

@inproceedings{mohan2015opaque,
  title = {Opaque {{Control-Flow Integrity}}},
  booktitle = {Proceedings 2015 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Mohan, Vishwath and Larsen, Per and Brunthaler, Stefan and Hamlen, Kevin W. and Franz, Michael},
  year = {2015},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2015.23271},
  abstract = {A new binary software randomization and ControlFlow Integrity (CFI) enforcement system is presented, which is the first to efficiently resist code-reuse attacks launched by informed adversaries who possess full knowledge of the inmemory code layout of victim programs. The defense mitigates a recent wave of implementation disclosure attacks, by which adversaries can exfiltrate in-memory code details in order to prepare code-reuse attacks (e.g., Return-Oriented Programming (ROP) attacks) that bypass fine-grained randomization defenses. Such implementation-aware attacks defeat traditional fine-grained randomization by undermining its assumption that the randomized locations of abusable code gadgets remain secret. Opaque CFI (O-CFI) overcomes this weakness through a novel combination of fine-grained code-randomization and coarsegrained control-flow integrity checking. It conceals the graph of hijackable control-flow edges even from attackers who can view the complete stack, heap, and binary code of the victim process. For maximal efficiency, the integrity checks are implemented using instructions that will soon be hardware-accelerated on commodity x86-x64 processors. The approach is highly practical since it does not require a modified compiler and can protect legacy binaries without access to source code. Experiments using our fully functional prototype implementation show that O-CFI provides significant probabilistic protection against ROP attacks launched by adversaries with complete code layout knowledge, and exhibits only 4.7\% mean performance overhead on current hardware (with further overhead reductions to follow on forthcoming Intel processors).},
  isbn = {978-1-891562-38-9},
  langid = {english},
  annotation = {150 citations (Semantic Scholar/DOI) [2022-10-26]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\APEJALJ2\\Mohan et al. - 2015 - Opaque Control-Flow Integrity.pdf}
}

@inproceedings{nagarakatte2010cets,
  title = {{{CETS}}: Compiler Enforced Temporal Safety for {{C}}},
  shorttitle = {{{CETS}}},
  booktitle = {Proceedings of the 2010 International Symposium on {{Memory}} Management},
  author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
  year = {2010},
  month = jun,
  series = {{{ISMM}} '10},
  pages = {31--40},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1806651.1806657},
  abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees, are a prevalent source of software bugs in unmanaged languages such as C. Existing schemes that attempt to retrofit temporal safety for such languages have high runtime overheads and/or are incomplete, thereby limiting their effectiveness as debugging aids. This paper presents CETS, a compile-time transformation for detecting all violations of temporal safety in C programs. Inspired by existing approaches, CETS maintains a unique identifier with each object, associates this metadata with the pointers in a disjoint metadata space to retain memory layout compatibility, and checks that the object is still allocated on pointer dereferences. A formal proof shows that this is sufficient to provide temporal safety even in the presence of arbitrary casts if the program contains no spatial safety violations. Our CETS prototype employs both temporal check removal optimizations and traditional compiler optimizations to achieve a runtime overhead of just 48\% on average. When combined with a spatial-checking system, the average overall overhead is 116\% for complete memory safety},
  isbn = {978-1-4503-0054-4},
  keywords = {c,dangling pointers,memory safety,temporal errors},
  annotation = {325 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RW2TJNS8\\Nagarakatte et al. - 2010 - CETS compiler enforced temporal safety for C.pdf}
}

@inproceedings{nagy2021breaking,
  title = {Breaking {{Through Binaries}}: {{Compiler-quality Instrumentation}} for {{Better Binary-only Fuzzing}}},
  shorttitle = {Breaking {{Through Binaries}}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Nagy, Stefan and {Nguyen-Tuong}, Anh and Hiser, Jason D. and Davidson, Jack W. and Hicks, Matthew},
  year = {2021},
  pages = {1683--1700},
  isbn = {978-1-939133-24-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\47L2NHRD\\Nagy et al. - 2021 - Breaking Through Binaries Compiler-quality Instru.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\Q5PHDBPG\\nagy.html}
}

@inproceedings{nam2019framer,
  title = {{{FRAMER}}: A Tagged-Pointer Capability System with Memory Safety Applications},
  shorttitle = {{{FRAMER}}},
  booktitle = {Proceedings of the 35th {{Annual Computer Security Applications Conference}}},
  author = {Nam, Myoung Jin and Akritidis, Periklis and Greaves, David J},
  year = {2019},
  month = dec,
  pages = {612--626},
  publisher = {{ACM}},
  address = {{San Juan Puerto Rico USA}},
  doi = {10.1145/3359789.3359799},
  abstract = {Security mechanisms for systems programming languages, such as fine-grained memory protection for C/C++, authorize operations at runtime using access rights associated with objects and pointers. The cost of such fine-grained capability-based security models is dominated by metadata updates and lookups, making efficient metadata management the key for minimizing performance impact. Existing approaches reduce metadata management overheads by sacrificing precision, breaking binary compatibility by changing object memory layout, or wasting space with excessive alignment or large shadow memory spaces.},
  isbn = {978-1-4503-7628-0},
  langid = {english},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KJFMKWEY\\Nam et al. - 2019 - FRAMER a tagged-pointer capability system with me.pdf}
}

@inproceedings{narayan2020retrofitting,
  title = {Retrofitting {{Fine Grain Isolation}} in the {{Firefox Renderer}}},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Narayan, Shravan and Disselkoen, Craig and Garfinkel, Tal and Froyd, Nathan and Rahm, Eric and Lerner, Sorin and Shacham, Hovav and Stefan, Deian},
  year = {2020},
  pages = {699--716},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\83NFM679\\Narayan et al. - 2020 - Retrofitting Fine Grain Isolation in the Firefox R.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\9M7TA5R2\\narayan.html}
}

@inproceedings{narayanan2020redleaf,
  title = {{{RedLeaf}}: {{Isolation}} and {{Communication}} in a {{Safe Operating System}}},
  shorttitle = {\{\vphantom\}{{RedLeaf}}\vphantom\{\}},
  booktitle = {14th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 20)},
  author = {Narayanan, Vikram and Huang, Tianjiao and Detweiler, David and Appel, Dan and Li, Zhaofeng and Zellweger, Gerd and Burtsev, Anton},
  year = {2020},
  pages = {21--39},
  isbn = {978-1-939133-19-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\444KR5WH\\Narayanan et al. - 2020 - RedLeaf Isolation and Communication in a Safe O.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\W5VIPZLK\\narayanan-vikram.html}
}

@inproceedings{nguyen2020binarylevel,
  title = {Binary-Level {{Directed Fuzzing}} for {{Use-After-Free Vulnerabilities}}},
  booktitle = {23rd {{International Symposium}} on {{Research}} in {{Attacks}}, {{Intrusions}} and {{Defenses}} ({{RAID}} 2020)},
  author = {Nguyen, Manh-Dung and Bardin, S{\'e}bastien and Bonichon, Richard and Groz, Roland and Lemerre, Matthieu},
  year = {2020},
  pages = {47--62},
  isbn = {978-1-939133-18-2},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MYZWZS9S\\Nguyen et al. - 2020 - Binary-level Directed Fuzzing for Use-After-Free .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\RAYK4RVK\\nguyen.html}
}

@inproceedings{nider2021case,
  title = {A {{Case Study}} of {{Processing-in-Memory}} in off-the-{{Shelf Systems}}},
  booktitle = {2021 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 21)},
  author = {Nider, Joel and Mustard, Craig and Zoltan, Andrada and Ramsden, John and Liu, Larry and Grossbard, Jacob and Dashti, Mohammad and Jodin, Romaric and Ghiti, Alexandre and Chauzi, Jordi and Fedorova, Alexandra},
  year = {2021},
  pages = {117--130},
  isbn = {978-1-939133-23-6},
  langid = {english},
  keywords = {pim,upmem},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\DPQUN6Q6\\Nider et al. - 2021 - A Case Study of Processing-in-Memory in off-the.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7PTHPNXF\\nider.html}
}

@inproceedings{nienhuis2020rigorous,
  title = {Rigorous Engineering for Hardware Security: {{Formal}} Modelling and Proof in the {{CHERI}} Design and Implementation Process},
  shorttitle = {Rigorous Engineering for Hardware Security},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Nienhuis, Kyndylan and Joannou, Alexandre and Bauereiss, Thomas and Fox, Anthony and Roe, Michael and Campbell, Brian and Naylor, Matthew and Norton, Robert M. and Moore, Simon W. and Neumann, Peter G. and Stark, Ian and Watson, Robert N. M. and Sewell, Peter},
  year = {2020},
  month = may,
  pages = {1003--1020},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00055},
  abstract = {The root causes of many security vulnerabilities include a pernicious combination of two problems, often regarded as inescapable aspects of computing. First, the protection mechanisms provided by the mainstream processor architecture and C/C++ language abstractions, dating back to the 1970s and before, provide only coarse-grain virtual-memory-based protection. Second, mainstream system engineering relies almost exclusively on test-and-debug methods, with (at best) prose specifications. These methods have historically sufficed commercially for much of the computer industry, but they fail to prevent large numbers of exploitable bugs, and the security problems that this causes are becoming ever more acute.In this paper we show how more rigorous engineering methods can be applied to the development of a new security-enhanced processor architecture, with its accompanying hardware implementation and software stack. We use formal models of the complete instruction-set architecture (ISA) at the heart of the design and engineering process, both in lightweight ways that support and improve normal engineering practice - as documentation, in emulators used as a test oracle for hardware and for running software, and for test generation - and for formal verification. We formalise key intended security properties of the design, and establish that these hold with mechanised proof. This is for the same complete ISA models (complete enough to boot operating systems), without idealisation.We do this for CHERI, an architecture with hardware capabilities that supports fine-grained memory protection and scalable secure compartmentalisation, while offering a smooth adoption path for existing software. CHERI is a maturing research architecture, developed since 2010, with work now underway on an Arm industrial prototype to explore its possible adoption in mass-market commercial processors. The rigorous engineering work described here has been an integral part of its development to date, enabling more rapid and confident experimentation, and boosting confidence in the design.},
  keywords = {Computer bugs,Hardware,Memory management,Security,Software,Testing},
  annotation = {17 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RVE55DZQ\\Nienhuis et al. - 2020 - Rigorous engineering for hardware security Formal.pdf}
}

@inproceedings{nilizadeh2019diffuzz,
  title = {{{DifFuzz}}: Differential Fuzzing for Side-Channel Analysis},
  shorttitle = {{{DifFuzz}}},
  booktitle = {Proceedings of the 41st {{International Conference}} on {{Software Engineering}}},
  author = {Nilizadeh, Shirin and Noller, Yannic and P{\u a}s{\u a}reanu, Corina S.},
  year = {2019},
  month = may,
  series = {{{ICSE}} '19},
  pages = {176--187},
  publisher = {{IEEE Press}},
  address = {{Montreal, Quebec, Canada}},
  doi = {10.1109/ICSE.2019.00034},
  abstract = {Side-channel attacks allow an adversary to uncover secret program data by observing the behavior of a program with respect to a resource, such as execution time, consumed memory or response size. Side-channel vulnerabilities are difficult to reason about as they involve analyzing the correlations between resource usage over multiple program paths. We present DifFuzz, a fuzzing-based approach for detecting side-channel vulnerabilities related to time and space. DifFuzz automatically detects these vulnerabilities by analyzing two versions of the program and using resource-guided heuristics to find inputs that maximize the difference in resource consumption between secret-dependent paths. The methodology of DifFuzz is general and can be applied to programs written in any language. For this paper, we present an implementation that targets analysis of Java programs, and uses and extends the Kelinci and AFL fuzzers. We evaluate DifFuzz on a large number of Java programs and demonstrate that it can reveal unknown side-channel vulnerabilities in popular applications. We also show that DifFuzz compares favorably against Blazer and Themis, two state-of-the-art analysis tools for finding side-channels in Java programs.},
  keywords = {dynamic analysis,fuzzing,side-channel analysis,side-channel attacks,vulnerability detection},
  annotation = {43 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5VGB7VWF\\Nilizadeh et al. - 2019 - DifFuzz differential fuzzing for side-channel ana.pdf}
}

@inproceedings{niu2015perinputa,
  title = {Per-{{Input Control-Flow Integrity}}},
  booktitle = {Proceedings of the 22nd {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Niu, Ben and Tan, Gang},
  year = {2015},
  month = oct,
  pages = {914--926},
  publisher = {{ACM}},
  address = {{Denver Colorado USA}},
  doi = {10.1145/2810103.2813644},
  abstract = {Control-Flow Integrity (CFI) is an effective approach to mitigating control-flow hijacking attacks. Conventional CFI techniques statically extract a control-flow graph (CFG) from a program and instrument the program to enforce that CFG. The statically generated CFG includes all edges for all possible inputs; however, for a concrete input, the CFG may include many unnecessary edges.},
  isbn = {978-1-4503-3832-5},
  langid = {english},
  keywords = {control-flow integrity,dynamic CFI},
  annotation = {144 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QAE83YGH\\Niu and Tan - 2015 - Per-Input Control-Flow Integrity.pdf}
}

@inproceedings{novark2010dieharder,
  title = {{{DieHarder}}: Securing the Heap},
  shorttitle = {{{DieHarder}}},
  booktitle = {Proceedings of the 17th {{ACM}} Conference on {{Computer}} and Communications Security},
  author = {Novark, Gene and Berger, Emery D.},
  year = {2010},
  month = oct,
  series = {{{CCS}} '10},
  pages = {573--584},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1866307.1866371},
  abstract = {Heap-based attacks depend on a combination of memory management error and an exploitable memory allocator. Many allocators include ad hoc countermeasures against particular exploits but their effectiveness against future exploits has been uncertain. This paper presents the first formal treatment of the impact of allocator design on security. It analyzes a range of widely-deployed memory allocators, including those used by Windows, Linux, FreeBSD and OpenBSD, and shows that they remain vulnerable to attack. It them presents DieHarder, a new allocator whose design was guided by this analysis. DieHarder provides the highest degree of security from heap-based attacks of any practical allocator of which we are aware while imposing modest performance overhead. In particular, the Firefox web browser runs as fast with DieHarder as with the Linux allocator.},
  isbn = {978-1-4503-0245-6},
  keywords = {buffer overflow,dangling pointer,dynamic memory allocation,memory errors},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6Q7VUAHY\\Novark and Berger - 2010 - DieHarder securing the heap.pdf}
}

@misc{nyman2018hardscope,
  title = {{{HardScope}}: {{Thwarting DOP}} with {{Hardware-assisted Run-time Scope Enforcement}}},
  shorttitle = {{{HardScope}}},
  author = {Nyman, Thomas and Dessouky, Ghada and Zeitouni, Shaza and Lehikoinen, Aaro and Paverd, Andrew and Asokan, N. and Sadeghi, Ahmad-Reza},
  year = {2018},
  month = mar,
  number = {arXiv:1705.10295},
  eprint = {1705.10295},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  abstract = {Widespread use of memory unsafe programming languages (e.g., C and C++) leaves many systems vulnerable to memory corruption attacks. A variety of defenses have been proposed to mitigate attacks that exploit memory errors to hijack the control flow of the code at run-time, e.g., (fine-grained) randomization or Control Flow Integrity. However, recent work on data-oriented programming (DOP) demonstrated highly expressive (Turing-complete) attacks, even in the presence of these state-of-the-art defenses. Although multiple real-world DOP attacks have been demonstrated, no efficient defenses are yet available. We propose run-time scope enforcement (RSE), a novel approach designed to efficiently mitigate all currently known DOP attacks by enforcing compile-time memory safety constraints (e.g., variable visibility rules) at run-time. We present HardScope, a proof-of-concept implementation of hardware-assisted RSE for the new RISC-V open instruction set architecture. We discuss our systematic empirical evaluation of HardScope which demonstrates that it can mitigate all currently known DOP attacks, and has a real-world performance overhead of 3.2\% in embedded benchmarks.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Cryptography and Security},
  annotation = {18 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\K6YH8GI6\\Nyman et al. - 2018 - HardScope Thwarting DOP with Hardware-assisted Ru.pdf}
}

@inproceedings{nyman2019hardscope,
  title = {{{HardScope}}: {{Hardening Embedded Systems Against Data-Oriented Attacks}}},
  shorttitle = {{{HardScope}}},
  booktitle = {2019 56th {{ACM}}/{{IEEE Design Automation Conference}} ({{DAC}})},
  author = {Nyman, Thomas and Dessouky, Ghada and Zeitouni, Shaza and Lehikoinen, Aaro and Paverd, Andrew and Asokan, N. and Sadeghi, Ahmad-Reza},
  year = {2019},
  month = jun,
  pages = {1--6},
  issn = {0738-100X},
  abstract = {Memory-unsafe programming languages like C and C++ leave many (embedded) systems vulnerable to attacks like control-flow hijacking. However, defenses against control-flow attacks, such as (fine-grained) randomization or control-flow integrity are ineffective against data-oriented attacks and more expressive Data-oriented Programming (DOP) attacks that bypass state-of-the-art defenses. We propose run-time scope enforcement (RSE), a novel approach that efficiently mitigates all currently known DOP attacks by enforcing compile-time memory safety constraints like variable visibility rules at run-time. We present Hardscope, a proof-of-concept implementation of hardware-assisted RSE for RISC-V, and show it has a low performance overhead of 3.2\% for embedded benchmarks.},
  keywords = {Hardware,Instruments,Memory management,Open source software,Program processors,Programming,Security},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\G3KFWGUU\\Nyman et al. - 2019 - HardScope Hardening Embedded Systems Against Data.pdf}
}

@inproceedings{orenbach2019cosmix,
  title = {{{CoSMIX}}: {{A Compiler-based System}} for {{Secure Memory Instrumentation}} and {{Execution}} in {{Enclaves}}},
  shorttitle = {\{\vphantom\}{{CoSMIX}}\vphantom\{\}},
  booktitle = {2019 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 19)},
  author = {Orenbach, Meni and Michalevsky, Yan and Fetzer, Christof and Silberstein, Mark},
  year = {2019},
  pages = {555--570},
  isbn = {978-1-939133-03-8},
  langid = {english},
  keywords = {ORAM},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7U4DWZJ8\\Orenbach et al. - 2019 - CoSMIX A Compiler-based System for Secure Memor.pdf}
}

@inproceedings{palit2021dynpta,
  title = {{{DynPTA}}: {{Combining Static}} and {{Dynamic Analysis}} for {{Practical Selective Data Protection}}},
  shorttitle = {{{DynPTA}}},
  booktitle = {2021 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Palit, Tapti and Firose Moon, Jarin and Monrose, Fabian and Polychronakis, Michalis},
  year = {2021},
  month = may,
  pages = {1919--1937},
  issn = {2375-1207},
  doi = {10.1109/SP40001.2021.00082},
  abstract = {As control flow hijacking attacks become more challenging due to the deployment of various exploit mitigation technologies, the leakage of sensitive process data through the exploitation of memory disclosure vulnerabilities is becoming an increasingly important threat. To make matters worse, recently introduced transient execution attacks provide a new avenue for leaking confidential process data. As a response, various approaches for selectively protecting subsets of critical in-memory data have been proposed, which though either require a significant code refactoring effort, or do not scale for large applications.In this paper we present DynPTA, a selective data protection approach that combines static analysis with scoped dynamic data flow tracking (DFT) to keep a subset of manually annotated sensitive data always encrypted in memory. DynPTA ameliorates the inherent overapproximation of pointer analysis\textemdash a significant challenge that has prevented previous approaches from supporting large applications\textemdash by relying on lightweight label lookups to determine if potentially sensitive data is actually sensitive. Labeled objects are tracked only within the subset of value flows that may carry potentially sensitive data, requiring only a fraction of the program's code to be instrumented for DFT. We experimentally evaluated DynPTA with real-world applications and demonstrate that it can prevent memory disclosure (Heartbleed) and transient execution (Spectre) attacks from leaking the protected data, while incurring a modest runtime overhead of up to 19.2\% when protecting the private TLS key of Nginx with OpenSSL.},
  keywords = {Data protection,Instruments,Memory management,Runtime,secret isolation,selective data protection,Sensitivity},
  annotation = {7 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7Z8CPI2W\\Palit et al. - 2021 - DynPTA Combining Static and Dynamic Analysis for .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\CXMGGWJC\\9519446.html}
}

@article{payersoftware,
  title = {Software {{Security}}},
  author = {Payer, Mathias},
  pages = {132},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GH362CXK\\Payer - Software Security.pdf}
}

@inproceedings{pewny2019steroids,
  title = {{{STEROIDS}} for {{DOPed Applications}}: {{A Compiler}} for {{Automated Data-Oriented Programming}}},
  shorttitle = {{{STEROIDS}} for {{DOPed Applications}}},
  booktitle = {2019 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {Pewny, Jannik and Koppe, Philipp and Holz, Thorsten},
  year = {2019},
  month = jun,
  pages = {111--126},
  doi = {10.1109/EuroSP.2019.00018},
  abstract = {The wide-spread adoption of system defenses such as the randomization of code, stack, and heap raises the bar for code-reuse attacks. Thus, attackers utilize a scripting engine in target programs like a web browser to prepare the code-reuse chain, e.g., relocate gadget addresses or perform a just-in-time gadget search. However, many types of programs do not provide such an execution context that an attacker can use. Recent advances in data-oriented programming (DOP) explored an orthogonal way to abuse memory corruption vulnerabilities and demonstrated that an attacker can achieve Turing-complete computations without modifying code pointers in applications. As of now, constructing DOP exploits requires a lot of manual work-for every combination of application and payload anew. In this paper, we present novel techniques to automate the process of generating DOP exploits. We implemented a compiler called STEROIDS that leverages these techniques and compiles our high-level language SLANG into low-level DOP data structures driving malicious computations at run time. This enables an attacker to specify her intent in an application-and vulnerability-independent manner to maximize reusability. We demonstrate the effectiveness of our techniques and prototype implementation by specifying four programs of varying complexity in SLANG that calculate the Levenshtein distance, traverse a pointer chain to steal a private key, relocate a ROP chain, and perform a JIT-ROP attack. STEROIDS compiles each of those programs to low-level DOP data structures targeted at five different applications including GStreamer, Wireshark and ProFTPd, which have vastly different vulnerabilities and DOP instances. Ultimately, this shows that our compiler is versatile, can be used for both 32-bit and 64-bit applications, works across bug classes, and enables highly expressive attacks without conventional code-injection or code-reuse techniques in applications lacking a scripting engine.},
  keywords = {Data structures,Data-Oriented Programming; Exploitation; Compiler; Steroids; Slang,Engines,Manuals,Payloads,Program processors,Programming,Prototypes},
  annotation = {8 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3SGRD97B\\Pewny et al. - 2019 - STEROIDS for DOPed Applications A Compiler for Au.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZLIRHPZW\\8806714.html}
}

@inproceedings{phan2017synthesis,
  title = {Synthesis of {{Adaptive Side-Channel Attacks}}},
  booktitle = {2017 {{IEEE}} 30th {{Computer Security Foundations Symposium}} ({{CSF}})},
  author = {Phan, Quoc-Sang and Bang, Lucas and Pasareanu, Corina S. and Malacaria, Pasquale and Bultan, Tevfik},
  year = {2017},
  month = aug,
  pages = {328--342},
  issn = {2374-8303},
  doi = {10.1109/CSF.2017.8},
  abstract = {We present symbolic analysis techniques for detecting vulnerabilities that are due to adaptive side-channel attacks, and synthesizing inputs that exploit the identified vulnerabilities. We start with a symbolic attack model that encodes succinctly all the side-channel attacks that an adversary can make. Using symbolic execution over this model, we generate a set of mathematical constraints, where each constraint characterizes the set of secret values that lead to the same sequence of side-channel measurements. We then compute the optimal attack, i.e, the attack that yields maximum leakage over the secret, by solving an optimization problem over the computed constraints. We use information-theoretic concepts such as channel capacity and Shannon entropy to quantify the leakage over multiple runs in the attack, where the measurements over the side channels form the observations that an adversary can use to try to infer the secret. We also propose greedy heuristics that generate the attack by exploring a portion of the symbolic attack model in each step. We implemented the techniques in Symbolic PathFinder and applied them to Java programs encoding web services, string manipulations and cryptographic functions, demonstrating how to synthesize optimal side-channel attacks.},
  keywords = {Channel capacity,Computational modeling,Cryptography,Entropy,Mathematical model,MaxSMT,Model Counting,Multi-run Security,Optimization,Quantitative Information Flow,Satisfiability Modulo Theories,Side-channel attacks,Side-Channel Attacks,Symbolic Execution},
  annotation = {51 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\C9LLMN9N\\Phan et al. - 2017 - Synthesis of Adaptive Side-Channel Attacks.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\SXKJE6QW\\8049730.html}
}

@inproceedings{proskurin2020xmp,
  title = {{{xMP}}: {{Selective Memory Protection}} for {{Kernel}} and {{User Space}}},
  shorttitle = {{{xMP}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Proskurin, Sergej and Momeu, Marius and Ghavamnia, Seyedhamed and Kemerlis, Vasileios P. and Polychronakis, Michalis},
  year = {2020},
  month = may,
  pages = {563--577},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00041},
  abstract = {Attackers leverage memory corruption vulnerabilities to establish primitives for reading from or writing to the address space of a vulnerable process. These primitives form the foundation for code-reuse and data-oriented attacks. While various defenses against the former class of attacks have proven effective, mitigation of the latter remains an open problem. In this paper, we identify various shortcomings of the x86 architecture regarding memory isolation, and leverage virtualization to build an effective defense against data-oriented attacks. Our approach, called xMP, provides (in-guest) selective memory protection primitives that allow VMs to isolate sensitive data in user or kernel space in disjoint xMP domains. We interface the Xen altp2m subsystem with the Linux memory management system, lending VMs the flexibility to define custom policies. Contrary to conventional approaches, xMP takes advantage of virtualization extensions, but after initialization, it does not require any hypervisor intervention. To ensure the integrity of in-kernel management information and pointers to sensitive data within isolated domains, xMP protects pointers with HMACs bound to an immutable context, so that integrity validation succeeds only in the right context. We have applied xMP to protect the page tables and process credentials of the Linux kernel, as well as sensitive data in various user-space applications. Overall, our evaluation shows that xMP introduces minimal overhead for real-world workloads and applications, and offers effective protection against data-oriented attacks.},
  keywords = {Kernel,Linux,Memory management,Security,Switches,Virtual machine monitors,Virtualization},
  annotation = {22 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MVIXELJ8\\Proskurin et al. - 2020 - xMP Selective Memory Protection for Kernel and Us.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\9LWT42IK\\9152671.html}
}

@inproceedings{provos2003preventing,
  title = {Preventing {{Privilege Escalation}}},
  booktitle = {12th {{USENIX Security Symposium}} ({{USENIX Security}} 03)},
  author = {Provos, Niels and Friedl, Markus and Honeyman, Peter},
  year = {2003},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IITMNVWM\\Provos et al. - 2003 - Preventing Privilege Escalation.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\9NRYT57F\\preventing-privilege-escalation.html}
}

@inproceedings{qian2019razor,
  title = {\{\vphantom\}{{RAZOR}}\vphantom\{\}: {{A Framework}} for {{Post-deployment Software Debloating}}},
  shorttitle = {\{\vphantom\}{{RAZOR}}\vphantom\{\}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Qian, Chenxiong and Hu, Hong and Alharthi, Mansour and Chung, Pak Ho and Kim, Taesoo and Lee, Wenke},
  year = {2019},
  pages = {1733--1750},
  isbn = {978-1-939133-06-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SBPYN9RI\\Qian et al. - 2019 - RAZOR A Framework for Post-deployment Software .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\HW3TUECY\\qian.html}
}

@inproceedings{qian2020slimium,
  title = {Slimium: {{Debloating}} the {{Chromium Browser}} with {{Feature Subsetting}}},
  shorttitle = {Slimium},
  booktitle = {Proceedings of the 2020 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Qian, Chenxiong and Koo, Hyungjoon and Oh, ChangSeok and Kim, Taesoo and Lee, Wenke},
  year = {2020},
  month = oct,
  series = {{{CCS}} '20},
  pages = {461--476},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3372297.3417866},
  abstract = {Today, a web browser plays a crucial role in offering a broad spectrum of web experiences. The most popular browser, Chromium, has become an extremely complex application to meet ever-increasing user demands, exposing unavoidably large attack vectors due to its large code base. Code debloating attracts attention as a means of reducing such a potential attack surface by eliminating unused code. However, it is very challenging to perform sophisticated code removal without breaking needed functionalities because Chromium operates on a large number of closely connected and complex components, such as a renderer and JavaScript engine. In this paper, we present Slimium, a debloating framework for a browser (i.e., Chromium) that harnesses a hybrid approach for a fast and reliable binary instrumentation. The main idea behind Slimium is to determine a set of features as a debloating unit on top of a hybrid (i.e., static, dynamic, heuristic) analysis, and then leverage feature subsetting to code debloating. It aids in i) focusing on security-oriented features, ii) discarding unneeded code simply without complications, and iii)\textasciitilde reasonably addressing a non-deterministic path problem raised from code complexity. To this end, we generate a feature-code map with a relation vector technique and prompt webpage profiling results. Our experimental results demonstrate the practicality and feasibility of Slimium for 40 popular websites, as on average it removes 94 CVEs (61.4\%) by cutting down 23.85 MB code (53.1\%) from defined features (21.7\% of the whole) in Chromium.},
  isbn = {978-1-4503-7089-9},
  keywords = {binary rewriting,browser,debloating,program analysis},
  annotation = {9 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SEB5YLCS\\Qian et al. - 2020 - Slimium Debloating the Chromium Browser with Feat.pdf}
}

@inproceedings{quach2019bloat,
  title = {Bloat {{Factors}} and {{Binary Specialization}}},
  booktitle = {Proceedings of the 3rd {{ACM Workshop}} on {{Forming}} an {{Ecosystem Around Software Transformation}}},
  author = {Quach, Anh and Prakash, Aravind},
  year = {2019},
  month = nov,
  series = {{{FEAST}}'19},
  pages = {31--38},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3338502.3359765},
  abstract = {Code bloating in software has been proven to be pervasive in recent research. However, each study provides a different approach to measure bloat. In this paper, we propose a system of metrics to effectively quantify bloat in binaries called bloat factors. Subsequently, we conducted an extensive study to calculate bloat factors for over 3000 Linux applications and 896 shared libraries. Using these metrics as pointers, we introduce a static approach to perform debloating for closed-source binaries by creating corresponding specialized versions to cater for a specific program requirements. We evaluated our debloating technique on large programs and achieved a maximum code reduction of 19.7\%.},
  isbn = {978-1-4503-6834-6},
  keywords = {binary analysis,debloat},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\S3QYUJMC\\Quach and Prakash - 2019 - Bloat Factors and Binary Specialization.pdf}
}

@article{ramsey2006teach,
  title = {Teach {{Technical Writing}} in {{Two Hours}} per {{Week}}},
  author = {Ramsey, Norman},
  year = {2006},
  pages = {31},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\DWXDAVGN\\Ramsey - Teach Technical Writing in Two Hours per Week.pdf}
}

@article{randalallison2020ideal,
  title = {The {{Ideal Versus}} the {{Real}}},
  author = {RandalAllison},
  year = {2020},
  month = feb,
  journal = {ACM Computing Surveys (CSUR)},
  publisher = {{ACM}},
  doi = {10.1145/3365199},
  abstract = {The common perception in both academic literature and industry today is that virtual machines offer better security, whereas containers offer better performance. However, a detailed review of the history of these technologies and the current threats ...},
  langid = {english},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22] 		PUB27 		New York, NY, USA},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NPSHG3ST\\RandalAllison - 2020 - The Ideal Versus the Real.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\YGPD4XD3\\3365199.html}
}

@inproceedings{recoules2019get,
  title = {Get {{Rid}} of {{Inline Assembly}} through {{Verification-Oriented Lifting}}},
  booktitle = {2019 34th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}} ({{ASE}})},
  author = {Recoules, Frederic and Bardin, Sebastien and Bonichon, Richard and Mounier, Laurent and Potet, Marie-Laure},
  year = {2019},
  month = nov,
  pages = {577--589},
  publisher = {{IEEE}},
  address = {{San Diego, CA, USA}},
  doi = {10.1109/ASE.2019.00060},
  abstract = {Formal methods for software development have made great strides in the last two decades, to the point that their application in safety-critical embedded software is an undeniable success. Their extension to non-critical software is one of the notable forthcoming challenges. For example, C programmers regularly use inline assembly for low-level optimizations and system primitives. This usually results in rendering state-ofthe-art formal analyzers developed for C ineffective. We thus propose TINA, the first automated, generic, verification-friendly and trustworthy lifting technique turning inline assembly into semantically equivalent C code amenable to verification, in order to take advantage of existing C analyzers. Extensive experiments on real-world code (including GMP and ffmpeg) show the feasibility and benefits of TINA.},
  isbn = {978-1-72812-508-4},
  langid = {english},
  annotation = {10 citations (Semantic Scholar/DOI) [2022-09-01]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IGIRFP2L\\Recoules et al. - 2019 - Get Rid of Inline Assembly through Verification-Or.pdf}
}

@inproceedings{recoules2021interface,
  title = {Interface {{Compliance}} of {{Inline Assembly}}: {{Automatically Check}}, {{Patch}} and {{Refine}}},
  shorttitle = {Interface {{Compliance}} of {{Inline Assembly}}},
  booktitle = {2021 {{IEEE}}/{{ACM}} 43rd {{International Conference}} on {{Software Engineering}} ({{ICSE}})},
  author = {Recoules, Fr{\'e}d{\'e}ric and Bardin, S{\'e}bastien and Bonichon, Richard and Lemerre, Matthieu and Mounier, Laurent and Potet, Marie-Laure},
  year = {2021},
  month = may,
  pages = {1236--1247},
  issn = {1558-1225},
  doi = {10.1109/ICSE43902.2021.00113},
  abstract = {Inline assembly is still a common practice in low-level C programming, typically for efficiency reasons or for accessing specific hardware resources. Such embedded assembly codes in the GNU syntax (supported by major compilers such as GCC, Clang and ICC) have an interface specifying how the assembly codes interact with the C environment. For simplicity reasons, the compiler treats GNU inline assembly codes as blackboxes and relies only on their interface to correctly glue them into the compiled C code. Therefore, the adequacy between the assembly chunk and its interface (named compliance) is of primary importance, as such compliance issues can lead to subtle and hard-to-find bugs. We propose RUSTInA, the first automated technique for formally checking inline assembly compliance, with the extra ability to propose (proven) patches and (optimization) refinements in certain cases. RUSTInA is based on an original formalization of the inline assembly compliance problem together with novel dedicated algorithms. Our prototype has been evaluated on 202 Debian packages with inline assembly (2656 chunks), finding 2183 issues in 85 packages - 986 significant issues in 54 packages (including major projects such as ffmpeg or ALSA), and proposing patches for 92\% of them. Currently, 38 patches have already been accepted (solving 156 significant issues), with positive feedback from development teams.},
  keywords = {Hardware,low level programming; inline assembly; compilation issues; program analysis,Optimization,Programming,Prototypes,Software engineering,Syntactics,Tools},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-09-01]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KW8IV6RR\\Recoules et al. - 2021 - Interface Compliance of Inline Assembly Automatic.pdf}
}

@inproceedings{rivera2021keeping,
  title = {Keeping {{Safe Rust Safe}} with {{Galeed}}},
  booktitle = {Annual {{Computer Security Applications Conference}}},
  author = {Rivera, Elijah and Mergendahl, Samuel and Shrobe, Howard and Okhravi, Hamed and Burow, Nathan},
  year = {2021},
  month = dec,
  series = {{{ACSAC}} '21},
  pages = {824--836},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3485832.3485903},
  abstract = {Rust is a programming language that simultaneously offers high performance and strong security guarantees. Safe Rust (i.e., Rust code that does not use the unsafe keyword) is memory and type safe. However, these guarantees are violated when safe Rust interacts with unsafe code, most notably code written in other programming languages, including in legacy C/C++ applications that are incrementally deploying Rust. This is a significant problem as major applications such as Firefox, Chrome, AWS, Windows, and Linux have either deployed Rust or are exploring doing so. It is important to emphasize that unsafe code is not only unsafe itself, but also it breaks the safety guarantees of `safe' Rust; e.g., a dangling pointer in a linked C/C++ library can access and overwrite memory allocated to Rust even when the Rust code is fully safe. This paper presents Galeed, a technique to keep safe Rust safe from interference from unsafe code. Galeed has two components: a runtime defense to prevent unintended interactions between safe Rust and unsafe code and a sanitizer to secure intended interactions. The runtime component works by isolating Rust's heap from any external access and is enforced using Intel Memory Protection Key (MPK) technology. The sanitizer uses a smart data structure that we call pseudo-pointer along with automated code transformation to avoid passing raw pointers across safe/unsafe boundaries during intended interactions (e.g., when Rust and C++ code exchange data). We implement and evaluate the effectiveness and performance of Galeed via micro- and macro-benchmarking, and use it to secure a widely used component of Firefox.},
  isbn = {978-1-4503-8579-4},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\YIU8SSXW\\Rivera et al. - 2021 - Keeping Safe Rust Safe with Galeed.pdf}
}

@incollection{roessler2021mscope,
  title = {{{$\mu$SCOPE}}: {{A Methodology}} for {{Analyzing Least-Privilege Compartmentalization}} in {{Large Software Artifacts}}},
  shorttitle = {{{$\mu$SCOPE}}},
  booktitle = {24th {{International Symposium}} on {{Research}} in {{Attacks}}, {{Intrusions}} and {{Defenses}}},
  author = {Roessler, Nick and Atayde, Lucas and Palmer, Imani and McKee, Derrick and Pandey, Jai and Kemerlis, Vasileios P. and Payer, Mathias and Bates, Adam and Smith, Jonathan M. and DeHon, Andre and Dautenhahn, Nathan},
  year = {2021},
  month = oct,
  pages = {296--311},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  abstract = {By prioritizing simplicity and portability, least-privilege engineering has been an afterthought in OS design, resulting in monolithic kernels where any exploit leads to total compromise. {$\mu$}SCOPE (``microscope'') addresses this problem by automatically identifying opportunities for least-privilege separation. {$\mu$}SCOPE replaces expert-driven, semi-automated analysis with a general methodology for exploring a continuum of security vs. performance design points by adopting a quantitative and systematic approach to privilege analysis. We apply the {$\mu$}SCOPE methodology to the Linux kernel by (1) instrumenting the entire kernel to gain comprehensive, fine-grained memory access and call activity; (2) mapping these accesses to semantic information; and (3) conducting separability analysis on the kernel using both quantitative privilege and overhead metrics. We discover opportunities for orders of magnitude privilege reduction while predicting relatively low overheads\textemdash at 15\% mediation overhead, overprivilege in Linux can be reduced up to 99.8\%\textemdash suggesting fine-grained privilege separation is feasible and laying the groundwork for accelerating real privilege separation.},
  isbn = {978-1-4503-9058-3},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2S2XPWFX\\Roessler et al. - 2021 - Î¼SCOPE A Methodology for Analyzing Least-Privileg.pdf}
}

@article{sangpridwen,
  title = {{{PRIDWEN}}: {{Universally Hardening SGX Programs}} via {{Load-Time Synthesis}}},
  author = {Sang, Fan and Shih, Ming-Wei and Lee, Sangho and Zhang, Xiaokuan and Steiner, Michael and Vij, Mona and Kim, Taesoo},
  pages = {17},
  abstract = {A growing class of threats to Intel Software Guard Extensions (SGX) is Side-Channel Attacks (SCAs). As a response, numerous countermeasures have been proposed. However, it is hard to incorporate them to protect SGX programs against multiple SCAs simultaneously. A na\"ive combination of distinct countermeasures does not work in practice because some of them are 1) undeployable in target environments lacking dependent hardware features, 2) redundant if there are already defenses with similar functionalities, and 3) incompatible with each other by design or implementation. Identifying all of such conditions and preparing potential workarounds before deployment are challenging, primarily when an SGX program targets multiple platforms that abstract or manipulate their configurations.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GQ5IYV7A\\Sang et al. - PRIDWEN Universally Hardening SGX Programs via Lo.pdf}
}

@inproceedings{sartakov2021cubicleos,
  title = {{{CubicleOS}}: A Library {{OS}} with Software Componentisation for Practical Isolation},
  shorttitle = {{{CubicleOS}}},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Sartakov, Vasily A. and Vilanova, Llu{\'i}s and Pietzuch, Peter},
  year = {2021},
  month = apr,
  series = {{{ASPLOS}} 2021},
  pages = {546--558},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3445814.3446731},
  abstract = {Library OSs have been proposed to deploy applications isolated inside containers, VMs, or trusted execution environments. They often follow a highly modular design in which third-party components are combined to offer the OS functionality needed by an application, and they are customised at compilation and deployment time to fit application requirements. Yet their monolithic design lacks isolation across components: when applications and OS components contain security-sensitive data (e.g., cryptographic keys or user data), the lack of isolation renders library OSs open to security breaches via malicious or vulnerable third-party components. We describe CubicleOS, a library OS that isolates components in the system while maintaining the simple, monolithic development approach of library composition. CubicleOS allows isolated components, called cubicles , to share data dynamically with other components. It provides spatial memory isolation at the granularity of function calls by using Intel MPK at user-level to isolate components. At the same time, it supports zero-copy data access across cubicles with feature-rich OS functionality. Our evaluation shows that CubicleOS introduces moderate end-to-end performance overheads in complex applications: 2\texttimes{} for the I/O-intensive NGINX web server with 8 partitions, and 1.7\textendash 8\texttimes{} for the SQLite database engine with 7 partitions.},
  isbn = {978-1-4503-8317-2},
  keywords = {compartments,Intel MPK,inter-process communication,isolation},
  annotation = {8 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\N2DH3S4W\\Sartakov et al. - 2021 - CubicleOS a library OS with software componentisa.pdf}
}

@inproceedings{sartakov2021spons,
  title = {Spons \& {{Shields}}: Practical Isolation for Trusted Execution},
  shorttitle = {Spons \& {{Shields}}},
  booktitle = {Proceedings of the 17th {{ACM SIGPLAN}}/{{SIGOPS International Conference}} on {{Virtual Execution Environments}}},
  author = {Sartakov, Vasily A. and O'Keeffe, Daniel and Eyers, David and Vilanova, Llu{\'i}s and Pietzuch, Peter},
  year = {2021},
  month = apr,
  series = {{{VEE}} 2021},
  pages = {186--200},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3453933.3454024},
  abstract = {Trusted execution environments (TEEs) promise a cost-effective, ``lift-and-shift'' solution for deploying security-sensitive applications in untrusted clouds. For this, they must support rich, multi-component applications, but a large trusted computing base (TCB) inside the TEE risks that attackers can compromise application security. Fine-grained compartmentalisation can increase security through defense-in-depth, but current solutions either run all software components unprotected in the same TEE, lack efficient shared memory support, or isolate application processes using separate TEEs, impacting performance and compatibility. We describe the Spons \& Shields framework (SSF) for Intel SGX TEEs, which offers intra-TEE compartmentalisation using two new abstraction, Spons and Shields. Spons and Shields generalise process, library and user/kernel isolation inside the TEE while allowing for efficient memory sharing. When users deploy unmodified multi-component applications in a TEE, SSF dynamically creates Spons (one per POSIX process or library) and Shields (to enforce a given security policy for memory accesses). Applications can be hardened with minor code changes, e.g., by using a separate Shield to isolate an SSL library. SSF uses compiler instrumentation to protect Shield boundaries, exploiting MPX instructions if available. We evaluate SSF using a complex application service (NGINX, PHP interpreter and PostgreSQL) and show that its overhead is comparable to process isolation.},
  isbn = {978-1-4503-8394-3},
  keywords = {compartments,isolation,SGX,trusted execution},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9TYV39IN\\Sartakov et al. - 2021 - Spons & Shields practical isolation for trusted e.pdf}
}

@inproceedings{saxena2022memory,
  title = {Memory Deduplication for Serverless Computing with {{Medes}}},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Saxena, Divyanshu and Ji, Tao and Singhvi, Arjun and Khalid, Junaid and Akella, Aditya},
  year = {2022},
  month = mar,
  series = {{{EuroSys}} '22},
  pages = {714--729},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3492321.3524272},
  abstract = {Serverless platforms today impose rigid trade-offs between resource use and user-perceived performance. Limited controls, provided via toggling sandboxes between warm and cold states and keep-alives, force operators to sacrifice significant resources to achieve good performance. We present a serverless framework, Medes, that breaks the rigid trade-off and allows operators to navigate the trade-off space smoothly. Medes leverages the fact that the warm sandboxes running on serverless platforms have a high fraction of duplication in their memory footprints. We exploit these redundant chunks to develop a new sandbox state, called a dedup state, that is more memory-efficient than the warm state and faster to restore from than the cold state. We develop novel mechanisms to identify memory redundancy at minimal overhead while ensuring that the dedup containers' memory footprint is small. Finally, we develop a simple sandbox management policy that exposes a narrow, intuitive interface for operators to trade-off performance for memory by jointly controlling warm and dedup sandboxes. Detailed experiments with a prototype using real-world serverless workloads demonstrate that Medes can provide up to 1\texttimes -2.75\texttimes{} improvements in the end-to-end latencies. The benefits of Medes are enhanced in memory pressure situations, where Medes can provide up to 3.8\texttimes{} improvements in end-to-end latencies. Medes achieves this by reducing the number of cold starts incurred by 10--50\% against the state-of-the-art baselines.},
  isbn = {978-1-4503-9162-7},
  keywords = {cloud computing,memory deduplication,serverless,virtualization},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NG22D9U9\\Saxena et al. - 2022 - Memory deduplication for serverless computing with.pdf}
}

@inproceedings{schrammel2022jenny,
  title = {Jenny: {{Securing Syscalls}} for \{\vphantom\}{{PKU-based}}\vphantom\{\} {{Memory Isolation Systems}}},
  shorttitle = {Jenny},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {Schrammel, David and Weiser, Samuel and Sadek, Richard and Mangard, Stefan},
  year = {2022},
  pages = {936--952},
  isbn = {978-1-939133-31-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\4UHPNRDH\\Schrammel et al. - 2022 - Jenny Securing Syscalls for PKU-based Memory Is.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\GS8VBLTS\\schrammel.html}
}

@article{sehr2010adapting,
  title = {Adapting {{Software Fault Isolation}} to {{Contemporary CPU Architectures}}},
  author = {Sehr, David and Muth, Robert and Schimpf, Karl and Biffle, Cliff and Khimenko, Victor and Yee, Bennet and Chen, Brad and Pasko, Egor},
  year = {2010},
  pages = {11},
  abstract = {Software Fault Isolation (SFI) is an effective approach to sandboxing binary code of questionable provenance, an interesting use case for native plugins in a Web browser. We present software fault isolation schemes for ARM and x86-64 that provide control-flow and memory integrity with average performance overhead of under 5\% on ARM and 7\% on x86-64. We believe these are the best known SFI implementations for these architectures, with significantly lower overhead than previous systems for similar architectures. Our experience suggests that these SFI implementations benefit from instruction-level parallelism, and have particularly small impact for workloads that are data memory-bound, both properties that tend to reduce the impact of our SFI systems for future CPU implementations.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WPHQVKY3\\Sehr et al. - Adapting Software Fault Isolation to Contemporary .pdf}
}

@inproceedings{seo2016flexdroid,
  title = {{{FLEXDROID}}: {{Enforcing In-App Privilege Separation}} in {{Android}}},
  shorttitle = {{{FLEXDROID}}},
  booktitle = {Proceedings 2016 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Seo, Jaebaek and Kim, Daehyeok and Cho, Donghyun and Kim, Taesoo and Shin, Insik},
  year = {2016},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2016.23485},
  abstract = {Mobile applications are increasingly integrating third-party libraries to provide various features, such as advertising, analytics, social networking, and more. Unfortunately, such integration with third-party libraries comes with the cost of potential privacy violations of users, because Android always grants a full set of permissions to third-party libraries as their host applications. Unintended accesses to users' private data are underestimated threats to users' privacy, as complex and often obfuscated third-party libraries make it hard for application developers to estimate the correct behaviors of thirdparty libraries. More critically, a wide adoption of native code (JNI) and dynamic code executions such as Java reflection or dynamic code reloading, makes it even harder to apply state-ofthe-art security analysis.},
  isbn = {978-1-891562-41-9},
  langid = {english},
  annotation = {85 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\CAARYS2F\\Seo et al. - 2016 - FLEXDROID Enforcing In-App Privilege Separation i.pdf}
}

@article{shafiei2022serverless,
  title = {Serverless {{Computing}}: {{A Survey}} of {{Opportunities}}, {{Challenges}}, and {{Applications}}},
  shorttitle = {Serverless {{Computing}}},
  author = {Shafiei, Hossein and Khonsari, Ahmad and Mousavi, Payam},
  year = {2022},
  month = jan,
  journal = {ACM Computing Surveys},
  issn = {0360-0300},
  doi = {10.1145/3510611},
  abstract = {The emerging serverless computing paradigm has attracted attention from both academia and industry. This paradigm brings benefits such as less operational complexity, a pay-as-you-go pricing model, and an auto-scaling feature. The paradigm opens up new opportunities and challenges for cloud application developers. In this paper, we present a comprehensive overview of the past development as well as the recent advances in research areas related to serverless computing. First, we survey serverless applications introduced in the literature. We categorize applications in eight domains and separately discuss the objectives and the viability of the serverless paradigm along with challenges in each of those domains. We then classify those challenges into nine topics and survey the proposed solutions. Finally, we present the areas that need further attention from the research community and identify open problems.},
  keywords = {Cloud Services,Function-as-a-Service (FaaS),Serverless Computing},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22] Just Accepted},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\IFH6F5JX\\Shafiei et al. - 2022 - Serverless Computing A Survey of Opportunities, C.pdf}
}

@article{shapiroeros,
  title = {{{EROS}}: A Fast Capability System\textsterling},
  author = {Shapiro, Jonathan S and Smith, Jonathan M and Farber, David J},
  pages = {16},
  abstract = {EROS is a capability-based operating system for commodity processors which uses a single level storage model. The single level store's persistence is transparent to applications. The performance consequences of support for transparent persistence and capability-based architectures are generally believed to be negative. Surprisingly, the basic operations of EROS (such as IPC) are generally comparable in cost to similar operations in conventional systems. This is demonstrated with a set of microbenchmark measurements of semantically similar operations in Linux.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TIUC4VHH\\Shapiro et al. - EROS a fast capability systemÂ£.pdf}
}

@inproceedings{sharif2018trimmer,
  title = {{{TRIMMER}}: Application Specialization for Code Debloating},
  shorttitle = {{{TRIMMER}}},
  booktitle = {Proceedings of the 33rd {{ACM}}/{{IEEE International Conference}} on {{Automated Software Engineering}}},
  author = {Sharif, Hashim and Abubakar, Muhammad and Gehani, Ashish and Zaffar, Fareed},
  year = {2018},
  month = sep,
  series = {{{ASE}} 2018},
  pages = {329--339},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3238147.3238160},
  abstract = {With the proliferation of new hardware architectures and ever-evolving user requirements, the software stack is becoming increasingly bloated. In practice, only a limited subset of the supported functionality is utilized in a particular usage context, thereby presenting an opportunity to eliminate unused features. In the past, program specialization has been proposed as a mechanism for enabling automatic software debloating. In this work, we show how existing program specialization techniques lack the analyses required for providing code simplification for real-world programs. We present an approach that uses stronger analysis techniques to take advantage of constant configuration data, thereby enabling more effective debloating. We developed Trimmer, an application specialization tool that leverages user-provided configuration data to specialize an application to its deployment context. The specialization process attempts to eliminate the application functionality that is unused in the user-defined context. Our evaluation demonstrates Trimmer can effectively reduce code bloat. For 13 applications spanning various domains, we observe a mean binary size reduction of 21\% and a maximum reduction of 75\%. We also show specialization reduces the surface for code-reuse attacks by reducing the number of exploitable gadgets. For the evaluated programs, we observe a 20\% mean reduction in the total gadget count and a maximum reduction of 87\%.},
  isbn = {978-1-4503-5937-5},
  keywords = {Code debloating,LLVM,Program specialization,Static analysis},
  annotation = {58 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WZJ8KGF5\\Sharif et al. - 2018 - TRIMMER application specialization for code deblo.pdf}
}

@misc{she2022effective,
  title = {Effective {{Seed Scheduling}} for {{Fuzzing}} with {{Graph Centrality Analysis}}},
  author = {She, Dongdong and Shah, Abhishek and Jana, Suman},
  year = {2022},
  month = mar,
  number = {arXiv:2203.12064},
  eprint = {2203.12064},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2203.12064},
  abstract = {Seed scheduling, the order in which seeds are selected, can greatly affect the performance of a fuzzer. Existing approaches schedule seeds based on their historical mutation data, but ignore the structure of the underlying Control Flow Graph (CFG). Examining the CFG can help seed scheduling by revealing the potential edge coverage gain from mutating a seed. An ideal strategy will schedule seeds based on a count of all reachable and feasible edges from a seed through mutations, but computing feasibility along all edges is prohibitively expensive. Therefore, a seed scheduling strategy must approximate this count. We observe that an approximate count should have 3 properties -- (i) it should increase if there are more edges reachable from a seed; (ii) it should decrease if mutation history information suggests an edge is hard to reach or is located far away from currently visited edges; and (iii) it should be efficient to compute over large CFGs. We observe that centrality measures from graph analysis naturally provide these three properties and therefore can efficiently approximate the likelihood of reaching unvisited edges by mutating a seed. We therefore build a graph called the edge horizon graph that connects seeds to their closest unvisited nodes and compute the seed node's centrality to measure the potential edge coverage gain from mutating a seed. We implement our approach in K-scheduler and compare with many popular seed scheduling strategies. We find that K-scheduler increases feature coverage by 25.89\% compared to Entropic and edge coverage by 4.21\% compared to the next-best AFL-based seed scheduler, in arithmetic mean on 12 Google FuzzBench programs. It also finds 3 more previously-unknown bugs than the next-best AFL-based seed scheduler.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Social and Information Networks},
  annotation = {1 citations (Semantic Scholar/arXiv) [2022-09-02] 1 citations (Semantic Scholar/DOI) [2022-09-02]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WJGSVQA5\\She et al. - 2022 - Effective Seed Scheduling for Fuzzing with Graph C.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\EM7UTL2J\\2203.html}
}

@inproceedings{shen2020heapexpo,
  title = {{{HeapExpo}}: {{Pinpointing Promoted Pointers}} to {{Prevent Use-After-Free Vulnerabilities}}},
  shorttitle = {{{HeapExpo}}},
  booktitle = {Annual {{Computer Security Applications Conference}}},
  author = {Shen, Zekun and {Dolan-Gavitt}, Brendan},
  year = {2020},
  month = dec,
  series = {{{ACSAC}} '20},
  pages = {454--465},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3427228.3427645},
  abstract = {Use-after-free (UAF) vulnerabilities, in which dangling pointers remain after memory is released, remain a persistent problem for applications written in C and C++. In order to protect legacy code, prior work has attempted to track pointer propagation and invalidate dangling pointers at deallocation time, but this work has gaps in coverage, as it lacks support for tracking program variables promoted to CPU registers. Moreover, we find that these gaps can significantly hamper detection of UAF bugs: in a preliminary study with OSS-Fuzz, we found that more than half of the UAFs in real-world programs we examined (10/19) could not be detected by prior systems due to register promotion. In this paper, we introduce HeapExpo, a new system that fills this gap in coverage by parsimoniously identifying potential dangling pointer variables that may be lifted into registers by the compiler and marking them as volatile. In our experiments, we find that HeapExpo effectively detects UAFs missed by other systems with an overhead of 35\% on the majority of SPEC CPU2006 and 66\% when including two benchmarks that have high amounts of pointer propagation.},
  isbn = {978-1-4503-8858-0},
  keywords = {Dangling pointers,memory errors,use-after-free},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PP9LQBXZ\\Shen and Dolan-Gavitt - 2020 - HeapExpo Pinpointing Promoted Pointers to Prevent.pdf}
}

@inproceedings{shen2020occlum,
  title = {Occlum: {{Secure}} and {{Efficient Multitasking Inside}} a {{Single Enclave}} of {{Intel SGX}}},
  shorttitle = {Occlum},
  booktitle = {Proceedings of the {{Twenty-Fifth International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Shen, Youren and Tian, Hongliang and Chen, Yu and Chen, Kang and Wang, Runji and Xu, Yi and Xia, Yubin and Yan, Shoumeng},
  year = {2020},
  month = mar,
  pages = {955--970},
  publisher = {{ACM}},
  address = {{Lausanne Switzerland}},
  doi = {10.1145/3373376.3378469},
  abstract = {Intel Software Guard Extensions (SGX) enables user-level code to create private memory regions called enclaves, whose code and data are protected by the CPU from software and hardware attacks outside the enclaves. Recent work introduces library operating systems (LibOSes) to SGX so that legacy applications can run inside enclaves with few or even no modifications. As virtually any non-trivial application demands multiple processes, it is essential for LibOSes to support multitasking. However, none of the existing SGX LibOSes support multitasking both securely and efficiently.},
  isbn = {978-1-4503-7102-5},
  langid = {english},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5RJPZFKG\\Shen et al. - 2020 - Occlum Secure and Efficient Multitasking Inside a.pdf}
}

@inproceedings{shillaker2020faasm,
  title = {Faasm: {{Lightweight Isolation}} for {{Efficient Stateful Serverless Computing}}},
  shorttitle = {Faasm},
  booktitle = {2020 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 20)},
  author = {Shillaker, Simon and Pietzuch, Peter},
  year = {2020},
  pages = {419--433},
  isbn = {978-1-939133-14-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2C6GV4AP\\Shillaker and Pietzuch - 2020 - Faasm Lightweight Isolation for Efficient Statefu.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\RIPQ4Z7F\\shillaker.html}
}

@inproceedings{shin2019crcount,
  title = {{{CRCount}}: {{Pointer Invalidation}} with {{Reference Counting}} to {{Mitigate Use-after-free}} in {{Legacy C}}/{{C}}++},
  shorttitle = {{{CRCount}}},
  booktitle = {Proceedings 2019 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Shin, Jangseop and Kwon, Donghyun and Seo, Jiwon and Cho, Yeongpil and Paek, Yunheung},
  year = {2019},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2019.23541},
  abstract = {Pointer invalidation has been a popular approach adopted in many recent studies to mitigate use-after-free errors. The approach can be divided largely into two different schemes: explicit invalidation and implicit invalidation. The former aims to eradicate the root cause of use-after-free errors by explicitly invalidating every dangling pointer. In contrast, the latter aims to prevent dangling pointers by freeing an object only if there is no pointer referring to it. A downside of the explicit scheme is that it is expensive, as it demands high-cost algorithms or a large amount of space to maintain up-to-date lists of pointer locations linking to each object. Implicit invalidation is more efficient in that even without any explicit effort, it can eliminate dangling pointers by leaving objects undeleted until all the links between the objects and their referring pointers vanish by themselves during program execution. However, such an argument only holds if the scheme knows exactly when each link is created and deleted. Reference counting is a traditional method to determine the existence of reference links between objects and pointers. Unfortunately, impeccable reference counting for legacy C/C++ code is very difficult and expensive to achieve in practice, mainly because of the type unsafe operations in the code. In this paper, we present a solution, called CRCount, to the use-after-free problem in legacy C/C++. For effective and efficient problem solving, CRCount is armed with the pointer footprinting technique that enables us to compute, with high accuracy, the reference count of every object referred to by the pointers in the legacy code. Our experiments demonstrate that CRCount mitigates the useafter-free errors with a lower performance-wise and space-wise overhead than the existing pointer invalidation solutions.},
  isbn = {978-1-891562-55-6},
  langid = {english},
  keywords = {use-after-free},
  annotation = {13 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5RYHKDIN\\Shin et al. - 2019 - CRCount Pointer Invalidation with Reference Count.pdf}
}

@inproceedings{shinde2016preventing,
  title = {Preventing {{Page Faults}} from {{Telling Your Secrets}}},
  booktitle = {Proceedings of the 11th {{ACM}} on {{Asia Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Shinde, Shweta and Chua, Zheng Leong and Narayanan, Viswesh and Saxena, Prateek},
  year = {2016},
  month = may,
  pages = {317--328},
  publisher = {{ACM}},
  address = {{Xi'an China}},
  doi = {10.1145/2897845.2897885},
  abstract = {New hardware primitives such as Intel SGX secure a user-level process in presence of an untrusted or compromised OS. Such ``enclaved execution'' systems are vulnerable to several side-channels, one of which is the page fault channel. In this paper, we show that the page fault side-channel has sufficient channel capacity to extract bits of encryption keys from commodity implementations of cryptographic routines in OpenSSL and Libgcrypt\textemdash{} leaking 27\% on average and up to 100\% of the secret bits in many casestudies. To mitigate this, we propose a software-only defense that masks page fault patterns by determinising the program's memory access behavior. We show that such a technique can be built into a compiler, and implement it for a subset of C which is sufficient to handle the cryptographic routines we study. This defense when implemented generically can have significant overhead of up to 4000\texttimes, but with help of developer-assisted compiler optimizations, the overhead reduces to at most 29.22\% in our case studies. Finally, we discuss scope for hardware-assisted defenses, and show one solution that can reduce overheads to 6.77\% with support from hardware changes.},
  isbn = {978-1-4503-4233-9},
  langid = {english},
  annotation = {176 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GRRIC6DD\\Shinde et al. - 2016 - Preventing Page Faults from Telling Your Secrets.pdf}
}

@inproceedings{silvestro2017freeguard,
  title = {{{FreeGuard}}: {{A Faster Secure Heap Allocator}}},
  shorttitle = {{{FreeGuard}}},
  booktitle = {Proceedings of the 2017 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Silvestro, Sam and Liu, Hongyu and Crosser, Corey and Lin, Zhiqiang and Liu, Tongping},
  year = {2017},
  month = oct,
  series = {{{CCS}} '17},
  pages = {2389--2403},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3133956.3133957},
  abstract = {In spite of years of improvements to software security, heap-related attacks still remain a severe threat. One reason is that many existing memory allocators fall short in a variety of aspects. For instance, performance-oriented allocators are designed with very limited countermeasures against attacks, but secure allocators generally suffer from significant performance overhead, e.g., running up to 10x slower. This paper, therefore, introduces FreeGuard, a secure memory allocator that prevents or reduces a wide range of heap-related security attacks, such as heap overflows, heap over-reads, use-after-frees, as well as double and invalid frees. FreeGuard has similar performance to the default Linux allocator, with less than 2\% overhead on average, but provides significant improvement to security guarantees.},
  isbn = {978-1-4503-4946-8},
  keywords = {heap allocator,memory safety,memory vulnerabilities},
  annotation = {43 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ISIPJ76V\\Silvestro et al. - 2017 - FreeGuard A Faster Secure Heap Allocator.pdf}
}

@inproceedings{silvestro2018guarder,
  title = {Guarder: {{A Tunable Secure Allocator}}},
  shorttitle = {Guarder},
  booktitle = {27th {{USENIX Security Symposium}} ({{USENIX Security}} 18)},
  author = {Silvestro, Sam and Liu, Hongyu and Liu, Tianyi and Lin, Zhiqiang and Liu, Tongping},
  year = {2018},
  pages = {117--133},
  isbn = {978-1-939133-04-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PQR42IVF\\Silvestro et al. - 2018 - Guarder A Tunable Secure Allocator.pdf}
}

@inproceedings{singhvi2021atoll,
  title = {Atoll: {{A Scalable Low-Latency Serverless Platform}}},
  shorttitle = {Atoll},
  booktitle = {Proceedings of the {{ACM Symposium}} on {{Cloud Computing}}},
  author = {Singhvi, Arjun and Balasubramanian, Arjun and Houck, Kevin and Shaikh, Mohammed Danish and Venkataraman, Shivaram and Akella, Aditya},
  year = {2021},
  month = nov,
  series = {{{SoCC}} '21},
  pages = {138--152},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3472883.3486981},
  abstract = {With user-facing apps adopting serverless computing, good latency performance of serverless platforms has become a strong fundamental requirement. However, it is difficult to achieve this on platforms today due to the design of their underlying control and data planes that are particularly ill-suited to short-lived functions with unpredictable arrival patterns. We present Atoll, a serverless platform, that overcomes the challenges via a ground-up redesign of the control and data planes. In Atoll, each app is associated with a latency deadline. Atoll achieves its per-app request latency goals by: (a) partitioning the cluster into (semi-global scheduler, worker pool) pairs, (b) performing deadline-aware scheduling and proactive sandbox allocation, and (c) using a load balancing layer to do sandbox-aware routing, and automatically scale the semi-global schedulers per app. Our results show that Atoll reduces missed deadlines by \textasciitilde 66x and tail latencies by \textasciitilde 3x compared to state-of-the-art alternatives.},
  isbn = {978-1-4503-8638-8},
  keywords = {Low-Latency,Scalable,Serverless Computing},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\VL3WHHVV\\Singhvi et al. - 2021 - Atoll A Scalable Low-Latency Serverless Platform.pdf}
}

@inproceedings{soneji2022flawed,
  title = {``{{Flawed}}, but like Democracy We Don't Have a Better System'': {{The Experts}}' {{Insights}} on the {{Peer Review Process}} of {{Evaluating Security Papers}}},
  shorttitle = {``{{Flawed}}, but like Democracy We Don't Have a Better System''},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Soneji, Ananta and Kokulu, Faris Bugra and {Rubio-Medrano}, Carlos and Bao, Tiffany and Wang, Ruoyu and Shoshitaishvili, Yan and Doup{\'e}, Adam},
  year = {2022},
  month = apr,
  pages = {1560--1560},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00131},
  abstract = {The academic computer security community has traditionally adopted peer review as an integral part of scientific publishing and dissemination, in a process that grows organically and nourishes itself by internal communications and intuitions, rather than repeatable experiments and investigations. Recently, key community members have shared a series of concerns regarding this process in public. To support or disprove some of these concerns, this paper presents the first qualitative study to examine the peer review process in the computer security field. Through semi-structured interviews (n=21) with Program Committee members, we systematically collect the reviewers' insights on how papers are evaluated in top-tier security conferences and investigate their concerns regarding the current security peer review system. Based on the collected data, we identify several issues in the security review system: whereas some have been previously observed by the community (e.g., the randomness in reviewers' decisions), others (e.g., reviewers have much more diverse and concrete opinions on the metrics of rejecting papers) have been observed for the first time in our study. Finally, through a series of recommendations, we aim to encourage the collaborative establishment of community norms that will significantly improve the security peer review process.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9R33IZPP\\1CIO8bqcxeU.html}
}

@article{sonejiexperts,
  title = {The {{Experts}}' {{Insights}} on the {{Peer Review Process}} of {{Evaluating Security Papers}}},
  author = {Soneji, Ananta and Kokulu, Faris Bugra and {Rubio-Medrano}, Carlos and Wang, Ruoyu and Shoshitaishvili, Yan and Doupe, Adam},
  pages = {18},
  abstract = {The academic computer security community has traditionally adopted peer review as an integral part of scientific publishing and dissemination, in a process that grows organically and nourishes itself by internal communications and intuitions, rather than repeatable experiments and investigations. Recently, key community members have shared a series of concerns regarding this process in public. To support or disprove some of these concerns, this paper presents the first qualitative study to examine the peer review process in the computer security field. Through semi-structured interviews (n=21) with Program Committee members, we systematically collect the reviewers' insights on how papers are evaluated in top-tier security conferences and investigate their concerns regarding the current security peer review system. Based on the collected data, we identify several issues in the security review system: whereas some have been previously observed by the community (e.g., the randomness in reviewers' decisions), others (e.g., reviewers have much more diverse and concrete opinions on the metrics of rejecting papers) have been observed for the first time in our study. Finally, through a series of recommendations, we aim to encourage the collaborative establishment of community norms that will significantly improve the security peer review process.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XB8R8S65\\Soneji et al. - The Expertsâ€™ Insights on the Peer Review Process o.pdf}
}

@inproceedings{song2016enforcing,
  title = {Enforcing {{Kernel Security Invariants}} with {{Data Flow Integrity}}},
  author = {Song, Chengyu and Lee, Byoungyoung and Lu, Kangjie and Harris, William and Kim, Taesoo and Lee, Wenke},
  year = {2016},
  month = feb,
  doi = {10.14722/ndss.2016.23218},
  abstract = {The operation system kernel is the foundation of the whole system and is often the de facto trusted computing base for many higher level security mechanisms. Unfortunately, kernel vulnerabilities are not rare and are continuously being introduced with new kernel features. Once the kernel is compromised, attackers can bypass any access control checks, escalate their privileges, and hide the evidence of attacks. Many protection mechanisms have been proposed and deployed to prevent kernel exploits. However, a majority of these techniques only focus on preventing control-flow hijacking attacks; techniques that can mitigate non-control-data attacks either only apply to drivers/modules or impose too much overhead. The goal of our research is to develop a principled defense mechanism against memory-corruption-based privilege escalation attacks. Toward this end, we leverage data-flow integrity to enforce security invariants of the kernel access control system. In order for our protection mechanism to be practical, we develop two new techniques: one for automatically inferring data that are critical to the access control system without manual annotation, and the other for efficient DFI enforcement over the inference results. We have implemented a prototype of our technology for the ARM64 Linux kernel on an Android device. The evaluation results of our prototype implementation show that our technology can mitigate a majority of privilege escalation attacks, while imposing a moderate amount of performance overhead.},
  keywords = {dfi},
  annotation = {97 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GQ3DDJJV\\Song et al. - 2016 - Enforcing Kernel Security Invariants with Data Flo.pdf}
}

@inproceedings{song2019sok,
  title = {{{SoK}}: {{Sanitizing}} for {{Security}}},
  shorttitle = {{{SoK}}},
  booktitle = {2019 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Song, Dokyung and Lettner, Julian and Rajasekaran, Prabhu and Na, Yeoul and Volckaert, Stijn and Larsen, Per and Franz, Michael},
  year = {2019},
  month = may,
  pages = {1275--1295},
  issn = {2375-1207},
  doi = {10.1109/SP.2019.00010},
  abstract = {The C and C++ programming languages are notoriously insecure yet remain indispensable. Developers therefore resort to a multi-pronged approach to find security issues before adversaries. These include manual, static, and dynamic program analysis. Dynamic bug finding tools-henceforth "sanitizers"-can find bugs that elude other types of analysis because they observe the actual execution of a program, and can therefore directly observe incorrect program behavior as it happens. A vast number of sanitizers have been prototyped by academics and refined by practitioners. We provide a systematic overview of sanitizers with an emphasis on their role in finding security issues. Specifically, we taxonomize the available tools and the security vulnerabilities they cover, describe their performance and compatibility properties, and highlight various trade-offs.},
  keywords = {C++ languages,Casting,Computer bugs,Computer-Bugs,Lenses,Safety,Security,Software-Safety,System-Software,Tools},
  annotation = {86 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\36KZU8X6\\Song et al. - 2019 - SoK Sanitizing for Security.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\DND453UV\\8835294.html}
}

@article{sufatrio2015securing,
  title = {Securing {{Android}}},
  author = {Sufatrio and J, TanDarell J. and {ChuaTong-Wei} and L, ThingVrizlynn L.},
  year = {2015},
  month = may,
  journal = {ACM Computing Surveys (CSUR)},
  publisher = {{ACM}},
  doi = {10.1145/2733306},
  abstract = {Recent years have seen a global adoption of smart mobile devices, particularly those based on Android. However, Android's widespread adoption is marred with increasingly rampant malware threats. This article gives a survey and taxonomy of existing works ...},
  langid = {english},
  annotation = {118 citations (Semantic Scholar/DOI) [2022-08-22] 		PUB27 		New York, NY, USA},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LQBQGYAD\\Sufatrio et al. - 2015 - Securing Android.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\C5E9MZLM\\2733306.html}
}

@inproceedings{sun2020oat,
  title = {{{OAT}}: {{Attesting Operation Integrity}} of {{Embedded Devices}}},
  shorttitle = {{{OAT}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Sun, Zhichuang and Feng, Bo and Lu, Long and Jha, Somesh},
  year = {2020},
  month = may,
  pages = {1433--1449},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00042},
  abstract = {Due to the wide adoption of IoT/CPS systems, embedded devices (IoT frontends) become increasingly connected and mission-critical, which in turn has attracted advanced attacks (e.g., control-flow hijacks and data-only attacks). Unfortunately, IoT backends (e.g., remote controllers or in-cloud services) are unable to detect if such attacks have happened while receiving data, service requests, or operation status from IoT devices (remotely deployed embedded devices). As a result, currently, IoT backends are forced to blindly trust the IoT devices that they interact with.To fill this void, we first formulate a new security property for embedded devices, called "Operation Execution Integrity" or OEI. We then design and build a system, OAT, that enables remote OEI attestation for ARM-based bare-metal embedded devices. Our formulation of OEI captures the integrity of both control flow and critical data involved in an operation execution. Therefore, satisfying OEI entails that an operation execution is free of unexpected control and data manipulations, which existing attestation methods cannot check. Our design of OAT strikes a balance between prover's constraints (embedded devices' limited computing power and storage) and verifier's requirements (complete verifiability and forensic assistance). OAT uses a new control-flow measurement scheme, which enables lightweight and space-efficient collection of measurements (97\% space reduction from the trace-based approach). OAT performs the remote control-flow verification through abstract execution, which is fast and deterministic. OAT also features lightweight integrity checking for critical data (74\% less instrumentation needed than previous work). Our security analysis shows that OAT allows remote verifiers or IoT backends to detect both controlflow hijacks and data-only attacks that affect the execution of operations on IoT devices. In our evaluation using real embedded programs, OAT incurs a runtime overhead of 2.7\%.},
  keywords = {Data integrity,Instruments,Manipulators,Open area test sites,Performance evaluation},
  annotation = {23 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PAR9E2NS\\Sun et al. - 2020 - OAT Attesting Operation Integrity of Embedded Dev.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\28HC652U\\9152803.html}
}

@inproceedings{sun2022ksg,
  title = {\{\vphantom\}{{KSG}}\vphantom\{\}: {{Augmenting Kernel Fuzzing}} with {{System Call Specification Generation}}},
  shorttitle = {\{\vphantom\}{{KSG}}\vphantom\{\}},
  booktitle = {2022 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 22)},
  author = {Sun, Hao and Shen, Yuheng and Liu, Jianzhong and Xu, Yiru and Jiang, Yu},
  year = {2022},
  pages = {351--366},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MW8ZGA3K\\Sun et al. - 2022 - KSG Augmenting Kernel Fuzzing with System Call .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\J9R5QAM9\\sun.html}
}

@article{sunksg,
  title = {{{KSG}}: {{Augmenting Kernel Fuzzing}} with {{System Call Specification Generation}}},
  author = {Sun, Hao and Shen, Yuheng and Liu, Jianzhong and Jiang, Yu and Xu, Yiru},
  pages = {16},
  abstract = {Kernel fuzzing is a dynamic testing technique that has successfully found numerous kernel vulnerabilities. However, existing kernel fuzzers, such as Syzkaller, depend on system call specifications to generate test cases. Writing such specifications requires an immense amount of domain knowledge while being extremely laborious. Meanwhile, automated generation of the specification is still an open problem due to the complexity of the kernel, including entry function extraction and input type identification. As a result, the current amount of system call information is insufficient to test the entire kernel code base thoroughly. Syzkaller covers an average of 38\% of Linux kernel code with current Syzlang specifications for a prolonged time of fuzzing.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BC5M3YJI\\Sun et al. - KSG Augmenting Kernel Fuzzing with System Call Sp.pdf}
}

@inproceedings{szekeres2013sok,
  title = {{{SoK}}: {{Eternal War}} in {{Memory}}},
  shorttitle = {{{SoK}}},
  booktitle = {2013 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Szekeres, L{\'a}szl{\'o} and Payer, Mathias and Wei, Tao and Song, Dawn},
  year = {2013},
  month = may,
  pages = {48--62},
  issn = {1081-6011},
  doi = {10.1109/SP.2013.13},
  abstract = {Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corruption attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other proposed protections enforcing stricter policies. We analyze the reasons why protection mechanisms implementing stricter polices are not deployed. To achieve wide adoption, protection mechanisms must support a multitude of features and must satisfy a host of requirements. Especially important is performance, as experience shows that only solutions whose overhead is in reasonable bounds get deployed. A comparison of different enforceable policies helps designers of new protection mechanisms in finding the balance between effectiveness (security) and efficiency. We identify some open research problems, and provide suggestions on improving the adoption of newer techniques.},
  keywords = {Aerospace electronics,Arrays,Computer bugs,Memory management,memory safety,Programming,s\&p,Safety,Security,sok},
  annotation = {563 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\T5AAWFRD\\Szekeres et al. - 2013 - SoK Eternal War in Memory.pdf}
}

@inproceedings{taassori2018vault,
  title = {{{VAULT}}: {{Reducing Paging Overheads}} in {{SGX}} with {{Efficient Integrity Verification Structures}}},
  shorttitle = {{{VAULT}}},
  booktitle = {Proceedings of the {{Twenty-Third International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Taassori, Meysam and Shafiee, Ali and Balasubramonian, Rajeev},
  year = {2018},
  month = mar,
  pages = {665--678},
  publisher = {{ACM}},
  address = {{Williamsburg VA USA}},
  doi = {10.1145/3173162.3177155},
  abstract = {Intel's SGX o ers state-of-the-art security features, including con dentiality, integrity, and authentication (CIA) when accessing sensitive pages in memory. Sensitive pages are placed in an Enclave Page Cache (EPC) within the physical memory before they can be accessed by the processor. To control the overheads imposed by CIA guarantees, the EPC operates with a limited capacity (currently 128 MB). Because of this limited EPC size, sensitive pages must be frequently swapped between EPC and non-EPC regions in memory. A page swap is expensive (about 40K cycles) because it requires an OS system call, page copying, updates to integrity trees and metadata, etc. Our analysis shows that the paging overhead can slow the system on average by 5\texttimes, and other studies have reported even higher slowdowns for memory-intensive workloads.},
  isbn = {978-1-4503-4911-6},
  langid = {english},
  annotation = {94 citations (Semantic Scholar/DOI) [2022-08-30]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\79IWUNIE\\Taassori et al. - 2018 - VAULT Reducing Paging Overheads in SGX with Effic.pdf}
}

@article{tan2017principles,
  title = {Principles and {{Implementation Techniques}} of {{Software-Based Fault Isolation}}},
  author = {Tan, Gang},
  year = {2017},
  journal = {Foundations and Trends\textregistered{} in Privacy and Security},
  volume = {1},
  number = {3},
  pages = {137--198},
  issn = {2474-1558, 2474-1566},
  doi = {10.1561/3300000013},
  abstract = {When protecting a computer system, it is often necessary to isolate an untrusted component into a separate protection domain and provide only controlled interaction between the domain and the rest of the system. Software-based Fault Isolation (SFI) establishes a logical protection domain by inserting dynamic checks before memory and control-transfer instructions. Compared to other isolation mechanisms, it enjoys the benefits of high efficiency (with less than 5\% performance overhead), being readily applicable to legacy native code, and not relying on special hardware or OS support. SFI has been successfully applied in many applications, including isolating OS kernel extensions, isolating plug-ins in browsers, and isolating native libraries in the Java Virtual Machine. In this survey article, we will discuss the SFI policy, its main implementation and optimization techniques, as well as an SFI formalization on an idealized assembly language.},
  langid = {english},
  annotation = {21 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XNQHPIQB\\Tan - 2017 - Principles and Implementation Techniques of Softwa.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\7B2QVWE9\\SEC-013.html}
}

@inproceedings{tan2021roload,
  title = {{{ROLoad}}: {{Securing Sensitive Operations}} with {{Pointee Integrity}}},
  shorttitle = {{{ROLoad}}},
  booktitle = {2021 58th {{ACM}}/{{IEEE Design Automation Conference}} ({{DAC}})},
  author = {Tan, Wende and Li, Yuan and Zhang, Chao and Chen, Xingman and Yang, Songtao and Liu, Ying and Wu, Jianping},
  year = {2021},
  month = dec,
  pages = {307--312},
  issn = {0738-100X},
  doi = {10.1109/DAC18074.2021.9586274},
  abstract = {Sensitive operations (e.g. control-flow transfers) are attractive targets for attackers. To protect them from being hijacked, we propose a new solution ROLoad to guarantee the integrity of their operands, which are loaded from (potentially corrupted) memory. We extend the RISC-V instruction set, implement an FPGA-based prototype of ROLoad, and then demonstrate two specific defense applications. Results show that this solution only costs few extra hardware resources ({$<$} 3.32\%). However, it could enable many lightweight (e.g. with overheads less than 0.31\%) defenses, and provide broader and stronger security guarantees than existing hardware solutions, e.g. ARM BTI and Intel CET.},
  keywords = {Costs,Design automation,Hardware,Prototypes,Reduced instruction set computing,Security},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\P7M96UGJ\\Tan et al. - 2021 - ROLoad Securing Sensitive Operations with Pointee.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZDLLPYSZ\\9586274.html}
}

@inproceedings{tartler2012automatic,
  title = {Automatic \{\vphantom\}{{OS}}\vphantom\{\} {{Kernel}} \{\vphantom\}{{TCB}}\vphantom\{\} {{Reduction}} by {{Leveraging}} \{\vphantom\}{{Compile-Time}}\vphantom\{\} {{Configurability}}},
  booktitle = {Eighth {{Workshop}} on {{Hot Topics}} in {{System Dependability}} ({{HotDep}} 12)},
  author = {Tartler, Reinhard and Kurmus, Anil and Heinloth, Bernhard and Rothberg, Valentin and Ruprecht, Andreas and Dorneanu, Daniela and Kapitza, R{\"u}diger and {Schr{\"o}der-Preikschat}, Wolfgang and Lohmann, Daniel},
  year = {2012},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MXSYL5G3\\Tartler et al. - 2012 - Automatic OS Kernel TCB Reduction by Leveragin.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZPTKH6UK\\tartler.html}
}

@inproceedings{tartler2014static,
  title = {Static {{Analysis}} of {{Variability}} in {{System Software}}: {{The}} 90,000 \#ifdefs {{Issue}}},
  shorttitle = {Static {{Analysis}} of {{Variability}} in {{System Software}}},
  booktitle = {2014 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 14)},
  author = {Tartler, Reinhard and Dietrich, Christian and Sincero, Julio and {Schr{\"o}der-Preikschat}, Wolfgang and Lohmann, Daniel},
  year = {2014},
  pages = {421--432},
  isbn = {978-1-931971-10-2},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ERGAFKFE\\Tartler et al. - 2014 - Static Analysis of Variability in System Software.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\YKDVQBYM\\tartler.html}
}

@article{tromer2010efficient,
  title = {Efficient {{Cache Attacks}} on {{AES}}, and {{Countermeasures}}},
  author = {Tromer, Eran and Osvik, Dag Arne and Shamir, Adi},
  year = {2010},
  month = jan,
  journal = {Journal of Cryptology},
  volume = {23},
  number = {1},
  pages = {37--71},
  issn = {0933-2790, 1432-1378},
  doi = {10.1007/s00145-009-9049-y},
  abstract = {We describe several software side-channel attacks based on inter-process leakage through the state of the CPU's memory cache. This leakage reveals memory access patterns, which can be used for cryptanalysis of cryptographic primitives that employ data-dependent table lookups. The attacks allow an unprivileged process to attack other processes running in parallel on the same processor, despite partitioning methods such as memory protection, sandboxing and virtualization. Some of our methods require only the ability to trigger services that perform encryption or MAC using the unknown key, such as encrypted disk partitions or secure network links. Moreover, we demonstrate an extremely strong type of attack, which requires knowledge of neither the specific plaintexts nor ciphertexts, and works by merely monitoring the effect of the cryptographic process on the cache. We discuss in detail several attacks on AES, and experimentally demonstrate their applicability to real systems, such as OpenSSL and Linux's dm-crypt encrypted partitions (in the latter case, the full key was recovered after just 800 writes to the partition, taking 65 milliseconds). Finally, we discuss a variety of countermeasures which can be used to mitigate such attacks.},
  langid = {english},
  annotation = {434 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\KEB933ZX\\Tromer et al. - 2010 - Efficient Cache Attacks on AES, and Countermeasure.pdf}
}

@inproceedings{vanderkouwe2017dangsan,
  title = {{{DangSan}}: {{Scalable Use-after-free Detection}}},
  shorttitle = {{{DangSan}}},
  booktitle = {Proceedings of the {{Twelfth European Conference}} on {{Computer Systems}}},
  author = {{van der Kouwe}, Erik and Nigade, Vinod and Giuffrida, Cristiano},
  year = {2017},
  month = apr,
  series = {{{EuroSys}} '17},
  pages = {405--419},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3064176.3064211},
  abstract = {Use-after-free vulnerabilities due to dangling pointers are an important and growing threat to systems security. While various solutions exist to address this problem, none of them is sufficiently practical for real-world adoption. Some can be bypassed by attackers, others cannot support complex multithreaded applications prone to dangling pointers, and the remainder have prohibitively high overhead. One major source of overhead is the need to synchronize threads on every pointer write due to pointer tracking. In this paper, we present DangSan, a use-after-free detection system that scales efficiently to large numbers of pointer writes as well as to many concurrent threads. To significantly reduce the overhead of existing solutions, we observe that pointer tracking is write-intensive but requires very few reads. Moreover, there is no need for strong consistency guarantees as inconsistencies can be reconciled at read (i.e., object deallocation) time. Building on these intuitions, DangSan's design mimics that of log-structured file systems, which are ideally suited for similar workloads. Our results show that DangSan can run heavily multithreaded applications, while introducing only half the overhead of previous multithreaded use-after-free detectors.},
  isbn = {978-1-4503-4938-3},
  keywords = {Dangling pointers,LLVM,use-after-free},
  annotation = {61 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LKRVHULJ\\van der Kouwe et al. - 2017 - DangSan Scalable Use-after-free Detection.pdf}
}

@inproceedings{vanderkouwe2018typeaftertype,
  title = {Type-{{After-Type}}: {{Practical}} and {{Complete Type-Safe Memory Reuse}}},
  shorttitle = {Type-{{After-Type}}},
  booktitle = {Proceedings of the 34th {{Annual Computer Security Applications Conference}}},
  author = {{van der Kouwe}, Erik and Kroes, Taddeus and Ouwehand, Chris and Bos, Herbert and Giuffrida, Cristiano},
  year = {2018},
  month = dec,
  series = {{{ACSAC}} '18},
  pages = {17--27},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3274694.3274705},
  abstract = {Temporal memory errors, such as use-after-free bugs, are increasingly popular among attackers and their exploitation is hard to stop efficiently using current techniques. We present a new design, called Type-After-Type, which builds on abstractions in production allocators to provide complete temporal type safety for C/C++ programs---ensuring that memory reuse is always type safe---and efficiently hinder temporal memory attacks. Type-After-Type uses static analysis to determine the types of all heap and stack allocations, and replaces regular allocations with typed allocations that never reuse memory previously used by other types. On the heap, Type-After-Type splits available memory into separate pools for each type. For the stack, Type-After-Type efficiently implements type-safe memory reuse for the first time, pushing variables on separate stacks according to their types, unless they are provably safe (e.g., their address is not taken), in which case they are zero-initialized and kept on a special stack. In our evaluation, we show that Type-After-Type stops a variety of real-world temporal memory attacks and on SPEC CPU2006 incurs a performance overhead of 4.3\% and a memory overhead of 17.4\% (geomean).},
  isbn = {978-1-4503-6569-7},
  keywords = {computer systems,defense,LLVM,uninitialized read,Use-after-free},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\MMKUQ6RT\\van der Kouwe et al. - 2018 - Type-After-Type Practical and Complete Type-Safe .pdf}
}

@inproceedings{vanderkouwe2019sok,
  title = {{{SoK}}: {{Benchmarking Flaws}} in {{Systems Security}}},
  shorttitle = {{{SoK}}},
  booktitle = {2019 {{IEEE European Symposium}} on {{Security}} and {{Privacy}} ({{EuroS}}\&{{P}})},
  author = {{van der Kouwe}, Erik and Heiser, Gernot and Andriesse, Dennis and Bos, Herbert and Giuffrida, Cristiano},
  year = {2019},
  month = jun,
  pages = {310--325},
  publisher = {{IEEE}},
  address = {{Stockholm, Sweden}},
  doi = {10.1109/EuroSP.2019.00031},
  isbn = {978-1-72811-148-3},
  langid = {english},
  annotation = {14 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LPCKWVP6\\van der Kouwe et al. - 2019 - SoK Benchmarking Flaws in Systems Security.pdf}
}

@inproceedings{vanderveen2016tough,
  title = {A {{Tough Call}}: {{Mitigating Advanced Code-Reuse Attacks}} at the {{Binary Level}}},
  shorttitle = {A {{Tough Call}}},
  booktitle = {2016 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {{van der Veen}, Victor and G{\"o}ktas, Enes and Contag, Moritz and Pawoloski, Andre and Chen, Xi and Rawat, Sanjay and Bos, Herbert and Holz, Thorsten and Athanasopoulos, Elias and Giuffrida, Cristiano},
  year = {2016},
  month = may,
  pages = {934--953},
  issn = {2375-1207},
  doi = {10.1109/SP.2016.60},
  abstract = {Current binary-level Control-Flow Integrity (CFI) techniques are weak in determining the set of valid targets for indirect control flow transfers on the forward edge. In particular, the lack of source code forces existing techniques to resort to a conservative address-taken policy that overapproximates this set. In contrast, source-level solutions can accurately infer the targets of indirect calls and thus detect malicious control-flow transfers more precisely. Given that source code is not always available, however, offering similar quality of protection at the binary level is important, but, unquestionably, more challenging than ever: recent work demonstrates powerful attacks such as Counterfeit Object-oriented Programming (COOP), which made the community believe that protecting software against control-flow diversion attacks at the binary level is rather impossible. In this paper, we propose binary-level analysis techniques to significantly reduce the number of possible targets for indirect branches. More specifically, we reconstruct a conservative approximation of target function prototypes by means of use-def analysis at possible callees. We then couple this with liveness analysis at each indirect callsite to derive a many-to-many relationship between callsites and target callees with a much higher precision compared to prior binary-level solutions. Experimental results on popular server programs and on SPEC CPU2006 show that TypeArmor, a prototype implementation of our approach, is efficient - with a runtime overhead of less than 3\%. Furthermore, we evaluate to what extent TypeArmor can mitigate COOP and other advanced attacks and show that our approach can significantly reduce the number of targets on the forward edge. Moreover, we show that TypeArmor breaks published COOP exploits, providing concrete evidence that strict binary-level CFI can still mitigate advanced attacks, despite the absence of source information or C++ semantics.},
  keywords = {binary analysis,binary rewrite,cfi,Libraries,Optimization,Prototypes,Registers,Runtime,s\&p,Semantics,Standards},
  annotation = {157 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UDXE5ARV\\van der Veen et al. - 2016 - A Tough Call Mitigating Advanced Code-Reuse Attac.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\BNEIPVZQ\\7546543.html}
}

@book{vanschaik2018malicious,
  title = {Malicious Management Unit: {{Why}} Stopping Cache Attacks in Software Is Harder than You Think},
  shorttitle = {Malicious Management Unit},
  author = {Van Schaik, Stephan and Giuffrida, Cristiano and Bos, Herbert and Razavi, Kaveh},
  year = {2018},
  month = aug,
  publisher = {{USENIX Association}},
  abstract = {Cache attacks have increasingly gained momentum in the security community. In such attacks, attacker-controlled code sharing the cache with a designated victim can leak confidential data by timing the execution of cache-accessing operations. Much recent work has focused on defenses that enforce cache access isolation between mutually distrusting software components. In such a landscape, many software-based defenses have been popularized, given their appealing portability and scalability guarantees. All such defenses prevent attacker-controlled CPU instructions from accessing a cache partition dedicated to a different security domain. In this paper, we present a new class of attacks (indirect cache attacks), which can bypass all the existing software-based defenses. In such attacks, rather than accessing the cache directly, attacker-controlled code lures an external, trusted component into indirectly accessing the cache partition of the victim and mount a confused-deputy side-channel attack. To demonstrate the viability of these attacks, we focus on the MMU, demonstrating that indirect cache attacks based on translation operations performed by the MMU are practical and can be used to bypass all the existing software-based defenses. Our results show that the isolation enforced by existing defense techniques is imperfect and that generalizing such techniques to mitigate arbitrary cache attacks is much more challenging than previously assumed},
  isbn = {978-1-939133-04-5},
  langid = {english},
  annotation = {OCLC: 8514259013},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\UQFHBHVR\\Van Schaik et al. - 2018 - Malicious management unit Why stopping cache atta.pdf}
}

@inproceedings{vasilakis2018breakapp,
  title = {{{BreakApp}}: {{Automated}}, {{Flexible Application Compartmentalization}}},
  shorttitle = {{{BreakApp}}},
  booktitle = {Proceedings 2018 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Vasilakis, Nikos and Karel, Ben and Roessler, Nick and Dautenhahn, Nathan and DeHon, Andre and Smith, Jonathan M.},
  year = {2018},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2018.23131},
  abstract = {Developers of large-scale software systems may use third-party modules to reduce costs and accelerate release cycles, at some risk to safety and security. BREAKAPP exploits module boundaries to automate compartmentalization of systems and enforce security policies, enhancing reliability and security. BREAKAPP transparently spawns modules in protected compartments while preserving their original behavior. Optional high-level policies decouple security assumptions made during development from requirements imposed for module composition and use. These policies allow fine-tuning trade-offs such as security and performance based on changing threat models or load patterns. Evaluation of BREAKAPP with a prototype implementation for JavaScript demonstrates feasibility by enabling simplified security hardening of existing systems with low performance overhead.},
  isbn = {978-1-891562-49-5},
  langid = {english},
  annotation = {41 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\W8D25A7R\\Vasilakis et al. - 2018 - BreakApp Automated, Flexible Application Compartm.pdf}
}

@inproceedings{vasilakis2021preventing,
  title = {Preventing {{Dynamic Library Compromise}} on {{Node}}.Js via {{RWX-Based Privilege Reduction}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Vasilakis, Nikos and Staicu, Cristian-Alexandru and Ntousakis, Grigoris and Kallas, Konstantinos and Karel, Ben and DeHon, Andr{\'e} and Pradel, Michael},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {1821--1838},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484535},
  abstract = {Third-party libraries ease the development of large-scale software systems. However, libraries often execute with significantly more privilege than needed to complete their task. Such additional privilege is sometimes exploited at runtime via inputs passed to a library, even when the library itself is not actively malicious. We present Mir, a system addressing dynamic compromise by introducing a fine-grained read-write-execute (RWX) permission model at the boundaries of libraries: every field of every free variable name in the context of an imported library is governed by a permission set. To help specify the permissions given to existing code, Mir's automated inference generates default permissions by analyzing how libraries are used by their clients. Applied to over 1,000 JavaScript libraries for Node.js, Mir shows practical security (61/63 attacks mitigated), performance (2.1s for static analysis and +1.93\% for dynamic enforcement), and compatibility (99.09\%) characteristics---and enables a novel quantification of privilege reduction.},
  isbn = {978-1-4503-8454-4},
  keywords = {program analysis,supply-chain attacks,third-party libraries},
  annotation = {7 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\49SAK426\\Vasilakis et al. - 2021 - Preventing Dynamic Library Compromise on Node.js v.pdf}
}

@inproceedings{vasilakis2021supplychain,
  title = {Supply-{{Chain Vulnerability Elimination}} via {{Active Learning}} and {{Regeneration}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Vasilakis, Nikos and Benetopoulos, Achilles and Handa, Shivam and Schoen, Alizee and Shen, Jiasi and Rinard, Martin C.},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {1755--1770},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484736},
  abstract = {Software supply-chain attacks target components that are integrated into client applications. Such attacks often target widely-used components, with the attack taking place via operations (for example, file system or network accesses) that do not affect those aspects of component behavior that the client observes. We propose new active library learning and regeneration (ALR) techniques for inferring and regenerating the client-observable behavior of software components. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the component, and observes the resulting outputs to infer a model of the component's behavior as a program in a domain-specific language. We present Harp, an ALR system for string processing components. We apply Harp to successfully infer and regenerate string-processing components written in JavaScript and C/C++. Our results indicate that, in the majority of cases, Harp completes the regeneration in less than a minute, remains fully compatible with the original library, and delivers performance indistinguishable from the original library. We also demonstrate that Harp can eliminate vulnerabilities associated with libraries targeted in several highly visible security incidents, specifically event-stream, left-pad, and string-compare.},
  isbn = {978-1-4503-8454-4},
  keywords = {modules,packages,program inference,program synthesis,supply-chain attacks,third-party libraries},
  annotation = {5 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ABR9VZFE\\Vasilakis et al. - 2021 - Supply-Chain Vulnerability Elimination via Active .pdf}
}

@inproceedings{vasiliadis2014pixelvault,
  title = {{{PixelVault}}: {{Using GPUs}} for {{Securing Cryptographic Operations}}},
  shorttitle = {{{PixelVault}}},
  booktitle = {Proceedings of the 2014 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Vasiliadis, Giorgos and Athanasopoulos, Elias and Polychronakis, Michalis and Ioannidis, Sotiris},
  year = {2014},
  month = nov,
  pages = {1131--1142},
  publisher = {{ACM}},
  address = {{Scottsdale Arizona USA}},
  doi = {10.1145/2660267.2660316},
  abstract = {Protecting the confidentiality of cryptographic keys in the event of partial or full system compromise is crucial for containing the impact of attacks. The Heartbleed vulnerability of April 2014, which allowed the remote leakage of secret keys from HTTPS web servers, is an indicative example. In this paper we present PixelVault, a system for keeping cryptographic keys and carrying out cryptographic operations exclusively on the GPU, which allows it to protect secret keys from leakage even in the event of full system compromise. This is possible by exposing secret keys only in GPU registers, keeping PixelVault's critical code in the GPU instruction cache, and preventing any access to both of them from the host. Due to the non-preemptive execution mode of the GPU, an adversary that has full control of the host cannot tamper with PixelVault's GPU code, but only terminate it, in which case all sensitive data is lost. We have implemented a PixelVault-enabled version of the OpenSSL library that allows the protection of existing applications with minimal modifications. Based on the results of our evaluation, PixelVault not only provides secure key storage using commodity hardware, but also significantly speeds up the processing throughput of cryptographic operations for server applications.},
  isbn = {978-1-4503-2957-6},
  langid = {english},
  keywords = {GPU,hardware-assisted security},
  annotation = {57 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\83TF554P\\Vasiliadis et al. - 2014 - PixelVault Using GPUs for Securing Cryptographic .pdf}
}

@inproceedings{vicarte2022augury,
  title = {Augury: {{Using}} Data Memory-Dependent Prefetchers to Leak Data at Rest},
  shorttitle = {Augury},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Vicarte, Jose Sanchez and Flanders, Michael and Paccagnella, Riccardo and {Garrett-Grossman}, Grant and Morrison, Adam and Fletcher, Chris and Kohlbrenner, David},
  year = {2022},
  month = apr,
  pages = {1518--1518},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00089},
  abstract = {Microarchitectural side-channel attacks are enjoying a time of explosive growth, mostly fueled by novel transient execution vulnerabilities. These attacks are capable of leaking arbitrary data, as long as it is possible for the adversary to read that data into the processor core using transient instructions. In this paper, we present the first microarchitectural attack that leaks \textbackslash emph\{data at rest\} in the memory system, i.e., never directly read into the core speculatively or non-speculatively. This technique is enabled by a previously unreported class of prefetcher: a data memory-dependent prefetcher (DMP). These prefetchers are designed to allow prefetching of irregular address patterns such as pointer chases. As such, DMPs examine and use the contents of memory directly to determine which addresses to prefetch. Our experiments demonstrate the existence of a pointer-chasing DMP on recent Apple processors, including the A14 and M1. We then reverse engineer the details of this DMP to determine the opportunities for and restrictions it places on attackers using it. Finally, we demonstrate several basic attack primitives capable of leaking pointer values using the DMP.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ADBZGE4Z\\1CIO7lTregM.html}
}

@inproceedings{volos2018graviton,
  title = {Graviton: {{Trusted Execution Environments}} on {{GPUs}}},
  shorttitle = {Graviton},
  booktitle = {13th {{USENIX Symposium}} on {{Operating Systems Design}} and {{Implementation}} ({{OSDI}} 18)},
  author = {Volos, Stavros and Vaswani, Kapil and Bruno, Rodrigo},
  year = {2018},
  pages = {681--696},
  isbn = {978-1-939133-08-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\3VQQYKNJ\\Volos et al. - 2018 - Graviton Trusted Execution Environments on GPUs .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\L8EGVM5U\\volos.html}
}

@inproceedings{voulimeneas2022you,
  title = {You Shall Not (by)Pass! Practical, Secure, and Fast {{PKU-based}} Sandboxing},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Voulimeneas, Alexios and Vinck, Jonas and Mechelinck, Ruben and Volckaert, Stijn},
  year = {2022},
  month = mar,
  series = {{{EuroSys}} '22},
  pages = {266--282},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3492321.3519560},
  abstract = {Memory Protection Keys for Userspace (PKU) is a recent hardware feature that allows programs to assign virtual memory pages to protection domains, and to change domain access permissions using inexpensive, unprivileged instructions. Several in-process memory isolation approaches leverage this feature to prevent untrusted code from accessing sensitive program state and data. Typically, PKU-based isolation schemes need to be used in conjunction with mitigations such as CFI because untrusted code, when compromised, can otherwise bypass the PKU access permissions using unprivileged instructions or operating system APIs. Recently, researchers proposed fully self-contained PKU-based memory isolation schemes that do not rely on other mitigations. These systems use exploit-proof call gates to transfer control between trusted and untrusted code, as well as a sandbox that prevents tampering with the PKU infrastructure from untrusted code. In this paper, we show that these solutions are not complete. We first develop two proof-of-concept attacks against a state-of-the-art PKU-based memory isolation scheme. We then present Cerberus, a PKU-based sandboxing framework that can overcome limitations of existing sandboxes. We apply Cerberus to several memory isolation schemes, and show that it is practical, efficient, and secure.},
  isbn = {978-1-4503-9162-7},
  keywords = {in-process isolation,PKU,sanboxing,security},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\Z6X2VIJL\\Voulimeneas et al. - 2022 - You shall not (by)pass! practical, secure, and fas.pdf}
}

@inproceedings{wang2015binary,
  title = {Binary {{Code Continent}}: {{Finer-Grained Control Flow Integrity}} for {{Stripped Binaries}}},
  shorttitle = {Binary {{Code Continent}}},
  booktitle = {Proceedings of the 31st {{Annual Computer Security Applications Conference}}},
  author = {Wang, Minghua and Yin, Heng and Bhaskar, Abhishek Vasisht and Su, Purui and Feng, Dengguo},
  year = {2015},
  month = dec,
  series = {{{ACSAC}} '15},
  pages = {331--340},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2818000.2818017},
  abstract = {Control Flow Integrity (CFI) is an effective technique to mitigate threats such as code-injection and code-reuse attacks in programs by protecting indirect transfers. For stripped binaries, a CFI policy has to be made conservatively due to the lack of source code level semantics. Existing binary-only CFI solutions such as BinCFI and CCFIR demonstrate the ability to protect stripped binaries, but the policies they apply are too permissive, allowing sophisticated code-reuse attacks. In this paper, we propose a new binary-only CFI protection scheme called BinCC, which applies static binary rewriting to provide finer-grained protection for x86 stripped ELF binaries. Through code duplication and static analysis, we divide the binary code into several mutually exclusive code continents. We further classify each indirect transfer within a code continent as either an Intra-Continent transfer or an Inter-Continent transfer, and apply separate, strict CFI polices to constrain these transfers. To evaluate BinCC, we introduce new metrics to estimate the average amount of legitimate targets of each kind of indirect transfer as well as the difficulty to leverage call preceded gadgets to generate ROP exploits. Compared to the state of the art binary-only CFI, BinCFI, the experimental results show that BinCC significantly reduces the legitimate transfer targets by 81.34\% and increases the difficulty for adversaries to bypass CFI restriction to launch sophisticated ROP attacks. Also, BinCC achieves a reasonable performance, around 14\% of the space overhead decrease and only 4\% runtime overhead increase as compared to BinCFI.},
  isbn = {978-1-4503-3682-6},
  keywords = {Control Flow Integrity},
  annotation = {30 citations (Semantic Scholar/DOI) [2022-10-24]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\FELNIS9K\\Wang et al. - 2015 - Binary Code Continent Finer-Grained Control Flow .pdf}
}

@inproceedings{wang2017how,
  title = {How \{\vphantom\}{{Double-Fetch}}\vphantom\{\} {{Situations}} Turn into \{\vphantom\}{{Double-Fetch}}\vphantom\{\} {{Vulnerabilities}}: {{A Study}} of {{Double Fetches}} in the {{Linux Kernel}}},
  shorttitle = {How \{\vphantom\}{{Double-Fetch}}\vphantom\{\} {{Situations}} Turn into \{\vphantom\}{{Double-Fetch}}\vphantom\{\} {{Vulnerabilities}}},
  booktitle = {26th {{USENIX Security Symposium}} ({{USENIX Security}} 17)},
  author = {Wang, Pengfei and Krinke, Jens and Lu, Kai and Li, Gen and {Dodier-Lazaro}, Steve},
  year = {2017},
  pages = {1--16},
  isbn = {978-1-931971-40-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6N7Y76AX\\Wang et al. - 2017 - How Double-Fetch Situations turn into Double-Fe.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\H65PQ2HK\\wang-pengfei.html}
}

@inproceedings{wang2018check,
  title = {Check {{It Again}}: {{Detecting Lacking-Recheck Bugs}} in {{OS Kernels}}},
  shorttitle = {Check {{It Again}}},
  booktitle = {Proceedings of the 2018 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Wang, Wenwen and Lu, Kangjie and Yew, Pen-Chung},
  year = {2018},
  month = oct,
  series = {{{CCS}} '18},
  pages = {1899--1913},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3243734.3243844},
  abstract = {Operating system kernels carry a large number of security checks to validate security-sensitive variables and operations. For example, a security check should be embedded in a code to ensure that a user-supplied pointer does not point to the kernel space. Using security-checked variables is typically safe. However, in reality, security-checked variables are often subject to modification after the check. If a recheck is lacking after a modification, security issues may arise, e.g., adversaries can control the checked variable to launch critical attacks such as out-of-bound memory access or privilege escalation. We call such cases lacking-recheck (LRC) bugs, a subclass of TOCTTOU bugs, which have not been explored yet. In this paper, we present the first in-depth study of LRC bugs and develop LRSan, a static analysis system that systematically detects LRC bugs in OS kernels. Using an inter-procedural analysis and multiple new techniques, LRSan first automatically identifies security checks, critical variables, and uses of the checked variables, and then reasons about whether a modification is present after a security check. A case in which a modification is present but a recheck is lacking is an LRC bug. We apply LRSan to the latest Linux kernel and evaluate the effectiveness of LRSan. LRSan reports thousands of potential LRC cases, and we have confirmed 19 new LRC bugs. We also discuss patching strategies of LRC bugs based on our study and bug-fixing experience.},
  isbn = {978-1-4503-5693-0},
  keywords = {error code,lacking-recheck,missing check,OS kernel bug,static analysis,TOCTTOU},
  annotation = {27 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\97AR5VX9\\Wang et al. - 2018 - Check It Again Detecting Lacking-Recheck Bugs in .pdf}
}

@inproceedings{wang2018peeking,
  title = {Peeking {{Behind}} the {{Curtains}} of {{Serverless Platforms}}},
  booktitle = {2018 {{USENIX Annual Technical Conference}} ({{USENIX ATC}} 18)},
  author = {Wang, Liang and Li, Mengyuan and Zhang, Yinqian and Ristenpart, Thomas and Swift, Michael},
  year = {2018},
  pages = {133--146},
  isbn = {978-1-939133-01-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\RH4ID92E\\Wang et al. - 2018 - Peeking Behind the Curtains of Serverless Platform.pdf}
}

@inproceedings{wang2019memory,
  title = {Towards {{Memory Safe Enclave Programming}} with {{Rust-SGX}}},
  booktitle = {Proceedings of the 2019 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Wang, Huibo and Wang, Pei and Ding, Yu and Sun, Mingshen and Jing, Yiming and Duan, Ran and Li, Long and Zhang, Yulong and Wei, Tao and Lin, Zhiqiang},
  year = {2019},
  month = nov,
  series = {{{CCS}} '19},
  pages = {2333--2350},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3319535.3354241},
  abstract = {Intel Software Guard eXtension (SGX), a hardware supported trusted execution environment (TEE), is designed to protect security critical applications. However, it does not terminate traditional memory corruption vulnerabilities for the software running inside enclave, since enclave software is still developed with type unsafe languages such as C/C++. This paper presents RUST-SGX, an efficient and layered approach to exterminating memory corruption for software running inside SGX enclaves. The key idea is to enable the development of enclave programs with an efficient memory safe system language Rust with a RUST-SGX SDK by solving the key challenges of how to (1) make the SGX software memory safe and (2) meanwhile run as efficiently as with the SDK provided by Intel. We therefore propose to build RUST-SGX atop Intel SGX SDK, and tame unsafe components with formally proven memory safety. We have implemented RUST-SGX and tested with a series of benchmark programs. Our evaluation results show that RUST-SGX imposes little extra overhead (less than 5\% with respect to the SGX specific features and services compared to software developed by Intel SGX SDK), and meanwhile have stronger memory safety.},
  isbn = {978-1-4503-6747-9},
  keywords = {memory safety,rust programming language,SGX,type system soundness},
  annotation = {46 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\8FKHK6AC\\Wang et al. - 2019 - Towards Memory Safe Enclave Programming with Rust-.pdf}
}

@inproceedings{wang2020seimi,
  title = {{{SEIMI}}: {{Efficient}} and {{Secure SMAP-Enabled Intra-process Memory Isolation}}},
  shorttitle = {{{SEIMI}}},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Wang, Zhe and Wu, Chenggang and Xie, Mengyao and Zhang, Yinqian and Lu, Kangjie and Zhang, Xiaofeng and Lai, Yuanming and Kang, Yan and Yang, Min},
  year = {2020},
  month = may,
  pages = {592--607},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00087},
  abstract = {Memory-corruption attacks such as code-reuse attacks and data-only attacks have been a key threat to systems security. To counter these threats, researchers have proposed a variety of defenses, including control-flow integrity (CFI), code-pointer integrity (CPI), and code (re-)randomization. All of them, to be effective, require a security primitive-intra-process protection of confidentiality and/or integrity for sensitive data (such as CFI's shadow stack and CPI's safe region).In this paper, we propose SEIMI, a highly efficient intra-process memory isolation technique for memory-corruption defenses to protect their sensitive data. The core of SEIMI is to use the efficient Supervisor-mode Access Prevention (SMAP), a hardware feature that is originally used for preventing the kernel from accessing the user space, to achieve intra-process memory isolation. To leverage SMAP, SEIMI creatively executes the user code in the privileged mode. In addition to enabling the new design of the SMAP-based memory isolation, we further develop multiple new techniques to ensure secure escalation of user code, e.g., using the descriptor caches to capture the potential segment operations and configuring the Virtual Machine Control Structure (VMCS) to invalidate the execution result of the control registers related operations. Extensive experimental results show that SEIMI outperforms existing isolation mechanisms, including both the Memory Protection Keys (MPK) based scheme and the Memory Protection Extensions (MPX) based scheme, while providing secure memory isolation.},
  keywords = {Data structures,Hardware,Kernel,Registers,Runtime,Security,Switches},
  annotation = {8 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ILIYYS2E\\Wang et al. - 2020 - SEIMI Efficient and Secure SMAP-Enabled Intra-pro.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\KGAGBCNT\\9152611.html}
}

@inproceedings{wang2022rttee,
  title = {{{RT-TEE}}: {{Real-time System Availability}} for {{Cyber-physical Systems}} Using {{ARM TrustZone}}},
  shorttitle = {{{RT-TEE}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Wang, Jinwen and Li, Ao and Li, Haoran and Lu, Chenyang and Zhang, Ning},
  year = {2022},
  month = apr,
  pages = {1573--1573},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00144},
  abstract = {Embedded devices are becoming increasingly pervasive in safety-critical systems of the emerging cyber-physical world. While trusted execution environments (TEEs), such as ARM TrustZone, have been widely deployed in mobile platforms, little attention has been given to deployment on real-time cyber-physical systems, which present a different set of challenges compared to mobile applications. For safety-critical cyber-physical systems, such as autonomous drones or automobiles, the current TEE deployment paradigm, which focuses only on confidentiality and integrity, is insufficient. Computation in these systems also needs to be completed in a timely manner (e.g., before the car hits a pedestrian), putting a much stronger emphasis on availability.  To bridge this gap, we present RT-TEE, a real-time trusted execution environment. There are three key research challenges. First, RT-TEE bootstraps the ability to ensure availability using a minimal set of hardware primitives on commodity embedded platforms. Second, to balance real-time performance and scheduler complexity, we designed a policy-based event-driven hierarchical scheduler. Third, to mitigate the risks of having device drivers in the secure environment, we designed an I/O reference monitor that leverages software sandboxing and driver debloating to provide fine-grained access control on peripherals while minimizing the trusted computing base (TCB).  We implemented prototypes on both ARMv8-A and ARMv8-M platforms. The system is tested on both synthetic tasks and real-life CPS applications. We evaluated rover and plane in simulation and quadcopter both in simulation and with a real drone.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QBEUKIZG\\1CIO8rGJko8.html}
}

@inproceedings{watson2015cheri,
  title = {{{CHERI}}: {{A Hybrid Capability-System Architecture}} for {{Scalable Software Compartmentalization}}},
  shorttitle = {{{CHERI}}},
  booktitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Watson, Robert N.M. and Woodruff, Jonathan and Neumann, Peter G. and Moore, Simon W. and Anderson, Jonathan and Chisnall, David and Dave, Nirav and Davis, Brooks and Gudka, Khilan and Laurie, Ben and Murdoch, Steven J. and Norton, Robert and Roe, Michael and Son, Stacey and Vadera, Munraj},
  year = {2015},
  month = may,
  pages = {20--37},
  issn = {2375-1207},
  doi = {10.1109/SP.2015.9},
  abstract = {CHERI extends a conventional RISC Instruction-Set Architecture, compiler, and operating system to support fine-grained, capability-based memory protection to mitigate memory-related vulnerabilities in C-language TCBs. We describe how CHERI capabilities can also underpin a hardware-software object-capability model for application compartmentalization that can mitigate broader classes of attack. Prototyped as an extension to the open-source 64-bit BERI RISC FPGA soft-core processor, Free BSD operating system, and LLVM compiler, we demonstrate multiple orders-of-magnitude improvement in scalability, simplified programmability, and resulting tangible security benefits as compared to compartmentalization based on pure Memory-Management Unit (MMU) designs. We evaluate incrementally deployable CHERI-based compartmentalization using several real-world UNIX libraries and applications.},
  keywords = {capability system,cheri,CHERI processor,computer architecture,Hardware,Kernel,Libraries,memory protection,object capabilities,Reduced instruction set computing,Registers,Security,software compartmentalization},
  annotation = {176 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\93BQW6TF\\Watson et al. - 2015 - CHERI A Hybrid Capability-System Architecture for.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\IZ97RGGU\\7163016.html}
}

@article{watsoncapsicum,
  title = {Capsicum: Practical Capabilities for {{UNIX}}},
  author = {Watson, Robert N M and Anderson, Jonathan and Kennaway, Kris and Laurie, Ben},
  pages = {17},
  abstract = {Capsicum is a lightweight operating system capability and sandbox framework planned for inclusion in FreeBSD 9. Capsicum extends, rather than replaces, UNIX APIs, providing new kernel primitives (sandboxed capability mode and capabilities) and a userspace sandbox API. These tools support compartmentalisation of monolithic UNIX applications into logical applications, an increasingly common goal supported poorly by discretionary and mandatory access control. We demonstrate our approach by adapting core FreeBSD utilities and Google's Chromium web browser to use Capsicum primitives, and compare the complexity and robustness of Capsicum with other sandboxing techniques.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XNGVJQN7\\Watson et al. - Capsicum practical capabilities for UNIX.pdf}
}

@misc{welcome,
  title = {Welcome to {{G}}.{{O}}.{{S}}.{{S}}.{{I}}.{{P}} {$\cdot$}},
  howpublished = {https://gossip.team/},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\B5H4U4S8\\gossip.team.html}
}

@article{wenzl2020hack,
  title = {From {{Hack}} to {{Elaborate Technique}}\textemdash{{A Survey}} on {{Binary Rewriting}}},
  author = {Wenzl, Matthias and Merzdovnik, Georg and Ullrich, Johanna and Weippl, Edgar},
  year = {2020},
  month = may,
  journal = {ACM Computing Surveys},
  volume = {52},
  number = {3},
  pages = {1--37},
  issn = {0360-0300, 1557-7341},
  doi = {10.1145/3316415},
  abstract = {Binary rewriting is changing the semantics of a program without having the source code at hand. It is used for diverse purposes, such as emulation (e.g., QEMU), optimization (e.g., DynInst), observation (e.g., Valgrind), and hardening (e.g., Control flow integrity enforcement). This survey gives detailed insight into the development and state-of-the-art in binary rewriting by reviewing 67 publications from 1966 to 2018. Starting from these publications, we provide an in-depth investigation of the challenges and respective solutions to accomplish binary rewriting. Based on our findings, we establish a thorough categorization of binary rewriting approaches with respect to their use-case, applied analysis technique, code-transformation method, and code generation techniques. We contribute a comprehensive mapping between binary rewriting tools, applied techniques, and their domain of application. Our findings emphasize that although much work has been done over the past decades, most of the effort was put into improvements aiming at rewriting general purpose applications but ignoring other challenges like altering throughput-oriented programs or software with real-time requirements, which are often used in the emerging field of the Internet of Things. To the best of our knowledge, our survey is the first comprehensive overview on the complete binary rewriting process.},
  langid = {english},
  keywords = {binary analysis,binary rewrite,csur},
  annotation = {31 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\A8UA8ISA\\Wenzl et al. - 2020 - From Hack to Elaborate Techniqueâ€”A Survey on Binar.pdf}
}

@inproceedings{wesleyfilardo2020cornucopia,
  title = {Cornucopia: {{Temporal Safety}} for {{CHERI Heaps}}},
  shorttitle = {Cornucopia},
  booktitle = {2020 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Wesley Filardo, Nathaniel and Gutstein, Brett F. and Woodruff, Jonathan and Ainsworth, Sam and {Paul-Trifu}, Lucian and Davis, Brooks and Xia, Hongyan and Tomasz Napierala, Edward and Richardson, Alexander and Baldwin, John and Chisnall, David and Clarke, Jessica and Gudka, Khilan and Joannou, Alexandre and Theodore Markettos, A. and Mazzinghi, Alfredo and Norton, Robert M. and Roe, Michael and Sewell, Peter and Son, Stacey and Jones, Timothy M. and Moore, Simon W. and Neumann, Peter G. and Watson, Robert N. M.},
  year = {2020},
  month = may,
  pages = {608--625},
  issn = {2375-1207},
  doi = {10.1109/SP40000.2020.00098},
  abstract = {Use-after-free violations of temporal memory safety continue to plague software systems, underpinning many high-impact exploits. The CHERI capability system shows great promise in achieving C and C++ language spatial memory safety, preventing out-of-bounds accesses. Enforcing language-level temporal safety on CHERI requires capability revocation, traditionally achieved either via table lookups (avoided for performance in the CHERI design) or by identifying capabilities in memory to revoke them (similar to a garbage-collector sweep). CHERIvoke, a prior feasibility study, suggested that CHERI's tagged capabilities could make this latter strategy viable, but modeled only architectural limits and did not consider the full implementation or evaluation of the approach.Cornucopia is a lightweight capability revocation system for CHERI that implements non-probabilistic C/C++ temporal memory safety for standard heap allocations. It extends the CheriBSD virtual-memory subsystem to track capability flow through memory and provides a concurrent kernel-resident revocation service that is amenable to multi-processor and hardware acceleration. We demonstrate an average overhead of less than 2\% and a worst-case of 8.9\% for concurrent revocation on compatible SPEC CPU2006 benchmarks on a multi-core CHERI CPU on FPGA, and we validate Cornucopia against the Juliet test suite's corpus of temporally unsafe programs. We test its compatibility with a large corpus of C programs by using a revoking allocator as the system allocator while booting multi-user CheriBSD. Cornucopia is a viable strategy for always-on temporal heap memory safety, suitable for production environments.},
  keywords = {cheri,Integrated circuits,Licenses,Privacy,RNA,Security},
  annotation = {16 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\973QHY48\\Wesley Filardo et al. - 2020 - Cornucopia Temporal Safety for CHERI Heaps.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\FLZRLVCL\\9152640.html}
}

@article{whitesides2004whitesides,
  title = {Whitesides' {{Group}}: {{Writing}} a {{Paper}}},
  shorttitle = {Whitesides' {{Group}}},
  author = {Whitesides, G. M.},
  year = {2004},
  month = aug,
  journal = {Advanced Materials},
  volume = {16},
  number = {15},
  pages = {1375--1377},
  issn = {0935-9648, 1521-4095},
  doi = {10.1002/adma.200400767},
  langid = {english},
  annotation = {85 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\2CDGIYDW\\Whitesides - 2004 - Whitesides' Group Writing a Paper.pdf}
}

@inproceedings{wickman2021preventing,
  title = {Preventing {{Use-After-Free Attacks}} with {{Fast Forward Allocation}}},
  booktitle = {30th {{USENIX Security Symposium}} ({{USENIX Security}} 21)},
  author = {Wickman, Brian and Hu, Hong and Yun, Insu and Jang, Daehee and Lim, JungWon and Kashyap, Sanidhya and Kim, Taesoo},
  year = {2021},
  pages = {2453--2470},
  isbn = {978-1-939133-24-3},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7N4KKJJJ\\Wickman et al. - 2021 - Preventing Use-After-Free Attacks with Fast Forw.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\2BDTR2JB\\wickman.html}
}

@book{williams1990style,
  title = {Style: Toward Clarity and Grace},
  shorttitle = {Style},
  author = {Williams, Joseph M.},
  year = {1990},
  series = {Chicago Guides to Writing, Editing, and Publishing},
  publisher = {{University of Chicago Press}},
  address = {{Chicago}},
  isbn = {978-0-226-89914-5},
  langid = {english},
  lccn = {PE1421 .W546 1990},
  keywords = {English language,Style},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\PF29UUKV\\Williams - 1990 - Style toward clarity and grace.pdf}
}

@book{williams2014style,
  title = {Style: Lessons in Clarity and Grace},
  shorttitle = {Style},
  author = {Williams, Joseph M. and Bizup, Joseph},
  year = {2014},
  edition = {Eleventh edition},
  publisher = {{Pearson}},
  address = {{Boston}},
  isbn = {978-0-321-89868-5},
  langid = {english},
  lccn = {PE1421 .W545 2014},
  keywords = {Business English,Business writing,English language,Rhetoric,Style,Technical English,Technical writing},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\S6VDRFFV\\Williams and Bizup - 2014 - Style lessons in clarity and grace.pdf}
}

@inproceedings{woodruff2014cheri,
  title = {The {{CHERI}} Capability Model: {{Revisiting RISC}} in an Age of Risk},
  shorttitle = {The {{CHERI}} Capability Model},
  booktitle = {2014 {{ACM}}/{{IEEE}} 41st {{International Symposium}} on {{Computer Architecture}} ({{ISCA}})},
  author = {Woodruff, Jonathan and Watson, Robert N. M. and Chisnall, David and Moore, Simon W. and Anderson, Jonathan and Davis, Brooks and Laurie, Ben and Neumann, Peter G. and Norton, Robert and Roe, Michael},
  year = {2014},
  month = jun,
  pages = {457--468},
  issn = {1063-6897},
  doi = {10.1109/ISCA.2014.6853201},
  abstract = {Motivated by contemporary security challenges, we reevaluate and refine capability-based addressing for the RISC era. We present CHERI, a hybrid capability model that extends the 64-bit MIPS ISA with byte-granularity memory protection. We demonstrate that CHERI enables language memory model enforcement and fault isolation in hardware rather than software, and that the CHERI mechanisms are easily adopted by existing programs for efficient in-program memory safety. In contrast to past capability models, CHERI complements, rather than replaces, the ubiquitous page-based protection mechanism, providing a migration path towards deconflating data-structure protection and OS memory management. Furthermore. CHERI adheres to a strict RISC philosophy: it maintains a load-store architecture and requires only single-cycle instructions, and supplies protection primitives to the compiler, language runtime, and operating system. We demonstrate a mature FPGA implementation that runs the FreeBSD operating system with a full range of software and an open-source application suite compiled with an extended LLVM to use CHERI memory protection. A limit study compares published memory safety mechanisms in terms of instruction count and memory overheads. The study illustrates that CHERI is performance-competitive even while providing assurance and greater flexibility with simpler hardware.},
  keywords = {Abstracts,Coprocessors,Ground penetrating radar,Registers,Safety},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\K9XKVIQX\\Woodruff et al. - 2014 - The CHERI capability model Revisiting RISC in an .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\HNRBVCGD\\6853201.html}
}

@misc{writing,
  title = {Writing {{Systems}} and {{Networking Articles}}},
  howpublished = {https://www.cs.columbia.edu/\textasciitilde hgs/etc/writing-style.html},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SFDGRXMN\\writing-style.html}
}

@article{wu2022dancing,
  title = {Dancing with {{Wolves}}: {{An Intra-process Isolation Technique}} with {{Privileged Hardware}}},
  shorttitle = {Dancing with {{Wolves}}},
  author = {Wu, Chenggang and Xie, Mengyao and Wang, Zhe and Zhang, Yinqian and Lu, Kangjie and Zhang, Xiaofeng and Lai, Yuanming and Kang, Yan and Yang, Min and Li, Tao},
  year = {2022},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  pages = {1--1},
  issn = {1941-0018},
  doi = {10.1109/TDSC.2022.3168089},
  abstract = {Intra-process memory isolation is a cornerstone technique of protecting the sensitive data in memory-corruption defenses, such as the shadow stack in control flow integrity (CFI) and the safe region in code pointer integrity (CPI). In this paper, we propose SEIMI, a highly efficient intra-process memory isolation technique for memory-corruption defenses. The core is to use the efficient Supervisor-mode Access Prevention (SMAP), a hardware feature that is originally used for preventing the kernel from accessing the user space, to achieve intra-process memory isolation. To leverage SMAP, SEIMI creatively executes the user code in the privileged mode. In addition to enabling the new design of the SMAP-based memory isolation, we further develop multiple new techniques to ensure secure escalation of user code. Extensive experiments show that SEIMI outperforms existing isolation mechanisms, including the Memory Protection Keys (MPK) based scheme and the Memory Protection Extensions (MPX) based scheme.},
  keywords = {Codes,Hardware,Intel Supervisor-mode Access Prevention,Intra-process Memory Isolation,Kernel,Registers,Runtime,Security,Virtualization},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\NGW8MXXX\\Wu et al. - 2022 - Dancing with Wolves An Intra-process Isolation Te.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\YC6ZWM98\\9760152.html}
}

@inproceedings{xia2018cherirtos,
  title = {{{CheriRTOS}}: {{A Capability Model}} for {{Embedded Devices}}},
  shorttitle = {{{CheriRTOS}}},
  booktitle = {2018 {{IEEE}} 36th {{International Conference}} on {{Computer Design}} ({{ICCD}})},
  author = {Xia, Hongyan and Woodruff, Jonathan and Barral, Hadrien and Esswood, Lawrence and Joannou, Alexandre and Kovacsics, Robert and Chisnall, David and Roe, Michael and Davis, Brooks and Napierala, Edward and Baldwin, John and Gudka, Khilan and Neumann, Peter G. and Richardson, Alexander and Moore, Simon W. and Watson, Robert N. M.},
  year = {2018},
  month = oct,
  pages = {92--99},
  issn = {2576-6996},
  doi = {10.1109/ICCD.2018.00023},
  abstract = {Embedded systems are deployed ubiquitously among various sectors including automotive, medical, robotics and avionics. As these devices become increasingly connected, the attack surface also increases tremendously; new mechanisms must be deployed to defend against more sophisticated attacks while not violating resource constraints. In this paper we present CheriRTOS on CHERI-64, a hardware-software platform atop Capability Hardware Enhanced RISC Instructions (CHERI) for embedded systems. Our system provides efficient and scalable task isolation, fast and secure inter-task communication, fine-grained memory safety, and real-time guarantees, using hardware capabilities as the sole protection mechanism. We summarize state-of-the-art security and memory safety for embedded systems for comparison with our platform, illustrating the superior substrate provided by CHERI's capabilities. Finally, our evaluations show that a capability system can be implemented within the constraints of embedded systems.},
  keywords = {capability systems,CHERI,embedded systems,Embedded systems,Hardware,Kernel,memory safety,real time operating systems,Real-time systems,Safety,security,Security,Task analysis},
  annotation = {6 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\AQ5RVY5J\\Xia et al. - 2018 - CheriRTOS A Capability Model for Embedded Devices.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\GCJUBDKI\\8615673.html}
}

@inproceedings{xia2019cherivoke,
  title = {{{CHERIvoke}}: {{Characterising Pointer Revocation}} Using {{CHERI Capabilities}} for {{Temporal Memory Safety}}},
  shorttitle = {{{CHERIvoke}}},
  booktitle = {Proceedings of the 52nd {{Annual IEEE}}/{{ACM International Symposium}} on {{Microarchitecture}}},
  author = {Xia, Hongyan and Woodruff, Jonathan and Ainsworth, Sam and Filardo, Nathaniel W. and Roe, Michael and Richardson, Alexander and Rugg, Peter and Neumann, Peter G. and Moore, Simon W. and Watson, Robert N. M. and Jones, Timothy M.},
  year = {2019},
  month = oct,
  series = {{{MICRO}} '52},
  pages = {545--557},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3352460.3358288},
  abstract = {A lack of temporal safety in low-level languages has led to an epidemic of use-after-free exploits. These have surpassed in number and severity even the infamous buffer-overflow exploits violating spatial safety. Capability addressing can directly enforce spatial safety for the C language by enforcing bounds on pointers and by rendering pointers unforgeable. Nevertheless, an efficient solution for strong temporal memory safety remains elusive. CHERI is an architectural extension to provide hardware capability addressing that is seeing significant commercial and open-source interest. We show that CHERI capabilities can be used as a foundation to enable low-cost heap temporal safety by facilitating out-of-date pointer revocation, as capabilities enable precise and efficient identification and invalidation of pointers, even when using unsafe languages such as C. We develop CHERIvoke, a technique for deterministic and fast sweeping revocation to enforce temporal safety on CHERI systems. CHERIvoke quarantines freed data before periodically using a small shadow map to revoke all dangling pointers in a single sweep of memory, and provides a tunable trade-off between performance and heap growth. We evaluate the performance of such a system using high-performance x86 processors, and further analytically examine its primary overheads. When configured with a heap-size overhead of 25\%, we find that CHERIvoke achieves an average execution-time overhead of under 5\%, far below the overheads associated with traditional garbage collection, revocation, or page-table systems.},
  isbn = {978-1-4503-6938-1},
  keywords = {architecture,security,temporal safety,use-after-free},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\6IS7EFCM\\Xia et al. - 2019 - CHERIvoke Characterising Pointer Revocation using.pdf}
}

@inproceedings{xia2022secretfree,
  title = {A {{Secret-Free Hypervisor}}: {{Rethinking Isolation}} in the {{Age}} of {{Speculative Vulnerabilities}}},
  shorttitle = {A {{Secret-Free Hypervisor}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Xia, Hongyan and Zhang, David and Liu, Wei and Haller, Istvan and Sherwin, Bruce and Chisnall, David},
  year = {2022},
  month = apr,
  pages = {1544--1544},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00115},
  abstract = {In recent years, the epidemic of speculative side channels significantly increases the difficulty in enforcing domain isolation boundaries in a virtualized cloud environment. Although mitigations exist, the approach taken by the industry is neither a long-term nor a scalable solution, as we target each vulnerability with specific mitigations that add up to substantial performance penalties. We propose a different approach to secret isolation: guaranteeing that the hypervisor is Secret-Free (SF). A Secret-Free design partitions memory into secrets and non-secrets and reconstructs hypervisor isolation. It enforces that all domains have a minimal and secret-free view of the address space. In contrast to state-of-the-art, a Secret-Free hypervisor does not identify secrets to be hidden, but instead identifies non-secrets that can be shared, and only grants access necessary for the current operation, an allow-list approach. SF designs function with existing hardware and do not exhibit noticeable performance penalties in production workloads versus the unmitigated baseline, and outperform state-of-the-art techniques by allowing speculative execution where secrets are invisible. We implement SF in Xen (a Type-I hypervisor) to demonstrate that the design applies well to a commercial hypervisor. Evaluation shows performance comparable to baseline and up to 37\% improvement in certain hypervisor paths compared with Xen default mitigations. Further, we demonstrate Secret-Free is a generic kernel isolation infrastructure for a variety of systems, not limited to Type-I hypervisors. We apply the same model in Hyper-V (Type-I), bhyve (Type-II) and FreeBSD (UNIX kernel) to evaluate its applicability and effectiveness. The successful implementations on these systems prove the generality of SF, and reveal the specific adaptations and optimizations required for each type of kernel.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\GH8WKIU5\\1CIO7QllknS.html}
}

@inproceedings{xin2020subdomainbased,
  title = {Subdomain-Based Generality-Aware Debloating},
  booktitle = {Proceedings of the 35th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  author = {Xin, Qi and Kim, Myeongsoo and Zhang, Qirun and Orso, Alessandro},
  year = {2020},
  month = dec,
  series = {{{ASE}} '20},
  pages = {224--236},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3324884.3416644},
  abstract = {Programs are becoming increasingly complex and typically contain an abundance of unneeded features, which can degrade the performance and security of the software. Recently, we have witnessed a surge of debloating techniques that aim to create a reduced version of a program by eliminating the unneeded features therein. To debloat a program, most existing techniques require a usage profile of the program, typically provided as a set of inputs I. Unfortunately, these techniques tend to generate a reduced program that is over-fitted to I and thus fails to behave correctly for other inputs. To address this limitation, we propose DomGad, which has two main advantages over existing debloating approaches. First, it produces a reduced program that is guaranteed to work for subdomains, rather than for specific inputs. Second, it uses stochastic optimization to generate reduced programs that achieve a close-to-optimal tradeoff between reduction and generality (i.e., the extent to which the reduced program is able to correctly handle inputs in its whole domain). To assess the effectiveness of DomGad, we applied our approach to a benchmark of ten Unix utility programs. Our results are promising, as they show that DomGad could produce debloated programs that achieve, on average, 50\% code reduction and 95\% generality. Our results also show that DomGad performs well when compared with two state-of-the-art debloating approaches.},
  isbn = {978-1-4503-6768-4},
  keywords = {debloating,generality-aware,stochastic optimization},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WPCMZQLP\\Xin et al. - 2020 - Subdomain-based generality-aware debloating.pdf}
}

@inproceedings{xu2015controlledchannel,
  title = {Controlled-{{Channel Attacks}}: {{Deterministic Side Channels}} for {{Untrusted Operating Systems}}},
  shorttitle = {Controlled-{{Channel Attacks}}},
  booktitle = {2015 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Xu, Yuanzhong and Cui, Weidong and Peinado, Marcus},
  year = {2015},
  month = may,
  pages = {640--656},
  issn = {2375-1207},
  doi = {10.1109/SP.2015.45},
  abstract = {The presence of large numbers of security vulnerabilities in popular feature-rich commodity operating systems has inspired a long line of work on excluding these operating systems from the trusted computing base of applications, while retaining many of their benefits. Legacy applications continue to run on the untrusted operating system, while a small hyper visor or trusted hardware prevents the operating system from accessing the applications' memory. In this paper, we introduce controlled-channel attacks, a new type of side-channel attack that allows an untrusted operating system to extract large amounts of sensitive information from protected applications on systems like Overshadow, Ink Tag or Haven. We implement the attacks on Haven and Ink Tag and demonstrate their power by extracting complete text documents and outlines of JPEG images from widely deployed application libraries. Given these attacks, it is unclear if Over shadow's vision of protecting unmodified legacy applications from legacy operating systems running on off-the-shelf hardware is still tenable.},
  keywords = {Control systems,Data mining,Hardware,Monitoring,Operating systems,Resource management,SGX,side-channel attack,untrusted operating system,Virtual machine monitors,virtualization},
  annotation = {617 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\5GACVKS3\\Xu et al. - 2015 - Controlled-Channel Attacks Deterministic Side Cha.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\YP6MWD5S\\7163052.html}
}

@inproceedings{xu2018precise,
  title = {Precise and {{Scalable Detection}} of {{Double-Fetch Bugs}} in {{OS Kernels}}},
  booktitle = {2018 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Xu, Meng and Qian, Chenxiong and Lu, Kangjie and Backes, Michael and Kim, Taesoo},
  year = {2018},
  month = may,
  pages = {661--678},
  issn = {2375-1207},
  doi = {10.1109/SP.2018.00017},
  abstract = {During system call execution, it is common for operating system kernels to read userspace memory multiple times (multi-reads). A critical bug may exist if the fetched userspace memory is subject to change across these reads, i.e., a race condition, which is known as a double-fetch bug. Prior works have attempted to detect these bugs both statically and dynamically. However, due to their improper assumptions and imprecise definitions regarding double-fetch bugs, their multi-read detection is inherently limited and suffers from significant false positives and false negatives. For example, their approach is unable to support device emulation, inter-procedural analysis, loop handling, etc. More importantly, they completely leave the task of finding real double-fetch bugs from the haystack of multi-reads to manual verification, which is expensive if possible at all. In this paper, we first present a formal and precise definition of double-fetch bugs and then implement a static analysis system - Deadline - to automatically detect double-fetch bugs in OS kernels. Deadline uses static program analysis techniques to systematically find multi-reads throughout the kernel and employs specialized symbolic checking to vet each multi-read for double-fetch bugs. We apply Deadline to Linux and FreeBSD kernels and find 23 new bugs in Linux and one new bug in FreeBSD. We further propose four generic strategies to patch and prevent double-fetch bugs based on our study and the discussion with kernel maintainers.},
  keywords = {bug,Computer bugs,detection,kernel,Kernel,Linux,Manuals,Memory management,Protocols},
  annotation = {47 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\E2HFKNZ2\\Xu et al. - 2018 - Precise and Scalable Detection of Double-Fetch Bug.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\AKCG76CN\\8418630.html}
}

@inproceedings{xu2019confirma,
  title = {\{\vphantom\}{{CONFIRM}}\vphantom\{\}: {{Evaluating Compatibility}} and {{Relevance}} of {{Control-flow Integrity Protections}} for {{Modern Software}}},
  shorttitle = {\{\vphantom\}{{CONFIRM}}\vphantom\{\}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Xu, Xiaoyang and Ghaffarinia, Masoud and Wang, Wenhao and Hamlen, Kevin W. and Lin, Zhiqiang},
  year = {2019},
  pages = {1805--1821},
  isbn = {978-1-939133-06-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\S9MS7PD6\\Xu et al. - 2019 - CONFIRM Evaluating Compatibility and Relevance .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\PBPNTGH8\\xu-xiaoyang.html}
}

@inproceedings{xu2021infat,
  title = {In-Fat Pointer: Hardware-Assisted Tagged-Pointer Spatial Memory Safety Defense with Subobject Granularity Protection},
  shorttitle = {In-Fat Pointer},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Xu, Shengjie and Huang, Wei and Lie, David},
  year = {2021},
  month = apr,
  series = {{{ASPLOS}} 2021},
  pages = {224--240},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3445814.3446761},
  abstract = {Programming languages like C and C++ are not memory-safe because they provide programmers with low-level pointer manipulation primitives. The incorrect use of these primitives can result in bugs and security vulnerabilities: for example, spatial memory safety errors can be caused by dereferencing pointers outside the legitimate address range belonging to the corresponding object. While a range of schemes to provide protection against these vulnerabilities have been proposed, they all suffer from the lack of one or more of low performance overhead, compatibility with legacy code, or comprehensive protection for all objects and subobjects. We present In-Fat Pointer, the first hardware-assisted defense that can achieve spatial memory safety at subobject granularity while maintaining compatibility with legacy code and low overhead. In-Fat Pointer improves the protection granularity of tagged-pointer schemes using object metadata, which is efficient and binary-compatible for object-bound spatial safety. Unlike previous work that devotes all pointer tag bits to object metadata lookup, In-Fat Pointer uses three complementary object metadata schemes to reduce the number pointer tag bits needed for metadata lookup, allowing it to use the left-over bits, along with in-memory type metadata, to refine the object bounds to subobject granularity. We show that this approach provides practical protection of fine-grained spatial memory safety.},
  isbn = {978-1-4503-8317-2},
  keywords = {Bound Checking,Buffer Overflows,Memory Safety,Object Metadata,pointer tagging,Spatial Memory Errors,Subobject Bound Checking,Tagged-pointer},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\DHGFYA79\\Xu et al. - 2021 - In-fat pointer hardware-assisted tagged-pointer s.pdf}
}

@inproceedings{xu2022cooper,
  title = {{{COOPER}}: {{Testing}} the {{Binding Code}} of {{Scripting Languages}} with {{Cooperative Mutation}}},
  shorttitle = {{{COOPER}}},
  booktitle = {Proceedings 2022 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Xu, Peng and Wang, Yanhao and Hu, Hong and Su, Purui},
  year = {2022},
  publisher = {{Internet Society}},
  address = {{San Diego, CA, USA}},
  doi = {10.14722/ndss.2022.24353},
  abstract = {Scripting languages like JavaScript are being integrated into commercial software to support easy file modification. For example, Adobe Acrobat accepts JavaScript to dynamically manipulate PDF files. To bridge the gap between the high-level scripts and the low-level languages (like C/C++) used to implement the software, a binding layer is necessary to transfer data and transform representations. However, due to the complexity of two sides, the binding code is prone to inconsistent semantics and security holes, which lead to severe vulnerabilities. Existing efforts for testing binding code merely focus on the script side, and thus miss bugs that require special program native inputs.},
  isbn = {978-1-891562-74-7},
  langid = {english},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\I3UM2YB5\\Xu et al. - 2022 - COOPER Testing the Binding Code of Scripting Lang.pdf}
}

@inproceedings{yagemann2021automated,
  title = {Automated {{Bug Hunting With Data-Driven Symbolic Root Cause Analysis}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Yagemann, Carter and Chung, Simon P. and Saltaformaggio, Brendan and Lee, Wenke},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {320--336},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3485363},
  abstract = {The increasing cost of successful cyberattacks has caused a mindset shift, whereby defenders now employ proactive defenses, namely software bug hunting, alongside existing reactive measures (firewalls, IDS, IPS) to protect systems. Unfortunately the path from hunting bugs to deploying patches remains laborious and expensive, requires human expertise, and still misses serious memory corruptions. Motivated by these challenges, we propose bug hunting using symbolically reconstructed states based on execution traces to achieve better detection and root cause analysis of overflow, use-after-free, double free, and format string bugs across user programs and their imported libraries. We discover that with the right use of widely available hardware processor tracing and partial memory snapshots, powerful symbolic analysis can be used on real-world programs while managing path explosion. Better yet, data can be captured from production deployments of live software on end-host systems transparently, aiding in the analysis of user clients and long-running programs like web servers. We implement a prototype of our design, Bunkerbuster, for Linux and evaluate it on 15 programs, where it finds 39 instances of our target bug classes, 8 of which have never before been reported and have lead to 1 EDB and 3 CVE IDs being issued. These 0-days were patched by developers using Bunkerbuster's reports, independently validating their usefulness. In a side-by-side comparison, our system uncovers 8 bugs missed by AFL and QSYM, and correctly classifies 4 that were previously detected, but mislabeled by AddressSanitizer. Our prototype accomplishes this with 7.21\% recording overhead.},
  isbn = {978-1-4503-8454-4},
  keywords = {bug hunting,processor tracing,symbolic analysis},
  annotation = {3 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WA2D5LXJ\\Yagemann et al. - 2021 - Automated Bug Hunting With Data-Driven Symbolic Ro.pdf}
}

@inproceedings{yee2009native,
  title = {Native {{Client}}: {{A Sandbox}} for {{Portable}}, {{Untrusted}} X86 {{Native Code}}},
  shorttitle = {Native {{Client}}},
  booktitle = {2009 30th {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen, J. Bradley and Muth, Robert and Ormandy, Tavis and Okasaka, Shiki and Narula, Neha and Fullagar, Nicholas},
  year = {2009},
  month = may,
  pages = {79--93},
  issn = {2375-1207},
  doi = {10.1109/SP.2009.25},
  abstract = {This paper describes the design, implementation and evaluation of Native Client, a sandbox for untrusted x86 native code. Native Client aims to give browser-based applications the computational performance of native applications without compromising safety. Native Client uses software fault isolation and a secure runtime to direct system interaction and side effects through interfaces managed by Native Client. Native Client provides operating system portability for binary code while supporting performance-oriented features generally absent from Web application programming environments, such as thread support, instruction set extensions such as SSE, and use of compiler intrinsics and hand-coded assembler. We combine these properties in an open architecture that encourages community review and 3rd-party tools.},
  keywords = {Application software,Assembly systems,High performance computing,Java,Manuals,Operating systems,Physics computing,Privacy,Security,World Wide Web,Yarn},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BL25SSVY\\Yee et al. - 2009 - Native Client A Sandbox for Portable, Untrusted x.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\GQWUXRA4\\5207638.html}
}

@inproceedings{yin2022finding,
  title = {Finding {{SMM Privilege-Escalation Vulnerabilities}} in {{UEFI Firmware}} with {{Protocol-Centric Static Analysis}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Yin, Jiawei and Li, Menghao and Wu, Wei and Sun, Dandan and Zhou, Jianhua and Huo, Wei and Xue, Jingling},
  year = {2022},
  month = apr,
  pages = {1570--1570},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00141},
  abstract = {The Unified Extensible Firmware Interface (UEFI) provides a specification of the software interface between an OS and its underlying platform firmware. The runtime services provided are seemingly secure as they reside in System Management Mode (SMM) at ring -2, assuming a higher privilege than the OS kernel at ring 0. However, their software vulnerabilities are known to be exploitable to launch ring 0 to ring -2 privilege escalation, i.e., SMM privilege escalation attacks. In this paper, we introduce an effective static analysis framework for detecting SMM privilege escalation vulnerabilities in UEFI firmware. We present a systematic study of such vulnerabilities and identify their root causes as being two types of references that can escape from the SMRAM, legacy references and unintentional references. Existing static analyses are ineffective in detecting such vulnerabilities in stripped COTS UEFI firmware images, which are developed based on a customized callback mechanism that organizes callable functions into protocols identified by GUIDs. By leveraging such a callbackbased programming paradigm, we introduce SPENDER, the first static detection framework, which is founded on a novel protocolcentric analysis, for uncovering the potential SMM privilege escalation vulnerabilities in UEFI firmware efficiently and precisely. For a total of 1148 UEFI binaries collected from eight vendors, SPENDER has successfully found 36 SMM privilege escalation vulnerabilities (two 1-day and 34 0-day vulnerabilities), which can cause arbitrary code execution and arbitrary address write (and can thus enable, e.g., the attackers to install a bootkit into a flash drive). We have reported these 36 vulnerabilities to the vendors, with the two 1-day vulnerabilities confirmed as known previously but the 34 0-day vulnerabilities confirmed as new.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9ZJX8I4Y\\1CIO8ohxLC8.html}
}

@misc{yoo2021inkernel,
  title = {In-{{Kernel Control-Flow Integrity}} on {{Commodity OSes}} Using {{ARM Pointer Authentication}}},
  author = {Yoo, Sungbae and Park, Jinbum and Kim, Seolheui and Kim, Yeji and Kim, Taesoo},
  year = {2021},
  month = dec,
  number = {arXiv:2112.07213},
  eprint = {2112.07213},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  doi = {10.48550/arXiv.2112.07213},
  abstract = {This paper presents an in-kernel, hardware-based control-flow integrity (CFI) protection, called PAL, that utilizes ARM's Pointer Authentication (PA). It provides three important benefits over commercial, state-of-the-art PA-based CFIs like iOS's: 1) enhancing CFI precision via automated refinement techniques, 2) addressing hindsight problems of PA for in kernel uses such as preemptive hijacking and brute-forcing attacks, and 3) assuring the algorithmic or implementation correctness via post validation. PAL achieves these goals in an OS-agnostic manner, so could be applied to commodity OSes like Linux and FreeBSD. The precision of the CFI protection can be adjusted for better performance or improved for better security with minimal engineering efforts if a user opts in to. Our evaluation shows that PAL incurs negligible performance overhead: e.g., {$<$}1\% overhead for Apache benchmark and 3\textasciitilde 5\% overhead for Linux perf benchmark on the latest Mac mini (M1). Our post-validation approach helps us ensure the security invariant required for the safe uses of PA inside the kernel, which also reveals new attack vectors on the iOS kernel. PAL as well as the CFI-protected kernels will be open sourced.},
  archiveprefix = {arXiv},
  keywords = {cfi,Computer Science - Cryptography and Security,Computer Science - Operating Systems,D.4.6,kernel},
  annotation = {0 citations (Semantic Scholar/arXiv) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\7J2ZLFPR\\Yoo et al. - 2021 - In-Kernel Control-Flow Integrity on Commodity OSes.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\ZSRLWMSY\\Style Lessons in Clarity and Grace by Joseph M. Williams, Joseph Bizup.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\KRMR4HC7\\2112.html}
}

@inproceedings{yoo2022inkernel,
  title = {\{\vphantom\}{{In-Kernel}}\vphantom\{\} \{\vphantom\}{{Control-Flow}}\vphantom\{\} {{Integrity}} on {{Commodity}} \{\vphantom\}{{OSes}}\vphantom\{\} Using \{\vphantom\}{{ARM}}\vphantom\{\} {{Pointer Authentication}}},
  booktitle = {31st {{USENIX Security Symposium}} ({{USENIX Security}} 22)},
  author = {Yoo, Sungbae and Park, Jinbum and Kim, Seolheui and Kim, Yeji and Kim, Taesoo},
  year = {2022},
  pages = {89--106},
  isbn = {978-1-939133-31-1},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\93IBWIJC\\Yoo et al. - 2022 - In-Kernel Control-Flow Integrity on Commodity .pdf;C\:\\Users\\dalo2\\Zotero\\storage\\VHXCACZ2\\yoo.html}
}

@article{yooinkernel,
  title = {In-{{Kernel Control-Flow Integrity}} on {{Commodity OSes}} Using {{ARM Pointer Authentication}}},
  author = {Yoo, Sungbae and Park, Jinbum and Kim, Seolheui and Kim, Yeji and Kim, Taesoo},
  pages = {19},
  abstract = {This paper presents an in-kernel, hardware-based control-flow integrity (CFI) protection, called PAL, that utilizes ARM's Pointer Authentication (PA). It provides three important benefits over commercial, state-of-the-art PA-based CFIs like iOS's: 1) enhancing CFI precision via automated refinement techniques, 2) addressing hindsight problems of PA for inkernel uses such as preemptive hijacking and brute-forcing attacks, and 3) assuring the algorithmic or implementation correctness via post validation.},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\QBXTC3MX\\Yoo et al. - In-Kernel Control-Flow Integrity on Commodity OSes.pdf}
}

@inproceedings{younan2015freesentry,
  title = {{{FreeSentry}}: {{Protecting Against Use-After-Free Vulnerabilities Due}} to {{Dangling Pointers}}},
  shorttitle = {{{FreeSentry}}},
  booktitle = {Proceedings 2015 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Younan, Yves},
  year = {2015},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2015.23190},
  abstract = {Use-after-free vulnerabilities have become an important class of security problems due to the existence of mitigations that protect against other types of vulnerabilities. The effects of their exploitation can be just as devastating as exploiting a buffer overflow, potentially resulting in full code execution within the vulnerable program. Few protections exist against these types of vulnerabilities and they are particularly hard to discover through manual code inspection. In this paper we present FreeSentry: a mitigation that protects against use-after-free vulnerabilities by inserting dynamic runtime checks that invalidate pointers when the associated memory is released. If such an invalidated pointer is accessed, the program will subsequently crash, preventing an attacker from exploiting the vulnerability. When checking dynamically allocated memory, our approach has a moderate performance overhead on the SPEC CPU benchmarks: running with a geometric mean performance impact of around 25\%. It has no overhead when deployed on widely used server side daemons such as OpenSSH or the Apache HTTP daemon. FreeSentry also discovered a previously unknown use-after-free vulnerability in one of the programs in SPEC CPU2000 benchmarks: perlbmk. This vulnerability seems to have been missed by other mitigations.},
  isbn = {978-1-891562-38-9},
  langid = {english},
  annotation = {85 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BTDD9R3H\\Younan - 2015 - FreeSentry Protecting Against Use-After-Free Vuln.pdf}
}

@inproceedings{yu2019data,
  title = {Data {{Oblivious ISA Extensions}} for {{Side Channel-Resistant}} and {{High Performance Computing}}},
  booktitle = {Proceedings 2019 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Yu, Jiyong and Hsiung, Lucas and El'Hajj, Mohamad and Fletcher, Christopher W.},
  year = {2019},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2019.23061},
  abstract = {Blocking microarchitectural (digital) side channels is one of the most pressing challenges in hardware security today. Recently, there has been a surge of effort that attempts to block these leakages by writing programs data obliviously. In this model, programs are written to avoid placing sensitive data-dependent pressure on shared resources. Despite recent efforts, however, running data oblivious programs on modern machines today is insecure and low performance. First, writing programs obliviously assumes certain instructions in today's ISAs will not leak privacy, whereas today's ISAs and hardware provide no such guarantees. Second, writing programs to avoid data-dependent behavior is inherently high performance overhead.},
  isbn = {978-1-891562-55-6},
  langid = {english},
  annotation = {49 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LWJ9LD4P\\Yu et al. - 2019 - Data Oblivious ISA Extensions for Side Channel-Res.pdf}
}

@inproceedings{yun2016apisan,
  title = {\{\vphantom\}{{APISan}}\vphantom\{\}: {{Sanitizing}} \{\vphantom\}{{API}}\vphantom\{\} {{Usages}} through {{Semantic}} \{\vphantom\}{{Cross-Checking}}\vphantom\{\}},
  shorttitle = {\{\vphantom\}{{APISan}}\vphantom\{\}},
  booktitle = {25th {{USENIX Security Symposium}} ({{USENIX Security}} 16)},
  author = {Yun, Insu and Min, Changwoo and Si, Xujie and Jang, Yeongjin and Kim, Taesoo and Naik, Mayur},
  year = {2016},
  pages = {363--378},
  isbn = {978-1-931971-32-4},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\XPSSTNJ9\\Yun et al. - 2016 - APISan Sanitizing API Usages through Semantic.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\UMRLPIZH\\yun.html}
}

@inproceedings{yun2019ginseng,
  title = {Ginseng: {{Keeping Secrets}} in {{Registers When You Distrust}} the {{Operating System}}},
  shorttitle = {Ginseng},
  booktitle = {Proceedings 2019 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Yun, Min Hong and Zhong, Lin},
  year = {2019},
  publisher = {{Internet Society}},
  address = {{San Diego, CA}},
  doi = {10.14722/ndss.2019.23327},
  abstract = {Many mobile and embedded apps possess sensitive data, or secrets. Trusting the operating system (OS), they often keep their secrets in the memory. Recent incidents have shown that the memory is not necessarily secure because the OS can be compromised due to inevitable vulnerabilities resulting from its sheer size and complexity. Existing solutions protect sensitive data against an untrusted OS by running app logic in the Secure world, a Trusted Execution Environment (TEE) supported by the ARM TrustZone technology. Because app logic increases the attack surface of their TEE, these solutions do not work for third-party apps.},
  isbn = {978-1-891562-55-6},
  langid = {english},
  annotation = {20 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\9J285BSA\\ndss2019_01A-2_Yun_paper.pdf}
}

@inproceedings{zeng2011combining,
  title = {Combining Control-Flow Integrity and Static Analysis for Efficient and Validated Data Sandboxing},
  booktitle = {Proceedings of the 18th {{ACM}} Conference on {{Computer}} and Communications Security},
  author = {Zeng, Bin and Tan, Gang and Morrisett, Greg},
  year = {2011},
  month = oct,
  series = {{{CCS}} '11},
  pages = {29--40},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2046707.2046713},
  abstract = {In many software attacks, inducing an illegal control-flow transfer in the target system is one common step. Control-Flow Integrity (CFI) protects a software system by enforcing a pre-determined control-flow graph. In addition to providing strong security, CFI enables static analysis on low-level code. This paper evaluates whether CFI-enabled static analysis can help build efficient and validated data sandboxing. Previous systems generally sandbox memory writes for integrity, but avoid protecting confidentiality due to the high overhead of sandboxing memory reads. To reduce overhead, we have implemented a series of optimizations that remove sandboxing instructions if they are proven unnecessary by static analysis. On top of CFI, our system adds only 2.7\% runtime overhead on SPECint2000 for sandboxing memory writes and adds modest 19\% for sandboxing both reads and writes. We have also built a principled data-sandboxing verifier based on range analysis. The verifier checks the safety of the results of the optimizer, which removes the need to trust the rewriter and optimizer. Our results show that the combination of CFI and static analysis has the potential of bringing down the cost of general inlined reference monitors, while maintaining strong security.},
  isbn = {978-1-4503-0948-6},
  keywords = {binary rewriting,control-flow integrity,inlined reference monitors,sfi,static analysis},
  annotation = {80 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\ZMMZD9NM\\Zeng et al. - 2011 - Combining control-flow integrity and static analys.pdf}
}

@inproceedings{zhang2019bogo,
  title = {{{BOGO}}: {{Buy Spatial Memory Safety}}, {{Get Temporal Memory Safety}} ({{Almost}}) {{Free}}},
  shorttitle = {{{BOGO}}},
  booktitle = {Proceedings of the {{Twenty-Fourth International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Zhang, Tong and Lee, Dongyoon and Jung, Changhee},
  year = {2019},
  month = apr,
  series = {{{ASPLOS}} '19},
  pages = {631--644},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3297858.3304017},
  abstract = {A memory safety violation occurs when a program has an out-of-bound (spatial safety) or use-after-free (temporal safety) memory access. Given its importance as a security vulnerability, recent Intel processors support hardware-accelerated bound checks, called Memory Protection Extensions (MPX). Unfortunately, MPX provides no temporal safety. This paper presents BOGO, a lightweight full memory safety enforcement scheme that transparently guarantees temporal safety on top of MPX's spatial safety. Instead of tracking separate metadata for temporal safety, BOGO reuses the bounds metadata maintained by MPX for both spatial and temporal safety. On free, BOGO scans the MPX bound tables to invalidate the bound of dangling pointers; any following use-after-free error can be detected by MPX as an out-of-bound error. Since scanning the entire MPX bound tables could be expensive, BOGO tracks a small set of hot MPX bound table pages to check on free, and relies on the page fault mechanism to detect any potentially missing dangling pointer, ensuring sound temporal safety protection. Our evaluation shows that BOGO provides full memory safety at 60\% runtime overhead and at 36\% memory overhead for SPEC CPU 2006 benchmarks. We also show that BOGO incurs reasonable 2.7x slowdown for the worst-case malloc-free intensive benchmarks; and moderate 1.34x overhead for real-world applications.},
  isbn = {978-1-4503-6240-5},
  keywords = {memory safety,mpx},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\G5ABZVK5\\Zhang et al. - 2019 - BOGO Buy Spatial Memory Safety, Get Temporal Memo.pdf}
}

@inproceedings{zhang2019pex,
  title = {{{PeX}}: {{A Permission Check Analysis Framework}} for {{Linux Kernel}}},
  shorttitle = {\{\vphantom\}{{PeX}}\vphantom\{\}},
  booktitle = {28th {{USENIX Security Symposium}} ({{USENIX Security}} 19)},
  author = {Zhang, Tong and Shen, Wenbo and Lee, Dongyoon and Jung, Changhee and Azab, Ahmed M. and Wang, Ruowen},
  year = {2019},
  pages = {1205--1220},
  isbn = {978-1-939133-06-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\C5FPLV68\\Zhang et al. - 2019 - PeX A Permission Check Analysis Framework for L.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\G37F9UU3\\zhang-tong.html}
}

@inproceedings{zhang2021statically,
  title = {Statically {{Discovering High-Order Taint Style Vulnerabilities}} in {{OS Kernels}}},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Zhang, Hang and Chen, Weiteng and Hao, Yu and Li, Guoren and Zhai, Yizhuo and Zou, Xiaochen and Qian, Zhiyun},
  year = {2021},
  month = nov,
  series = {{{CCS}} '21},
  pages = {811--824},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484798},
  abstract = {Static analysis is known to yield numerous false alarms when used in bug finding, especially for complex vulnerabilities in large code bases like the Linux kernel. One important class of such complex vulnerabilities is what we call "high-order taint style vulnerability", where the taint flow from the user input to the vulnerable site crosses the boundary of a single entry function invocation (i.e., syscall). Due to the large scope and high precision requirement, few have attempted to solve the problem. In this paper, we present SUTURE, a highly precise and scalable static analysis tool capable of discovering high-order vulnerabilities in OS kernels. SUTURE employs a novel summary-based high-order taint flow construction approach to efficiently enumerate the cross-entry taint flows, while incorporating multiple innovative enhancements on analysis precision that are unseen in existing tools, resulting in a highly precise inter-procedural flow-, context-, field-, index-, and opportunistically path-sensitive static taint analysis. We apply SUTURE to discover high-order taint vulnerabilities in multiple Android kernels from mainstream vendors (e.g., Google, Samsung, Huawei), the results show that SUTURE can both confirm known high-order vulnerabilities and uncover new ones. So far, SUTURE generates 79 true positive warning groups, of which 19 have been confirmed by the vendors, including a high severity vulnerability rated by Google. SUTURE also achieves a reasonable false positive rate (51.23\%) perceived by users of our tool.},
  isbn = {978-1-4503-8454-4},
  keywords = {OS kernels,static program analysis,vulnerability discovery},
  annotation = {2 citations (Semantic Scholar/DOI) [2022-09-01]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\X62PPD6A\\Zhang et al. - 2021 - Statically Discovering High-Order Taint Style Vuln.pdf}
}

@inproceedings{zhang2022one,
  title = {One Size Does Not Fit All: Security Hardening of {{MIPS}} Embedded Systems via Static Binary Debloating for Shared Libraries},
  shorttitle = {One Size Does Not Fit All},
  booktitle = {Proceedings of the 27th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {Zhang, Haotian and Ren, Mengfei and Lei, Yu and Ming, Jiang},
  year = {2022},
  month = feb,
  series = {{{ASPLOS}} 2022},
  pages = {255--270},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3503222.3507768},
  abstract = {Embedded systems have become prominent targets for cyberattacks. To exploit firmware's memory corruption vulnerabilities, cybercriminals harvest reusable code gadgets from the large shared library codebase (e.g., uClibc). Unfortunately, unlike their desktop counterparts, embedded systems lack essential computing resources to enforce security hardening techniques. Recently, we have witnessed a surge of software debloating as a new defense mechanism against code-reuse attacks; it erases unused code to significantly diminish the possibilities of constructing reusable gadgets. Because of the single firmware image update style, static library debloating shows promise to fortify embedded systems without compromising performance and forward compatibility. However, static library debloating on stripped binaries (e.g., firmware's shared libraries) is still an enormous challenge. In this paper, we show that this challenge is not insurmountable for MIPS firmware. We develop a novel system, named uTrimmer, to identify and wipe out unused basic blocks from shared libraries' binary code, without causing additional runtime overhead or memory consumption. We propose a new method to identify address-taken blocks/functions, which further help us maintain an inter-procedural control flow graph to conservatively include library code that could be potentially used by firmware. By capturing address access patterns for position-independent code, we circumvent the challenge of determining code-pointer targets and safely eliminate unused code. We run uTrimmer to debloat shared libraries for SPEC CPU2017 benchmarks, popular firmware applications (e.g., Apache, BusyBox, and OpenSSL), and a real-world wireless router firmware image. Our experiments show that not only does uTrimmer deliver functional programs, but also it can cut the exposed code surface and eliminate various reusable code gadgets remarkably. uTrimmer's debloating capability can compete with the static linking results.},
  isbn = {978-1-4503-9205-1},
  keywords = {embedded systems,software debloating,static analysis},
  annotation = {1 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\BV9JCE6E\\Zhang et al. - 2022 - One size does not fit all security hardening of M.pdf}
}

@inproceedings{zhao2022vsgx,
  title = {{{vSGX}}: {{Virtualizing SGX Enclaves}} on {{AMD SEV}}},
  shorttitle = {{{vSGX}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Zhao, Shixuan and Li, Mengyuan and Zhang, Yinqian and Lin, Zhiqiang},
  year = {2022},
  month = jan,
  pages = {687--702},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00040},
  abstract = {The growing need of trusted execution environment (TEE) has boomed the development of hardware enclaves. However, current TEEs and their applications are tightly bound to the hardware implementation, hindering their compatibility across different platforms. This paper presents vSGX, a novel system to virtualize the execution of an Intel SGX enclave atop AMD SEV. The key idea is to interpose the execution of enclave instructions transparently to support the SGX ISA extensions, consolidate encrypted virtual memory of separated SEV virtual machines to create a single virtualized SGX-like address space, and provide attestations for the authenticity of the TEE and the integrity of enclave software with a trust chain rooted in the SEV hardware. By design, vSGX achieves a comparable level of security guarantees on SEV as that on Intel SGX. We have implemented vSGX and demonstrated it imposes reasonable performance overhead for SGX enclave execution.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TLXJJ8D4\\1A4Q3q3W28E.html}
}

@inproceedings{zhou2014armlock,
  title = {{{ARMlock}}: {{Hardware-based Fault Isolation}} for {{ARM}}},
  shorttitle = {{{ARMlock}}},
  booktitle = {Proceedings of the 2014 {{ACM SIGSAC Conference}} on {{Computer}} and {{Communications Security}}},
  author = {Zhou, Yajin and Wang, Xiaoguang and Chen, Yue and Wang, Zhi},
  year = {2014},
  month = nov,
  pages = {558--569},
  publisher = {{ACM}},
  address = {{Scottsdale Arizona USA}},
  doi = {10.1145/2660267.2660344},
  abstract = {Software fault isolation (SFI) is an effective mechanism to confine untrusted modules inside isolated domains to protect their host applications. Since its debut, researchers have proposed different SFI systems for many purposes such as safe execution of untrusted native browser plugins. However, most of these systems focus on the x86 architecture. In recent years, ARM has become the dominant architecture for mobile devices and gains in popularity in data centers. Hence there is a compelling need for an efficient SFI system for the ARM architecture. Unfortunately, existing systems either have prohibitively high performance overhead or place various limitations on the memory layout and instructions of untrusted modules.},
  isbn = {978-1-4503-2957-6},
  langid = {english},
  keywords = {sfi},
  annotation = {63 citations (Semantic Scholar/DOI) [2022-10-21]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\YEY4V2EF\\Zhou et al. - 2014 - ARMlock Hardware-based Fault Isolation for ARM.pdf}
}

@inproceedings{zhou2022opec,
  title = {{{OPEC}}: Operation-Based Security Isolation for Bare-Metal Embedded Systems},
  shorttitle = {{{OPEC}}},
  booktitle = {Proceedings of the {{Seventeenth European Conference}} on {{Computer Systems}}},
  author = {Zhou, Xia and Li, Jiaqi and Zhang, Wenlong and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
  year = {2022},
  month = mar,
  series = {{{EuroSys}} '22},
  pages = {317--333},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3492321.3519573},
  abstract = {Bare-metal embedded systems usually lack security isolation. Attackers can subvert the whole system with a single vulnerability. Previous research intends to enforce both privilege isolation (to run application code at the unprivileged level) and resource isolation for global variables and peripherals. However, it suffers from partition-time and execution-time over-privilege issues, due to the limited hardware resources (MPU regions) and the improper way to partition a program. In this paper, we propose operation-based isolation for bare-metal embedded systems. An operation is a logically independent task composed of an entry function and all functions reachable from it. To solve the partition-time over-privilege issue, we utilize the global variables shadowing technique to reduce the needed MPU regions to confine the access of the global variables. To mitigate the execution-time over-privilege issue, we split programs into code compartments (called operation) that only contain necessary functions to perform specific tasks, thereby removing the resources needed by unnecessary functions. We implement a prototype called OPEC, which contains an LLVM-based compiler and a reference monitor. The compiler partitions a program and analyzes the resource dependency for each operation. With the hardware-supported privilege levels and MPU, the reference monitor is responsible for enforcing the privilege and resource isolation at runtime. Our evaluation shows that OPEC can achieve the security guarantees for the privilege and resource isolation with negligible runtime overhead (average 0.23\%), moderate Flash overhead (average 1.79\%), and acceptable SRAM overhead (average 5.35\%).},
  isbn = {978-1-4503-9162-7},
  keywords = {hardware-assisted security,memory protection unit,security isolation},
  annotation = {0 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\TZVD3RBV\\Zhou et al. - 2022 - OPEC operation-based security isolation for bare-.pdf}
}

@inproceedings{zhou2022smile,
  title = {{{SMILE}}: {{Secure Memory Introspection}} for {{Live Enclave}}},
  shorttitle = {{{SMILE}}},
  booktitle = {2022 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  author = {Zhou, Lei and Ding, Xuhua and Zhang, Fengwei},
  year = {2022},
  month = apr,
  pages = {1536--1536},
  publisher = {{IEEE Computer Society}},
  issn = {2375-1207},
  doi = {10.1109/SP46214.2022.00107},
  abstract = {SGX enclaves prevent external software from accessing their memory. This feature conflicts with legitimate needs for enclave memory introspection, e.g., runtime stack collection on an enclave under a return-oriented-programming attack. We propose SMILE for enclave owners to acquire live enclave contents with the assistance of a semi-trusted agent installed by the host platform's vendor as a plug-in of the System Management Interrupt handler. SMILE authenticates the enclave under introspection without trusting the kernel nor depending on the SGX attestation facility. SMILE is enclave security preserving as breaking of SMILE does not undermine enclave security. It allows a cloud server to provide the enclave introspection service. We have implemented a SMILE prototype and run various experiments to read enclave code, heap, stack and SSA frames. The total cost for introspecting one page is less than 300 microseconds.},
  isbn = {978-1-66541-316-9},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\SFJKV7PA\\1CIO7GcBPgY.html}
}

@inproceedings{zhu2017understanding,
  title = {Understanding {{The Security}} of {{Discrete GPUs}}},
  booktitle = {Proceedings of the {{General Purpose GPUs}}},
  author = {Zhu, Zhiting and Kim, Sangman and Rozhanski, Yuri and Hu, Yige and Witchel, Emmett and Silberstein, Mark},
  year = {2017},
  month = feb,
  series = {{{GPGPU-10}}},
  pages = {1--11},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3038228.3038233},
  abstract = {GPUs have become an integral part of modern systems, but their implications for system security are not yet clear. This paper demonstrates both that discrete GPUs cannot be used as secure co-processors and that GPUs provide a stealthy platform for malware. First, we examine a recent proposal to use discrete GPUs as secure co-processors and show that the security guarantees of the proposed system do not hold on the GPUs we investigate. Second, we demonstrate that (under certain circumstances) it is possible to bypass IOMMU protections and create stealthy, long-lived GPU-based malware. We demonstrate a novel attack that compromises the in-kernel GPU driver and one that compromises GPU microcode to gain full access to CPU physical memory. In general, we find that the highly sophisticated, but poorly documented GPU hardware architecture, hidden behind obscure close-source device drivers and vendor-specific APIs, not only make GPUs a poor choice for applications requiring strong security, but also make GPUs into a security threat.},
  isbn = {978-1-4503-4915-4},
  annotation = {32 citations (Semantic Scholar/DOI) [2022-08-22]},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\FHTKTBPY\\Zhu et al. - 2017 - Understanding The Security of Discrete GPUs.pdf}
}

@article{zhu2022fuzzing,
  title = {Fuzzing: {{A Survey}} for {{Roadmap}}},
  shorttitle = {Fuzzing},
  author = {Zhu, Xiaogang and Wen, Sheng and Camtepe, Seyit and Xiang, Yang},
  year = {2022},
  month = jan,
  journal = {ACM Computing Surveys},
  issn = {0360-0300},
  doi = {10.1145/3512345},
  abstract = {Fuzz testing (fuzzing) has witnessed its prosperity in detecting security flaws recently. It generates a large number of test cases and monitors the executions for defects. Fuzzing has detected thousands of bugs and vulnerabilities in various applications. Although effective, there lacks systematic analysis of gaps faced by fuzzing. As a technique of defect detection, fuzzing is required to narrow down the gaps between the entire input space and the defect space. Without limitation on the generated inputs, the input space is infinite. However, defects are sparse in an application, which indicates that the defect space is much smaller than the entire input space. Besides, because fuzzing generates numerous test cases to repeatedly examine targets, it requires fuzzing to perform in an automatic manner. Due to the complexity of applications and defects, it is challenging to automatize the execution of diverse applications. In this paper, we systematically review and analyze the gaps as well as their solutions, considering both breadth and depth. This survey can be a roadmap for both beginners and advanced developers to better understand fuzzing.},
  keywords = {Automation,Fuzz Testing,Fuzzing Theory,Input Space,Security},
  annotation = {4 citations (Semantic Scholar/DOI) [2022-08-22] Just Accepted},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\LAJQRSH9\\Zhu et al. - 2022 - Fuzzing A Survey for Roadmap.pdf}
}

@inproceedings{zong2020fuzzguard,
  title = {{{FuzzGuard}}: {{Filtering}} out {{Unreachable Inputs}} in {{Directed Grey-box Fuzzing}} through {{Deep Learning}}},
  shorttitle = {\{\vphantom\}{{FuzzGuard}}\vphantom\{\}},
  booktitle = {29th {{USENIX Security Symposium}} ({{USENIX Security}} 20)},
  author = {Zong, Peiyuan and Lv, Tao and Wang, Dawei and Deng, Zizhuang and Liang, Ruigang and Chen, Kai},
  year = {2020},
  pages = {2255--2269},
  isbn = {978-1-939133-17-5},
  langid = {english},
  file = {C\:\\Users\\dalo2\\Zotero\\storage\\WHDCSQLP\\Zong et al. - 2020 - FuzzGuard Filtering out Unreachable Inputs in D.pdf;C\:\\Users\\dalo2\\Zotero\\storage\\SH23KVJM\\zong.html}
}

